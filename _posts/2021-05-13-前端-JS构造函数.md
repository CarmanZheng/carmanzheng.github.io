---
title: JS构造函数
layout: post
tags: 前端JS
categories: '前端'
---

## 1.构造函数和原型

### 1.1 对象的三种创建方式

1. 字面量方式

   ```js
   var obj = {};
   ```

2. new关键字

   ```js
   var obj = new Object();
   ```

3. 构造函数方式

   ```js
   function Person(name,age){
     this.name = name;
     this.age = age;
   }
   var obj = new Person('zs',12);
   ```

### 1.2 静态成员和实例成员

#### 1.2.1 实例成员

​		实例成员就是构造函数内部通过this添加的成员 ，如下列代码中`uname ,age, sing `就是实例成员。实例成员只能通过实例化的对象来访问。

```js
 function Star(uname, age) {
     this.uname = uname;
     this.age = age;
     this.sing = function() {
     console.log('我会唱歌');
    }
}
var ldh = new Star('刘德华', 18);
console.log(ldh.uname);//实例成员只能通过实例化的对象来访问
```

#### 1.2.2 静态成员

​		静态成员 在构造函数本身上添加的成员  如下列代码中 `sex` 就是静态成员,静态成员只能通过构造函数来访问

```js
 function Star(uname, age) {
     this.uname = uname;
     this.age = age;
     this.sing = function() {
     console.log('我会唱歌');
    }
}
Star.sex = '男';
var ldh = new Star('刘德华', 18);
console.log(Star.sex);//静态成员只能通过构造函数来访问
```

### 1.3 构造函数的问题

​		构造函数方法很好用，但是存在浪费内存的问题。

![](../../assets/images/20210513profunciton/img1.png)

### 1.4 构造函数原型prototype

​		构造函数通过原型分配的函数是所有对象所共享的。

​		JavaScript 规定，每一个构造函数都有一个prototype 属性，指向另一个对象。注意这个prototype就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。

​		我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。

```js
function Star(uname, age) {
    this.uname = uname;
    this.age = age;
}
Star.prototype.sing = function() {
	console.log('我会唱歌');
}
var ldh = new Star('刘德华', 18);
var zxy = new Star('张学友', 19);
ldh.sing();//我会唱歌
zxy.sing();//我会唱歌
```

![](../../assets/images/20210513profunciton/img7.png)

### 1.5 对象原型

​		对象都会有一个属性 `__proto__` 指向构造函数的 `prototype `原型对象，`__proto__`对象原型和原型对象 prototype 是等价的。
`__proto__`对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线。

​		但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype。

<img src="../../assets/images/20210513profunciton/img2.png" style="zoom:67%;" />

<img src="../../assets/images/20210513profunciton/img31.png" style="zoom:80%;" />

### 1.6 constructor构造函数

​		对象原型（ `__proto__`）和构造函数（`prototype`）原型对象里面都有一个属性 constructor 属性 ，constructor 我们称为构造函数，因为它指回构造函数本身。

​		constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。
​		

​		一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor  就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。

​		如果我们修改了原来的原型对象，给原型对象赋值的是一个对象，则必须手动的利用constructor指回原来的构造函数如:

```js
 function Star(uname, age) {
     this.uname = uname;
     this.age = age;
 }

 // 很多情况下,我们需要手动的利用constructor 这个属性指回 原来的构造函数
 Star.prototype = {
	 // 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数
     // 手动设置指回原来的构造函数
   constructor: Star, 
   sing: function() {
     console.log('我会唱歌');
   },
   movie: function() {
     console.log('我会演电影');
   }
}
var zxy = new Star('张学友', 19);
console.log(zxy)
```

以上代码运行结果，设置`constructor`属性如图:

![](../../assets/images/20210513profunciton/img8.png)

如果未设置`constructor`属性,如图:

![](../../assets/images/20210513profunciton/img9.png)



### 1.7 原型链

​	每一个实例对象又有一个`__proto__`属性，指向的构造函数的原型对象。构造函数的原型对象也是一个对象，也有`__proto__`属性，这样一层一层往上找就形成了原型链。

![](D:\07_GitHub\GitHub_Blogs\assets\images\20210513profunciton\img5.png)

### 1.8 构造函数实例和原型对象三角关系

1.构造函数的`prototype`属性指向了构造函数原型对象
2.实例对象是由构造函数创建的，实例对象的`__proto__`属性指向了构造函数的原型对象
3.构造函数的原型对象的`constructor`属性指向了构造函数，实例对象的原型的constructor属性也指向了构造函数

![](D:\07_GitHub\GitHub_Blogs\assets\images\20210513profunciton\img4.png)

### 1.9 原型链和成员的查找机制

​		任何对象都有原型对象，也就是prototype属性。

​		任何原型对象也是一个对象，即对象就有`__proto__`属性，这样一层一层往上找,就形成了一条链，我们称此为原型链。

```js
1. 当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。
2. 如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象）。
3. 如果还没有,就查找原型对象的原型（Object的原型对象）。
	依此类推一直找到 Object 为止（null）。

```

`__proto__`对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。

### 1.10 原型对象中this指向

​		构造函数中的this和原型对象的this，都指向我们new出来的**实例对象**

```js
function Star(uname, age) {
    this.uname = uname;
    this.age = age;
}
var that;
Star.prototype.sing = function() {
    console.log('我会唱歌');
    that = this;
}
var ldh = new Star('刘德华', 18);
// 1. 在构造函数中,里面this指向的是对象实例 ldh
console.log(that === ldh);//true
// 2.原型对象函数里面的this 指向的是 实例对象 ldh
```

![](D:/02_Task/05_1前端开发/01_明阳培训01/课程16/images/img6.png)

### 1.11 通过原型为数组扩展内置方法

```js
 Array.prototype.sum = function() {
   var sum = 0;
   for (var i = 0; i < this.length; i++) {
   sum += this[i];
   }
   return sum;
 };
 // 此时数组对象中已经存在sum()方法了 ， 可以使用 数组.sum() 进行数据的求和
```

## 2.构造函数继承

![image-20220425141101094](D:\07_GitHub\GitHub_Blogs\assets\images\20210513profunciton\image-20220425141101094.png)

[JS 常见的 6 种继承方式](https://blog.csdn.net/jatej/article/details/120317973)

### 2.1 第一种：原型链继承

​		原型链继承是比较常见的继承方式之一，其中涉及的构造函数、原型和实例，三者之间存在着一定的关系，即每一个构造函数都有一个原型对象，原型对象又包含一个指向构造函数的指针，而实例则包含一个原型对象的指针。

```js
function Parent1() {
    this.name = 'parent1';
    this.play = [1, 2, 3]
  }
function Child1() {
    this.type = 'child2';
}
Child1.prototype = new Parent1();
console.log(new Child1());
```

​		上面的代码看似没有问题，虽然父类的方法和属性都能够访问，但其实有一个潜在的问题，我再举个例子来说明这个问题。

```js
let s1 = new Child1();
let s2 = new Child2();
s1.play.push(4);
console.log(s1.play, s2.play);
```

​		这段代码在控制台执行之后，可以看到结果如下：

<img src="D:\07_GitHub\GitHub_Blogs\assets\images\20210513profunciton\20210915215831428.png" style="zoom:80%;" />



​		明明我只改变了 s1 的 play 属性，为什么 s2 也跟着变了呢？

​		原因很简单，因为两个实例使用的是同一个原型对象。它们的内存空间是共享的，当一个发生变化的时候，另外一个也随之进行了变化，这就是使用原型链继承方式的一个缺点。

那么要解决这个问题的话，我们就得再看看其他的继承方式，下面我们看看能解决原型属性共享问题的第二种方法。

### 2.2 第二种 ：call()

- call()可以调用函数
- call()可以修改`this`的指向,使用`call()`的时候 参数一是修改后的`this`指向，`参数2,参数3..`使用逗号隔开连接

```js
 function fn(x, y) {
     console.log(this);
     console.log(x + y);
}
  var o = {
  	name: 'andy'
  };
  fn.call(o, 1, 2);//调用了函数此时的this指向了对象o,
```

![](D:/02_Task/05_1前端开发/01_明阳培训01/课程16/images/img10.png)

子构造函数继承父构造函数中的属性

1. 先定义一个父构造函数
2. 再定义一个子构造函数
3. 子构造函数继承父构造函数的属性(使用call方法)

```js
 // 1. 父构造函数
 function Father(uname, age) {
   // this 指向父构造函数的对象实例
   this.uname = uname;
   this.age = age;
 }
  // 2 .子构造函数 
function Son(uname, age, score) {
  // this 指向子构造函数的对象实例
  // 3.使用call方式实现子继承父的属性
  Father.call(this, uname, age);
  this.score = score;
}
var son = new Son('刘德华', 18, 100);
console.log(son);
```

![](D:/02_Task/05_1前端开发/01_明阳培训01/课程16/images/img11.png)

### 2.2 借用原型对象继承方法

1. 先定义一个父构造函数
2. 再定义一个子构造函数
3. 子构造函数继承父构造函数的属性(使用call方法)

```js
// 1. 父构造函数
function Father(uname, age) {
  // this 指向父构造函数的对象实例
  this.uname = uname;
  this.age = age;
}
Father.prototype.money = function() {
  console.log(100000);
 };

 // 2 .子构造函数 
  function Son(uname, age, score) {
      // this 指向子构造函数的对象实例
      Father.call(this, uname, age);
      this.score = score;
  }

// Son.prototype = Father.prototype;  这样直接赋值会有问题,如果修改了子原型对象,父原型对象也会跟着一起变化
Son.prototype = new Father();
// 如果利用对象的形式修改了原型对象,别忘了利用constructor 指回原来的构造函数
Son.prototype.constructor = Son;
// 这个是子构造函数专门的方法
Son.prototype.exam = function() {
    console.log('孩子要考试');

}
var son = new Son('刘德华', 18, 100);
console.log(son);
```

如上代码结果如图:

![](D:/02_Task/05_1前端开发/01_明阳培训01/课程16/images/img12.png)

## 