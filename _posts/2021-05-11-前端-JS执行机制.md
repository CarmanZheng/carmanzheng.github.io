---
title: JS执行机制
layout: post
tags: 前端JS
categories: '前端'
---

## 1.概述

​		JavaScript语言的一大特点就是**单线程**，即同一个时间只能做一件事。

​		单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。

​		这样所导致的问题是： 如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。

## 2.同步任务和异步任务

​		为了解决单线程问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制。于是，JS 中出现了**同步任务**和**异步任务**。

### 2.1同步

​		前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。比如做饭的同步做法：我们要烧水煮饭，等水开了（10分钟之后），再去切菜，炒菜。

### 2.2异步

​		你在做一件事情时，因为这件事情会花费很长时间，在做这件事的同时，你还可以去处理其他事情。比如做饭的异步做法，我们在烧水的同时，利用这10分钟，去切菜，炒菜。

![](../../assets/images/20210512JS_exec_rule/1551434972778.png)

## 3.事件循环

![](../../assets/images/20210512JS_exec_rule/1551435335464.png)

<img src="../../assets/images/20210512JS_exec_rule/1551435398306.png" style="zoom:150%;" />

### 3.1 setTimeout

大名鼎鼎的setTimeout无需再多言，大家对他的第一印象就是异步可以延时执行，我们经常这么实现延时3秒执行：

```js
setTimeout(() => {
		console.log('延时3秒');
},3000)
```

​		渐渐的setTimeout用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数，这又咋回事啊？

先看一个例子：

```js
setTimeout(() => {
	task();
},3000)
console.log('执行console')
```

​		根据前面我们的结论，setTimeout是异步的，应该先执行console.log这个同步任务，所以我们的结论是：

```js
//执行console
//task()复制代码
去验证一下，结果正确！
然后我们修改一下前面的代码：
setTimeout(() => {
	task()
},3000)
sleep(10000000)
```

​		乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行task()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？

​		这时候我们需要重新理解setTimeout的定义。我们先说上述代码是怎么执行的：

1. task()进入Event Table并注册,计时开始。
2. 执行sleep函数，很慢，非常慢，计时仍在继续。
3. 3秒到了，计时事件timeout完成，task()进入Event Queue，但是sleep也太慢了吧，还没执行完，只好等着。
4. sleep终于执行完了，task()终于从Event Queue进入了主线程执行。



​		我们还经常遇到setTimeout(fn,0)这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？

​		答案是不会的，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明：

```js
//代码1
console.log('先执行这里');
setTimeout(() => {
	console.log('执行啦')
},0);

//代码2
console.log('先执行这里');
	setTimeout(() => {
	console.log('执行啦')
},3000);

代码1的输出结果是：
//先执行这里
//执行啦
代码2的输出结果是：
//先执行这里
// ... 3s later
// 执行啦
```

​		关于setTimeout要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。

### 3.2 setInterval

​		setInterval会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。

​		唯一需要注意的一点是，对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是**每过ms秒，会有fn进入Event Queue。**