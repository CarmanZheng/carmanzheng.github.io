---
title: VueX与路由
layout: post
tags: 前端Vue
categories: '前端'
---

## 1.Vuex

### 1.概念

​	专门在Vue中实现集中式状态（数据）管理的一个Vue**插件**，对Vue应用中多个组件的共享状态进行集中式的管理（读写），也是组件间通信的方式，且**适用于任意组件间通信**。

<img src="../../assets/images/20220521VueVuexRouter/image-20220428172241332.png" alt="image-20220428172241332" style="zoom:67%;" />

1. 所有组件的数据进行统一管理（存储和变更），每个组件内部就不再需要维护这些数据了
2. 数据变更时，**统一修改Store中数据即可**，组件中用到这个数据的组件会自动更新（数据是响应式的）

### 2.Vuex应用场景

​		如果需要构建一个中大型单页应用，Vuex 将会成为自然而然的选择，Vuex能够保持多个组件间的数据一致。

对于中大型应用，就需要摒弃小应用中的`props方法`和`全局事件总线`

1. 多个组件依赖于同一状态
2. 来自不同组件的行为需要变更同一状态

<img src="../../assets/images/20220521VueVuexRouter/image-20211202183106434.png" alt="image-20211202183106434" style="zoom: 50%;" />

### 3.安装

```sh
npm install vuex --save

#  上面不行就用下面的
npm i vuex --legacy-peer-deps
```

需要在根目录下面创建文件夹`store`,并在`store`文件夹下创建`index.js`

```js
root-|
     | ---  node_modulesnode
     | ---  public
     | ---  src
     |		| --- main.js		
     | ---  git
     | ---  .gitignoregit
     | ---  babel.config.js
     | ---  package.json
     | ---  package.lock.json
     | ---  README.md
     | ---  store
			| ---index.js
```

`store/index.js`

```js
//该文件用于创建Vuex中最为核心的store
// 引入Vue
import Vue from 'vue'
// 引入Vuex
import Vuex from 'vuex'
Vue.use(Vuex)


// 准备actions - 用于相应组件中的动作，用来写动作
const actions ={}
// 准备mutations - 用于操作数据（state），用来写操作函数
const mutations ={}
// 准备state -- 用于定义和存储数据
const state={}



// 创建并暴露store，这个store相当于数据存储的库
const store =  new Vuex.Store({
    actions,
    mutations,
    state,
})

export default store
```

`main.js`

```js
...
import store from './store/index.js'
new Vue({
    el:"#app",
    render:h=>h(App),
    store,
    beforeCreate(){
        Vue.prototype.$bus =this
    }
})
```

### 4.基本使用

| 模块      | 说明                                                         |
| --------- | ------------------------------------------------------------ |
| state     | 定义应用状态的数据结构，可以在这里设置默认的初始状态         |
| getters   | 允许组件从 store 中获取数据                                  |
| mutations | 用来更改state的唯一标准方式，且必须是同步函数                |
| actions   | 组件通过调用actions来提交mutation，不是直接变更状态，可以包含任意异步操作 |
| modules   | 每个module都有自己的state，getters，mutations，actions       |

​		对变量的增删改查

#### 4.1 state

**第一种访问方式：通过 this引入**

​		假设我们有一个全局状态 `count` 的值为 5。那么，我们就可以将其定义为 `state` 对象中的 `key` 和 `value`，作为全局状态供我们使用。如下：

```js
//创建一个 store
const store = new Vuex.Store({
    //state存储应用层的状态
    state:{
        count:5  //总数：5
    }
});
```

```js
// 把state中数据，定义在组件内的计算属性中
computed: {
  // 1. 最完整的写法
  // count: function () {
  //   return this.$store.state.count
  // },
  // 2. 缩写
  count () {
    return this.$store.state.count
  }
}
// 不能使用箭头函数  this指向的不是vue实例，实际上用的是父级函数中的this
```

1. state中的数据是自定义的，但是state属性名是固定的
2. 获取数据可以通过 $store.state
3. 可以使用计算属性优化模板中获取数据的方式
4. 计算属性不可以使用箭头函数（箭头函数本身是没有this的，实际上用的是父级函数中的this）

**第二种访问方式：mapState**

```js
// 1. 从vuex中按需导入mapState函数
import { mapState } from 'vuex' 
// 2.通过导入的mapState函数，将当前组件需要的全局数据，映射为当前组件的computed计算属性
computed:{
    ...mapState(['count'])
}
// 这时候，count作为组件的一个计算属性，直接使用就ok了
```

#### 4.2 Getters

​		**可以认为，`getters` 是store的计算属性，类似于`computed`，对state里的数据进行一些过滤，改造等等**

​		假设我们要在`state.count`的基础上派生出一个新的状态`newCount`出来，就适合使用我们的 `getters`，`getters` 接受 `state` 作为其第一个参数。

```js
const store = new Vuex.Store({
    //state存储应用层的状态
    state:{
        count:5  //总数：5
    },
    getters:{
        newCount:state => state.count * 3;
        showNum(state){
    return "当前最新的数量是"+ state.count
}
                             }
                             })
```

在组件中获取 `{{newCount}}` 方式：

```js
export default {
    computed: {
        newCount(){
            return this.$store.getters.newCount;
        }
    }
};  
```

第二种方式，通过`mapGetters`，引入getters中的变量，作为计算属性，直接使用即可

```vue
<template>
    <div>
            {{showNum}}
     </div>
</template>

<script>
    import { mapGetters } from 'vuex'
    methods: {
        ...mapGetters(['showNum'])
    }
</script>
```

#### 4.3  Mutations

​		**`Vuex` 给我们提供修改仓库 `store`中的状态的唯一办法就是通过提交`mutation` ，且必须是`同步函数`**

​		**只有`mutaitons`才有修改state中数据的权利**

我们在 `mutations`中定义了一个叫`increment`的函数，函数体就是我们要进行更改的地方，

`Mutations` 中的`increment`函数会接受 `state`作为第一个参数，第二个是自定义传参

```js
const store = new Vuex.Store({
    //state存储应用层的状态
    state:{
        count:5  //总数：5
    },
    // mutations是修改state中数据的唯一途径
    mutations:{
        increment(state，value){
            state.count += value;
        }
    }
});
```

我们在提交`commit`时候，第一个参数`"increment"`，就是对应在 `mutations`中的`increment`方法，第二个参数是自定义值。例如：

```js
methods: {
    getVal() {
        let value = 10;
        //通过commit调用一个名为increment的mutation
        this.$store.commit("increment", value);
    }
}
```

除了通过`commit`调用，`vuex`提供了`mapmutations`供组件方便调用store中的`mutation`

```js
import { mapMutations } from 'vuex'
methods: {
    ...mapMutations(['increment'])
    getVal() {
        let value = 10;
        //通过commit调用一个名为increment的mutation
        this.increment(value);
    }
}
```

#### 4.4 Action

1. 用于提交 `mutation`，而不是直接变更状态，**可以包含`任意异步操作`**
2. 只有通过 `action => mutations => states` ，这个流程进行操作，具体步骤如下：

```js
export default new Vuex.Store({
    //1.存放数据
    state: {
        obj: {},
    },
    //4. 通过commit mutations中的方法来处理
    mutations: {
        getParam(state, Object) {
            //5.修改state中的数据
            state.obj = Object
        }
    },
    //2.接受dispatch传递过来的方法和参数
    actions: {
        getParamAsync(store, Object) {
            // 处理异步操作
            setTimeout(() => {
                // 3.通过commit提交一个名为getParam的mutation
                // action 函数接收一个 store 的实例对象，因此可以调用 store.commit 提交一个 mutation
                store.commit("getParam", Object);
            }, 1000)
        }
    }
})
```

然后我们就在组件里这么调用就可以了。

**注意：只能通过`dispatch`方法触发action**

```js
methods: {
   getVal() {
	  let name= "xia";
	  let age= "26";
	  let sex= "man";
	  // 1.通过dispatch将方法getParamSync和多个参数{name,age,sex}传递给actions
	  this.$store.dispatch("getParamSync",{name,age,sex})
   }
}
```

第二种引入方式`mapAction`

```js
1. 从vuex中按需导入 mapActions函数
import { mapAcitons } from 'vuex'
2. 通过指定的actions函数，映射为当前组件的methods函数
methods:{
    ...mapAcitons(['getParamSync']),
        // 可以定义函数调用，也可以直接调用getParamSync
        // mapAcitons相当于将acitons中的函数直接映射到本组件中，属于本组件的方法，所以可以直接用
     getVal() {
        this.getParamSync({name,age,sex})
    }
}
```

#### 4.5 Modules

​		随着项目的复杂度增大，为了方便管理 Vuex，一般会将其按功能分割成不同的模块(`Module`)，方便日后管理。每个模块拥有自己的 `state`、`mutation`、`action`、`getter` 甚至是嵌套子模块

```js
import Vue from "vue"
import Vuex from "vuex"
import state from "./state"
import mutations from "./mutations"
import actions from "./actions"
import * as getters from "./getters"

import moduleA from "./module/moduleA" // 模块A
import moduleB from "./module/moduleB" // 模块B

Vue.use(Vuex)

export default new Vuex.Store({
    actions,
    getters,
    state,
    mutations,
    modules: {
        moduleA,
        moduleB
    }
})
```

`moduleA.js` / `moduleB.js` 文件

```js
// 每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块
export default {
    state: {
        text: "moduleA"
    },
    getters: {},
    mutations: {},
    actions: {}
}
```

然后我们就在组件里这么调用就可以了

```vue
<template>
<div class="demo">
    <h1>{{getText1}}</h1>
    <h1>{{getText2}}</h1>
    </div>
</template>
<script>
    computed: {
        getText1(){
            return this.$store.state.moduleA.text;
        },
            //或
            ...mapState({
                getText2: state => state.moduleB.text;
            })
    }
</script>
```

由此可知，模块内部的 state 是**局部**的，只属于模块本身所有，所以外部必须通过对应的模块名进行访问。

## 参考链接

1.[最详细Vuex教程（超详细）-基本使用](https://blog.csdn.net/weixin_55537701/article/details/118031388?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2.pc_relevant_antiscanv2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2.pc_relevant_antiscanv2&utm_relevant_index=5)

2.[Vuex从入门到实战(这个讲的很详细，建议看)](https://www.bilibili.com/video/BV1h7411N7bg?p=14&spm_id_from=pageDriver)