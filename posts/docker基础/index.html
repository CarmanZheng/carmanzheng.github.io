<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="天前"><meta name="hour-prompt" content="小时前"><meta name="minute-prompt" content="分钟前"><meta name="justnow-prompt" content="刚刚"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="Docker基础" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="本文主要对docker的基础知识进行介绍，了解docker的镜像、容器和仓库。" /><meta property="og:description" content="本文主要对docker的基础知识进行介绍，了解docker的镜像、容器和仓库。" /><link rel="canonical" href="https://carmanzheng.github.io//posts/docker%E5%9F%BA%E7%A1%80/" /><meta property="og:url" content="https://carmanzheng.github.io//posts/docker%E5%9F%BA%E7%A1%80/" /><meta property="og:site_name" content="Technical Blogs" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-02-15T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Docker基础" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"本文主要对docker的基础知识进行介绍，了解docker的镜像、容器和仓库。","headline":"Docker基础","dateModified":"2022-05-20T10:52:14+08:00","datePublished":"2022-02-15T00:00:00+08:00","url":"https://carmanzheng.github.io//posts/docker%E5%9F%BA%E7%A1%80/","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://carmanzheng.github.io//posts/docker%E5%9F%BA%E7%A1%80/"},"@context":"https://schema.org"}</script><title>Docker基础 | Technical Blogs</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Technical Blogs"><meta name="application-name" content="Technical Blogs"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="zh-CN"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/favicons/android-chrome-192x192.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Technical Blogs</a></div><div class="site-subtitle font-italic">Learning by Doing, Sharing for more!</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/Carmanzheng" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['zhengkan1993','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>Docker基础</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Docker基础</h1><div class="post-meta text-muted"><div> 作者 <em> <a href="https://github.com/carmanzheng">carmanzheng</a> </em></div><div class="d-flex"><div> <span> 发表于 <em class="timeago" date="2022-02-15 00:00:00 +0800" data-toggle="tooltip" data-placement="bottom" title="2022-02-15, 00:00 +0800" >02-15</em> </span> <span> 更新于 <em class="timeago" date="2022-05-20 10:52:14 +0800 " data-toggle="tooltip" data-placement="bottom" title="2022-05-20, 10:52 +0800" >05-20</em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="7167 字"> <em>39 分钟</em>阅读</span></div></div></div><div class="post-content"><p>本文主要对docker的基础知识进行介绍，了解docker的镜像、容器和仓库。</p><h3 id="1镜像">1.镜像<a href="#1镜像" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>docker的镜像实由一层一层的文件系统组成，这种层级的文件系统采用联合文件系统编写（UnionFS)，优点：共享资源。</p><p>即有多个镜像从相同的base镜像构建而来，那么宿主机上只需要在磁盘上保存一份base镜像，同时内存中只需要加载一份base镜像，就可以为所有容器提供服务了，且镜像的每一层都能被共享。</p><p><strong>bootfs(boot files system)</strong></p><p>​ 主要包含bootloader和kernel，bootloader主要是引导加载kernel。Linux刚启动会加载bootfs文件系统，在docker镜像的最底层就是bootfs。这一层与典型的Linux/Unix系统一样的，包含boot加载器和内核。当boot加载完成后，整个内核就在内存当中，此时<strong>内存的使用权由bootfs转交为内核，然后系统也会卸载bootfs</strong>。</p><p>典型的Linux启动到运行需要两个FS - bootfs + rootfs (从功能角度而非文件系统角度)</p><p><img data-src="../../assets/images/20220215docker/format" alt="img" style="zoom:50%;" data-proofer-ignore></p><p><strong>rootfs</strong></p><p>​ rootfs（(root file system) ）在bootfs之上，包含的就是典型的Linux系统中的/dev,/proc,/bin,/ect等标准目录和文件。rootfs就是不同操作系统的发行版，比如Ubuntu，CentOS等等。</p><p>​ 典型的Linux在启动后，首先将 rootfs 置为 readonly, 进行一系列检查, 然后将其切换为 “readwrite” 供用户使用。在docker中，起初也是将 rootfs 以readonly方式加载并检查，然而接下来利用 union mount 的将一个 readwrite 文件系统挂载在 readonly 的rootfs之上，并且允许再次将下层的 file system设定为readonly 并且向上叠加, 这样一组readonly和一个writeable的结构构成一个container的运行目录, 每一个被称作一个Layer。（图 [1,2]）</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center"><img data-src="../../assets/images/20220217docker/2" alt="img" style="zoom: 50%;" data-proofer-ignore><th style="text-align: center"><img data-src="../../assets/images/20220217docker/3" alt="img" style="zoom:50%;" data-proofer-ignore><tbody><tr><td style="text-align: center"><img data-src="../../assets/images/20220217docker/4" alt="img" style="zoom:50%;" data-proofer-ignore><td style="text-align: center"><img data-src="../../assets/images/20220217docker/5" alt="img" style="zoom:50%;" data-proofer-ignore><tr><td style="text-align: center"><img data-src="../../assets/images/20220217docker/6" alt="img" style="zoom:50%;" data-proofer-ignore><td style="text-align: center"><img data-src="../../assets/images/20220217docker/7" alt="img" style="zoom:50%;" data-proofer-ignore><tr><td style="text-align: center"><img data-src="../../assets/images/20220217docker/8" alt="img" style="zoom:50%;" data-proofer-ignore><td style="text-align: center"> </table></div><p>参考 ：https://baike.baidu.com/item/Docker/13344470?fr=aladdin</p><h3 id="2镜像命令">2.镜像命令<a href="#2镜像命令" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>Docker中与镜像操作相关的命令都在docker image这条子命令下，通过docker image –help这条命令，可以看到docker image子命令的详细文档，如下：</p><div class="language-tex highlighter-rouge"><div class="code-header"> <span label-text="TeX"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre>Usage:  docker image COMMAND

Manage images

Commands:
  build       Build an image from a Dockerfile(构建镜像的命令)
  history     Show the history of an image(显示镜像构建历史过程)
  import      Import the contents from a tarball to create a filesystem image(导入一个由容器导出的镜像)
  inspect     Display detailed information on one or more images(显示一个镜像的详细信息)
  load        Load an image from a tar archive or STDIN(从一个文件或标准输入流中导入镜像)
  ls          List images(查看镜像列表)
  prune       Remove unused images(删除虚悬镜像)
  pull        Pull an image or a repository from a registry(从仓库拉取镜像)
  push        Push an image or a repository to a registry(推送镜像到仓库)
  rm          Remove one or more images(删除镜像)
  save        Save one or more images to a tar archive (streamed to STDOUT by default)(保存镜像到文件)
  tag         Create a tag TARGET<span class="p">_</span>IMAGE that refers to SOURCE<span class="p">_</span>IMAGE(给镜像打标签)
</pre></table></code></div></div><h4 id="1构建镜像">1.构建镜像<a href="#1构建镜像" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>构建镜像方式：</p><ol><li><p>从官方仓库或其他镜像仓库拉取别人构建好的镜像</p><li><p>构建自己的镜像 【1. commit方法 2.dockerfile方法（推荐）】</p></ol><div class="language-sh highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="c"># 拉取镜像</span>
<span class="c"># 下载最新版本</span>
<span class="o">(</span>base<span class="o">)</span> zhengkan03@ubuntu:~/桌面<span class="nv">$ </span>docker pull mysql
Using default tag: latest
latest: Pulling from library/mysql
69692152171a: Pull <span class="nb">complete</span>       <span class="c"># 分层下载</span>
1651b0be3df3: Pull <span class="nb">complete 
</span>951da7386bc8: Pull <span class="nb">complete 
</span>0f86c95aa242: Pull <span class="nb">complete 
</span>37ba2d8bd4fe: Pull <span class="nb">complete 
</span>6d278bb05e94: Pull <span class="nb">complete 
</span>497efbd93a3e: Pull <span class="nb">complete 
</span>f7fddf10c2c2: Pull <span class="nb">complete 
</span>16415d159dfb: Pull <span class="nb">complete 
</span>0e530ffc6b73: Pull <span class="nb">complete 
</span>b0a4a1a77178: Pull <span class="nb">complete 
</span>cd90f92aa9ef: Pull <span class="nb">complete 
</span>Digest: sha256:d50098d7fcb25b1fcb24e2d3247cae3fc55815d64fec640dc395840f8fa80969
Status: Downloaded newer image <span class="k">for </span>mysql:latest
docker.io/library/mysql:latest

<span class="c"># 等价</span>
<span class="c"># docker pull mysql </span>
<span class="c"># docker pull docker.io/library/mysql:latest</span>

<span class="c"># 下载指定版本</span>
<span class="c"># docker pull 镜像名[:版本号]</span>
<span class="c"># docker pull mysql:5.7</span>
</pre></table></code></div></div><div class="language-sh highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c"># 构建镜像</span>
<span class="c"># 1. commit方法</span>
<span class="c"># 使用docker commit命令，我们可以将修改过的容器重新提交为一个镜像，如：</span>
<span class="nv">$ </span>docker commit <span class="o">[</span>容器ID] <span class="o">[</span>新生成的文件名]
<span class="nv">$ </span>docker commit conntaner_id my-hello:1.0
<span class="nv">$ </span>docker commit <span class="nt">-m</span><span class="o">=</span><span class="s1">'要提交的信息'</span> <span class="nt">-a</span><span class="o">=</span><span class="s1">'作者'</span> 容器ID 要创建的目标镜像名：版本号
</pre></table></code></div></div><p>一般推荐编写Dockerfile来构建一种镜像，Docker Hub上的镜像都是采用这种方式构建的.</p><p>好处:我们不用把镜像分发给别人，而只是把Dockerfile和相应需要写入镜像的资料发给别人，别人也能自己构建镜像，安全透明</p><h5 id="1-构建步骤">1. 构建步骤<a href="#1-构建步骤" class="anchor"><i class="fas fa-hashtag"></i></a></h5></h5><ol><li>编写一个dockerfile文件<li>docker build 构建成为一个镜像<li>docker run 运行镜像<li>docker push 发布镜像（dockerHub,阿里云）</ol><h5 id="2-dockerfile指令">2. Dockerfile指令<a href="#2-dockerfile指令" class="anchor"><i class="fas fa-hashtag"></i></a></h5></h5><div class="language-sh highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>FROM   		<span class="c"># 基础镜像，一切从这里开始</span>
MAINTIANER 	<span class="c"># 镜像是谁编写的，姓名+邮箱</span>
RUN     	<span class="c"># 镜像构建时候需要运行的命令</span>
ADD			<span class="c"># 步骤，tomcat镜像，添加内容</span>
WORKDIR 	<span class="c"># 镜像的工作目录</span>
VOLUME		<span class="c"># 挂载的目录</span>
EXPOSE		<span class="c"># 暴露对外端口</span>
CMD			<span class="c"># 指定这个容器的启动时候的命令 ,只有最后一个会生效</span>
ENTRYPOINT	<span class="c"># 指定 容器启动时候要运行的命令，可以追加命令</span>
ONBUILD		<span class="c"># 当构建一个被继承Dockerfile，这个时候就会运行ONBUILD</span>
COPY		<span class="c"># 类似ADD	,将文件拷贝到镜像中</span>
ENV			<span class="c"># 构建的时候设置环境变量</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">Dockerfile文件</code></p><div class="language-dockerfile highlighter-rouge"><div class="code-header"> <span label-text="Dockerfile"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c"># 1.构建镜像文件</span>
<span class="k">FROM</span><span class="s"> ubuntu</span>
<span class="k">MAINTAINER</span><span class="s"> Zheng</span>
<span class="k">RUN </span>apt-get update
<span class="k">RUN </span>apt-get <span class="nb">install</span> <span class="nt">-y</span> python3
<span class="k">RUN </span>apt-get <span class="nb">install</span> <span class="nt">-y</span> python3-pip
<span class="k">RUN </span>apt-get <span class="nb">install</span> <span class="nt">-y</span> vim
<span class="k">RUN </span>pip3 <span class="nb">install </span>Flask
<span class="k">RUN </span><span class="nb">mkdir </span>app
<span class="k">ADD</span><span class="s"> . /app</span>
<span class="k">WORKDIR</span><span class="s"> /app/app</span>
<span class="k">CMD</span><span class="s"> ["python3","flask01.py"]</span>
</pre></table></code></div></div><p>开始构建镜像 编写好Dockerfile文件后，需要使用docker build命令进行构建，docker build命令的格式如下：</p><div class="language-sh highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="c"># 2. 通过这个文件创建镜像</span>
<span class="c">#命令 docker build -f dockerfile文件路径 -t 镜像名:版本号</span>
docker build <span class="nt">-f</span> Dockerfile myapp:1.0
</pre></table></code></div></div><p>测试运行刚创建的镜像</p><div class="language-sh highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="c"># 3.测试运行</span>
docker run <span class="nt">-it</span> mycentos：1.0
<span class="c"># 可以使用docker inspect 镜像名 来查看镜像构建历史</span>
</pre></table></code></div></div><h5 id="3cmd与entrypoint">3.<code class="language-plaintext highlighter-rouge">CMD</code>与<code class="language-plaintext highlighter-rouge">ENTRYPOINT</code><a href="#3cmd与entrypoint" class="anchor"><i class="fas fa-hashtag"></i></a></h5></h5><pre><code class="language-SH"># ENTRYPOINT 两种写法
ENTRYPOINT ["executable", "param1", "param2"] # 这是 exec 模式的写法，注意需要使用双引号
ENTRYPOINT command param1 param2   #  这是 shell 模式的写法

1. 配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖。
2. 每个 Dockerfile 中只能有一个 ENTRYPOINT，当指定多个时，只有最后一个起效。
</code></pre><div class="language-sh highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c"># CMD 三种写法</span>
CMD <span class="o">[</span><span class="s2">"executable"</span>,<span class="s2">"param1"</span>,<span class="s2">"param2"</span><span class="o">]</span> <span class="c"># 使用 exec 执行，推荐方式；</span>
CMD <span class="nb">command </span>param1 param2    <span class="c"># 在 /bin/sh 中执行，提供给需要交互的应用；</span>
CMD <span class="o">[</span><span class="s2">"param1"</span>,<span class="s2">"param2"</span><span class="o">]</span>      <span class="c"># 提供给 ENTRYPOINT 的默认参数；</span>

1. 每个 Dockerfile 只能有一条 CMD 命令。如果指定了多条命令，只有最后一条会被执行。
2. 如果用户启动容器时候指定了运行的命令，则会覆盖掉 CMD 指定的命令。
</pre></table></code></div></div><p>举例说明，参考链接： https://www.cnblogs.com/lienhua34/p/5170335.html</p><p>从上面的说明，我们可以看到有两个共同点：</p><ol><li><strong>都可以指定shell或exec函数调用的方式执行命令；</strong><li><strong>当存在多个CMD指令或ENTRYPOINT指令时，只有最后一个生效；</strong></ol><p>而它们有如下差异：</p><div class="table-wrapper"><table><thead><tr><th>CMD<th>ENTRYPOINT<tbody><tr><td>容器启动时命令<strong>可以被docker run指定的命令覆盖</strong><td>docker run指定的参数当做ENTRYPOINT指定命令的参数<tr><td>可以为ENTRYPOINT指令设置默认参数<td>参数可以由CMD提供</table></div><h6 id="31-差异1">3.1 差异1</h6><div class="language-sh highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>
/diff1_folder
|--- startup.sh
|--- Dockerfile
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">startup.sh</code></p><div class="language-sh highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c">#!/bin/bash</span>
<span class="nb">echo</span> <span class="s2">"in startup, args: </span><span class="nv">$@</span><span class="s2">"</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">Dockerfile</code></p><div class="language-dockerfile highlighter-rouge"><div class="code-header"> <span label-text="Dockerfile"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">FROM</span><span class="s"> ubuntu:14.04</span>
<span class="k">MAINTAINER</span><span class="s"> lienhua34@xxx.com</span>

<span class="k">ADD</span><span class="s"> startup /opt</span>
<span class="k">RUN </span><span class="nb">chmod </span>a+x /opt/startup

<span class="k">CMD</span><span class="s"> ["/opt/startup"]</span>
</pre></table></code></div></div><div class="language-sh highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="c"># 使用docker build 创建镜像</span>
<span class="nb">sudo </span>docker build <span class="nt">-t</span> <span class="nb">test</span> <span class="nb">.</span>

...

Successfully built 18a2d5066346

<span class="c"># 用docker run启动两个test:latest镜像的容器</span>
<span class="c"># 第一个docker run命令没有指定容器启动时命令</span>
<span class="c"># 第二个docker run命令指定了容器启动时的命令为  /bin/bash -c 'echo Hello'</span>

lienhua34@test<span class="nv">$ </span><span class="nb">sudo </span>docker run <span class="nt">-ti</span> <span class="nt">--rm</span><span class="o">=</span><span class="nb">true test
</span><span class="k">in </span>startup, args: 
lienhua34@test<span class="nv">$ </span><span class="nb">sudo </span>docker run <span class="nt">-ti</span> <span class="nt">--rm</span><span class="o">=</span><span class="nb">true test</span> /bin/bash <span class="nt">-c</span> <span class="s1">'echo Hello'</span>
Hello

<span class="c">#可以看出， docker run命令启动容器时,指定的运行命令覆盖了Dockerfile文件中CMD指令指定的命令</span>
</pre></table></code></div></div><p>开始对比，同样的手法对于<code class="language-plaintext highlighter-rouge">ENTRYPOINT</code></p><div class="language-sh highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>/diff1_folder
|--- startup.sh
|--- Dockerfile
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">startup.sh</code>与上相同</p><p><code class="language-plaintext highlighter-rouge">Dockerfile</code></p><div class="language-dockerfile highlighter-rouge"><div class="code-header"> <span label-text="Dockerfile"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">FROM</span><span class="s"> ubuntu:14.04</span>
<span class="k">MAINTAINER</span><span class="s"> lienhua34@xxx.com</span>

<span class="k">ADD</span><span class="s"> startup /opt</span>
<span class="k">RUN </span><span class="nb">chmod </span>a+x /opt/startup

<span class="k">ENTRYPOINT</span><span class="s"> [“/opt/startup”]</span>
</pre></table></code></div></div><div class="language-sh highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="c"># 使用docker build 创建镜像</span>
<span class="nb">sudo </span>docker build <span class="nt">-t</span> <span class="nb">test</span> <span class="nb">.</span>

...

Successfully built 78f8aca2edc2

<span class="c"># 用docker run启动两个test:latest镜像的容器</span>
<span class="c"># 第一个docker run命令没有指定容器启动时命令</span>
<span class="c"># 第二个docker run命令指定了容器启动时的命令为 /bin/bash -c 'echo Hello' </span>
lienhua34@test<span class="nv">$ </span><span class="nb">sudo </span>docker run <span class="nt">-ti</span> <span class="nt">--rm</span><span class="o">=</span><span class="nb">true test
</span><span class="k">in </span>startup, args: 
lienhua34@test<span class="nv">$ </span><span class="nb">sudo </span>docker run <span class="nt">-ti</span> <span class="nt">--rm</span><span class="o">=</span><span class="nb">true test</span> /bin/bash <span class="nt">-c</span> <span class="s1">'echo Hello'</span>
<span class="k">in </span>startup, args: /bin/bash <span class="nt">-c</span> <span class="nb">echo </span>Hello

<span class="c"># 可以看出，docker run命令指定的容器运行命令不能覆盖Dockerfile文件中ENTRYPOINT指令指定的命令，反而被当做参数传递给ENTRYPOINT指令指定的命令</span>
</pre></table></code></div></div><h6 id="32-差异2">3.2 差异2</h6><div class="language-sh highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>/diff2_folder
|--- startup.sh
|--- Dockerfile
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">startup.sh</code></p><div class="language-sh highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c">#!/bin/bash</span>
<span class="nb">echo</span> <span class="s2">"in startup, args: </span><span class="nv">$@</span><span class="s2">"</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">Dockerfile</code></p><div class="language-dockerfile highlighter-rouge"><div class="code-header"> <span label-text="Dockerfile"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">FROM</span><span class="s"> ubuntu:14.04</span>
<span class="k">MAINTAINER</span><span class="s"> lienhua34@xxx.com</span>
 
<span class="k">ADD</span><span class="s"> startup /opt</span>
<span class="k">RUN </span><span class="nb">chmod </span>a+x /opt/startup

<span class="k">ENTRYPOINT</span><span class="s"> ["/opt/startup", "arg1"]</span>
<span class="k">CMD</span><span class="s"> ["arg2"]</span>
</pre></table></code></div></div><div class="language-sh highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>lienhua34@test<span class="nv">$ </span><span class="nb">sudo </span>docker build <span class="nt">-t</span> <span class="nb">test</span> <span class="nb">.</span>
...
Successfully built 4684ba457cc2

<span class="c"># docker run启动两个test:latest镜像的容器</span>
<span class="c"># 第一条docker run命令没有指定参数</span>
<span class="c"># 第二条docker run命令指定了参数arg3，其运行结果如下</span>
lienhua34@test<span class="nv">$ </span><span class="nb">sudo </span>docker run <span class="nt">-ti</span> <span class="nt">--rm</span><span class="o">=</span><span class="nb">true test
</span><span class="k">in </span>startup, args: arg1 arg2
lienhua34@test<span class="nv">$ </span><span class="nb">sudo </span>docker run <span class="nt">-ti</span> <span class="nt">--rm</span><span class="o">=</span><span class="nb">true test </span>arg3
<span class="k">in </span>startup, args: arg1 arg3

<span class="c"># 可以看出,CMD指令为ENTRYPOINT指令设置了默认参数；从第二个容器的运行结果看出，docker run命令指定的参数覆盖了CMD指令指定的参数(arg3覆盖了arg2)</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">Dockerfile</code>中出现<code class="language-plaintext highlighter-rouge">ENTRYPOINT</code>，则该<code class="language-plaintext highlighter-rouge">ENTRYPOINT</code>就是该容器启动命令；如果没有<code class="language-plaintext highlighter-rouge">ENTRYPOINT</code>，则<code class="language-plaintext highlighter-rouge">CMD</code>后面内容为容器启动命令；<li>一个<code class="language-plaintext highlighter-rouge">Dockerfile</code>中必须有一个<code class="language-plaintext highlighter-rouge">CMD</code>或者<code class="language-plaintext highlighter-rouge">ENTRYPOINT</code><li>如果两者同时出现，<code class="language-plaintext highlighter-rouge">CMD</code>后面的内容为<code class="language-plaintext highlighter-rouge">ENTRYPOINT</code>的参数，且该内容可以被<code class="language-plaintext highlighter-rouge">docker run</code>后面的内容覆盖<li>如果出现多个<code class="language-plaintext highlighter-rouge">CMD</code>或者<code class="language-plaintext highlighter-rouge">ENTRYPOINT</code>,则前面的<code class="language-plaintext highlighter-rouge">CMD</code>被最后一个<code class="language-plaintext highlighter-rouge">CMD</code>覆盖；前面的<code class="language-plaintext highlighter-rouge">ENTRYPOINT</code>被最后一个<code class="language-plaintext highlighter-rouge">ENTRYPOINT</code>覆盖</ul><h4 id="2删除镜像">2.删除镜像<a href="#2删除镜像" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>镜像在被运行后，就形成了容器；一般如果镜像已经被使用来创建容器，使用<code class="language-plaintext highlighter-rouge">docker rmi</code>命令来删除镜像会报下面的错误，告诉我们该镜像已经被使用，不允许删除。</p><div class="language-sh highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>Error response from daemon: conflict: unable to remove repository reference <span class="s2">"mysql:5.7"</span> <span class="o">(</span>must force<span class="o">)</span> - container ccd406c07a78 is using its referenced image e1e1680ac726
</pre></table></code></div></div><p>对于已经被用于创建容器的镜像，删除方法有两种</p><div class="language-sh highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c"># 一种是先把容器删除，再删除镜像【推荐】</span>

<span class="c"># 另一种则只需要在删除镜像的命令中跟一个-f参数便可，如：</span>
<span class="c"># docker rmi 镜像名</span>
docker rmi 镜像id
docker rmi <span class="nt">-f</span> 镜像id 					<span class="c"># 强制删除镜像</span>
docker rmi <span class="nt">-f</span> <span class="si">$(</span>docker ps <span class="nt">-aq</span><span class="si">)</span>         <span class="c"># 删除所有镜像</span>
</pre></table></code></div></div><h4 id="3拉取镜像">3.拉取镜像<a href="#3拉取镜像" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>官方的https://hub.docker.com/提供了数十万个镜像提供大家下载，以拉取个人公有centos7.3镜像为例：</p><div class="language-sh highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c"># docker pull 用户/仓库：标签</span>
docker pull kennyyaohong/public:centos7.3
</pre></table></code></div></div><h4 id="4镜像推送">4.镜像推送<a href="#4镜像推送" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p><img data-src="../../assets/images/20220215docker/image-20220222145732015.png" alt="image-20220222145732015" style="zoom:67%;" data-proofer-ignore></p><div class="language-sh highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c"># 第一步 打标签 docker  tag  镜像id       要推入仓库的用户名/要推入的仓库名:新定义的tag </span>
docker tag e12a9ec48ab7 kennyyaohong/public:myproject_centos7.3
<span class="c"># 第二步 推送 docker push      要推入仓库的用户名/要推入的仓库名:镜像标签</span>
docker push kennyyaohong/public:myproject_centos7.3
</pre></table></code></div></div><h3 id="3-容器命令">3. 容器命令<a href="#3-容器命令" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>容器(Container)与镜像的关系，就如同面向编程中对象与类之间的关系。</p><p>因为容器是通过镜像来创建的，所以必须先有镜像才能创建容器，而生成的容器是一个独立于宿主机的隔离进程，并且有属于容器自己的网络和命名空间。</p><p>镜像由多个中间层(layer)组成，生成的<strong>镜像是只读的</strong>，但<strong>容器却是可读可写的</strong>，这是因为容器是在镜像上面添一层读写层(writer/read layer)来实现的。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre>Usage:  docker container COMMAND

Manage containers

Commands:
  attach      Attach local standard input, output, and error streams to a running container                                                                                          
  commit      Create a new image from a container's changes(把容器保存为镜像)
  cp          Copy files/folders between a container and the local filesystem
  create      Create a new container(创建一个新的容器)
  diff        Inspect changes to files or directories on a container's filesyste                                                                                             m
  exec        Run a command in a running container(在一个运行的容器中执行命令)
  export      Export a container's filesystem as a tar archive
  inspect     Display detailed information on one or more containers
  kill        Kill one or more running containers(杀死一个或多个正在运行的容器)
  logs        Fetch the logs of a container
  ls          List containers(显示本地容器列表)
  pause       Pause all processes within one or more containers
  port        List port mappings or a specific mapping for the container
  prune       Remove all stopped containers
  rename      Rename a container(重命名容器)
  restart     Restart one or more containers(重启一个或多个容器)
  rm          Remove one or more containers(删除一个或多个容器)
  run         Run a command in a new container(运行一个新的容器)
  start       Start one or more stopped containers
  stats       Display a live stream of container(s) resource usage statistics
  stop        Stop one or more running containers(停止一个或多个容器)
  top         Display the running processes of a container
  unpause     Unpause all processes within one or more containers
  update      Update configuration of one or more containers
  wait        Block until one or more containers stop, then print their exit codes
</pre></table></code></div></div><h4 id="1启动停止容器">1.启动/停止容器<a href="#1启动停止容器" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><div class="language-sh highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="c"># 通过镜像创建容器，指定容器name </span>
<span class="c"># -i interactive -t persu tty</span>
docker run <span class="nt">-it</span> <span class="nt">--name</span> myu1 ubuntu 
<span class="c"># 启动/停止容器</span>
docker start 容器id
docker restart 容器id
docker stop 容器id
docker <span class="nb">kill </span>容器id  <span class="c"># 强制停止当前容器</span>
</pre></table></code></div></div><h4 id="2进入容器">2.进入容器<a href="#2进入容器" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><div class="language-sh highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="c"># 进入容器</span>
docker <span class="nb">exec</span> <span class="nt">-it</span> 容器id /bin/bash

<span class="c"># 示例</span>
zhengkan03@ubuntu:~/桌面<span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span>  ffbdccd23b40 /bin/bash
root@ffbdccd23b40:/app# <span class="nb">ls
</span>data  Dockerfile  LSTM.py  __pycache__  README.md  requirements.txt  static  templates  WindPlatform.py

<span class="c"># 进入容器</span>
docker attach

<span class="c"># 区别</span>
docker <span class="nb">exec</span>       <span class="c"># 进入容器后开启一个新的终端</span>
docker attach	  <span class="c"># 进入容器正在执行的终端，不会启动新的进程</span>
</pre></table></code></div></div><h4 id="3退出容器">3.退出容器<a href="#3退出容器" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><div class="language-sh highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nb">exit</span>  <span class="c"># 直接容器停止并退出</span>
CTRL + P + Q <span class="c"># 容器不停止，退出</span>
</pre></table></code></div></div><h4 id="4删除容器">4.删除容器<a href="#4删除容器" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><div class="language-sh highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>docker <span class="nb">rm </span>容器id					<span class="c"># 删除指定容器 ，不能删除正在运行的容器</span>
docker <span class="nb">rm</span> <span class="nt">-f</span> <span class="si">$(</span>docker ps <span class="nt">-aq</span><span class="si">)</span>	   <span class="c"># 删除所有容器(强制)</span>
</pre></table></code></div></div><h4 id="5查看容器">5.查看容器<a href="#5查看容器" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><div class="language-sh highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="c"># 查看日志</span>
docker logs 
docker logs <span class="nt">-tf</span> <span class="nt">-tail</span> n 容器id   <span class="c"># 查看最后n条日志  -t 显示时间戳   -f 跟随时间戳</span>

<span class="c"># 示例</span>
zhengkan03@ubuntu:~/桌面<span class="nv">$ </span>docker logs <span class="nt">-tf</span> <span class="nt">--tail</span> 10 26b6aea91aaa
2021-06-22T07:48:50.905093443Z 
2021-06-22T07:48:50.905095407Z To try something more ambitious, you can run an Ubuntu container with:
2021-06-22T07:48:50.905097543Z  <span class="nv">$ </span>docker run <span class="nt">-it</span> ubuntu bash
2021-06-22T07:48:50.905099590Z 
2021-06-22T07:48:50.905101646Z Share images, automate workflows, and more with a free Docker ID:
2021-06-22T07:48:50.905103754Z  https://hub.docker.com/
2021-06-22T07:48:50.905105835Z 
2021-06-22T07:48:50.905107823Z For more examples and ideas, visit:
2021-06-22T07:48:50.905109929Z  https://docs.docker.com/get-started/
2021-06-22T07:48:50.905112002Z    
</pre></table></code></div></div><div class="language-sh highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="c"># 查看进程信息</span>
docker top 容器id

<span class="c"># 示例</span>
hengkan03@ubuntu:~/桌面<span class="nv">$ </span>docker top ffbdccd23b40
UID                 PID                 PPID                C                   STIME               TTY             
root                4003                3981                1                   16:02               ?               
root                4048                4003                2                   16:02               ?    
</pre></table></code></div></div><div class="language-sh highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
</pre><td class="rouge-code"><pre><span class="c"># 查看容器元数据</span>
docker inspect 容器id
<span class="c"># 示例</span>
zhengkan03@ubuntu:~/桌面<span class="nv">$ </span>docker inspect ffbdccd23b40
<span class="o">[</span>
    <span class="o">{</span>
        <span class="s2">"Id"</span>: <span class="s2">"ffbdccd23b400f0e42060189c76b8497b6b97911c1bd98937d57417ea7751496"</span>,
        <span class="s2">"Created"</span>: <span class="s2">"2021-06-22T08:02:15.072353163Z"</span>,
        <span class="s2">"Path"</span>: <span class="s2">"python3"</span>,
        <span class="s2">"Args"</span>: <span class="o">[</span>
            <span class="s2">"WindPlatform.py"</span>
        <span class="o">]</span>,
        <span class="s2">"State"</span>: <span class="o">{</span>
            <span class="s2">"Status"</span>: <span class="s2">"running"</span>,
            <span class="s2">"Running"</span>: <span class="nb">true</span>,
            <span class="s2">"Paused"</span>: <span class="nb">false</span>,
            <span class="s2">"Restarting"</span>: <span class="nb">false</span>,
            <span class="s2">"OOMKilled"</span>: <span class="nb">false</span>,
            <span class="s2">"Dead"</span>: <span class="nb">false</span>,
            <span class="s2">"Pid"</span>: 4003,
            <span class="s2">"ExitCode"</span>: 0,
            <span class="s2">"Error"</span>: <span class="s2">""</span>,
            <span class="s2">"StartedAt"</span>: <span class="s2">"2021-06-22T08:02:15.329542854Z"</span>,
            <span class="s2">"FinishedAt"</span>: <span class="s2">"0001-01-01T00:00:00Z"</span>
        <span class="o">}</span>,
        <span class="s2">"Image"</span>: <span class="s2">"sha256:fa7b17d27d4a5dffbfef573effc6c11f8e08050df1d5479d58196a9d3e57e3e4"</span>,
        <span class="s2">"ResolvConfPath"</span>: <span class="s2">"/var/lib/docker/containers/ffbdccd23b400f0e42060189c76b8497b6b97911c1bd98937d57417ea7751496/resolv.conf"</span>,
        <span class="s2">"HostnamePath"</span>: <span class="s2">"/var/lib/docker/containers/ffbdccd23b400f0e42060189c76b8497b6b97911c1bd98937d57417ea7751496/hostname"</span>,
        <span class="s2">"HostsPath"</span>: <span class="s2">"/var/lib/docker/containers/ffbdccd23b400f0e42060189c76b8497b6b97911c1bd98937d57417ea7751496/hosts"</span>,
        <span class="s2">"LogPath"</span>: <span class="s2">"/var/lib/docker/containers/ffbdccd23b400f0e42060189c76b8497b6b97911c1bd98937d57417ea7751496/ffbdccd23b400f0e42060189c76b8497b6b97911c1bd98937d57417ea7751496-json.log"</span>,
        <span class="s2">"Name"</span>: <span class="s2">"/nifty_euclid"</span>,
        <span class="s2">"RestartCount"</span>: 0,
        <span class="s2">"Driver"</span>: <span class="s2">"overlay2"</span>,
        <span class="s2">"Platform"</span>: <span class="s2">"linux"</span>,
        <span class="s2">"MountLabel"</span>: <span class="s2">""</span>,
        <span class="s2">"ProcessLabel"</span>: <span class="s2">""</span>,
        <span class="s2">"AppArmorProfile"</span>: <span class="s2">"docker-default"</span>,
        <span class="s2">"ExecIDs"</span>: null,
        <span class="s2">"HostConfig"</span>: <span class="o">{</span>
            <span class="s2">"Binds"</span>: null,
            <span class="s2">"ContainerIDFile"</span>: <span class="s2">""</span>,
            <span class="s2">"LogConfig"</span>: <span class="o">{</span>
                <span class="s2">"Type"</span>: <span class="s2">"json-file"</span>,
                <span class="s2">"Config"</span>: <span class="o">{}</span>
            <span class="o">}</span>,
            <span class="s2">"NetworkMode"</span>: <span class="s2">"default"</span>,
            <span class="s2">"PortBindings"</span>: <span class="o">{}</span>,
            <span class="s2">"RestartPolicy"</span>: <span class="o">{</span>
                <span class="s2">"Name"</span>: <span class="s2">"no"</span>,
                <span class="s2">"MaximumRetryCount"</span>: 0
            <span class="o">}</span>,
            <span class="s2">"AutoRemove"</span>: <span class="nb">false</span>,
            <span class="s2">"VolumeDriver"</span>: <span class="s2">""</span>,
            <span class="s2">"VolumesFrom"</span>: null,
            <span class="s2">"CapAdd"</span>: null,
            <span class="s2">"CapDrop"</span>: null,
            <span class="s2">"CgroupnsMode"</span>: <span class="s2">"host"</span>,
            <span class="s2">"Dns"</span>: <span class="o">[]</span>,
            <span class="s2">"DnsOptions"</span>: <span class="o">[]</span>,
            <span class="s2">"DnsSearch"</span>: <span class="o">[]</span>,
            <span class="s2">"ExtraHosts"</span>: null,
            <span class="s2">"GroupAdd"</span>: null,
            <span class="s2">"IpcMode"</span>: <span class="s2">"private"</span>,
            <span class="s2">"Cgroup"</span>: <span class="s2">""</span>,
            <span class="s2">"Links"</span>: null,
            <span class="s2">"OomScoreAdj"</span>: 0,
            <span class="s2">"PidMode"</span>: <span class="s2">""</span>,
            <span class="s2">"Privileged"</span>: <span class="nb">false</span>,
            <span class="s2">"PublishAllPorts"</span>: <span class="nb">false</span>,
            <span class="s2">"ReadonlyRootfs"</span>: <span class="nb">false</span>,
            <span class="s2">"SecurityOpt"</span>: null,
            <span class="s2">"UTSMode"</span>: <span class="s2">""</span>,
            <span class="s2">"UsernsMode"</span>: <span class="s2">""</span>,
            <span class="s2">"ShmSize"</span>: 67108864,
            <span class="s2">"Runtime"</span>: <span class="s2">"runc"</span>,
            <span class="s2">"ConsoleSize"</span>: <span class="o">[</span>
                0,
                0
            <span class="o">]</span>,
            <span class="s2">"Isolation"</span>: <span class="s2">""</span>,
            <span class="s2">"CpuShares"</span>: 0,
            <span class="s2">"Memory"</span>: 0,
            <span class="s2">"NanoCpus"</span>: 0,
            <span class="s2">"CgroupParent"</span>: <span class="s2">""</span>,
            <span class="s2">"BlkioWeight"</span>: 0,
            <span class="s2">"BlkioWeightDevice"</span>: <span class="o">[]</span>,
            <span class="s2">"BlkioDeviceReadBps"</span>: null,
            <span class="s2">"BlkioDeviceWriteBps"</span>: null,
            <span class="s2">"BlkioDeviceReadIOps"</span>: null,
            <span class="s2">"BlkioDeviceWriteIOps"</span>: null,
            <span class="s2">"CpuPeriod"</span>: 0,
            <span class="s2">"CpuQuota"</span>: 0,
            <span class="s2">"CpuRealtimePeriod"</span>: 0,
            <span class="s2">"CpuRealtimeRuntime"</span>: 0,
            <span class="s2">"CpusetCpus"</span>: <span class="s2">""</span>,
            <span class="s2">"CpusetMems"</span>: <span class="s2">""</span>,
            <span class="s2">"Devices"</span>: <span class="o">[]</span>,
            <span class="s2">"DeviceCgroupRules"</span>: null,
            <span class="s2">"DeviceRequests"</span>: null,
            <span class="s2">"KernelMemory"</span>: 0,
            <span class="s2">"KernelMemoryTCP"</span>: 0,
            <span class="s2">"MemoryReservation"</span>: 0,
            <span class="s2">"MemorySwap"</span>: 0,
            <span class="s2">"MemorySwappiness"</span>: null,
            <span class="s2">"OomKillDisable"</span>: <span class="nb">false</span>,
            <span class="s2">"PidsLimit"</span>: null,
            <span class="s2">"Ulimits"</span>: null,
            <span class="s2">"CpuCount"</span>: 0,
            <span class="s2">"CpuPercent"</span>: 0,
            <span class="s2">"IOMaximumIOps"</span>: 0,
            <span class="s2">"IOMaximumBandwidth"</span>: 0,
            <span class="s2">"MaskedPaths"</span>: <span class="o">[</span>
                <span class="s2">"/proc/asound"</span>,
                <span class="s2">"/proc/acpi"</span>,
                <span class="s2">"/proc/kcore"</span>,
                <span class="s2">"/proc/keys"</span>,
                <span class="s2">"/proc/latency_stats"</span>,
                <span class="s2">"/proc/timer_list"</span>,
                <span class="s2">"/proc/timer_stats"</span>,
                <span class="s2">"/proc/sched_debug"</span>,
                <span class="s2">"/proc/scsi"</span>,
                <span class="s2">"/sys/firmware"</span>
            <span class="o">]</span>,
            <span class="s2">"ReadonlyPaths"</span>: <span class="o">[</span>
                <span class="s2">"/proc/bus"</span>,
                <span class="s2">"/proc/fs"</span>,
                <span class="s2">"/proc/irq"</span>,
                <span class="s2">"/proc/sys"</span>,
                <span class="s2">"/proc/sysrq-trigger"</span>
            <span class="o">]</span>
        <span class="o">}</span>,
        <span class="s2">"GraphDriver"</span>: <span class="o">{</span>
            <span class="s2">"Data"</span>: <span class="o">{</span>
                <span class="s2">"LowerDir"</span>: <span class="s2">"/var/lib/docker/overlay2/683812c5b66d7ff4a6efc7479adf1d1dd69ef966d721104cb240fc810d023f7d-init/diff:/var/lib/docker/overlay2/17a7729fae872dc47beaddd86c02f5a95d1c8b17525e49e9457ff52e126dfc17/diff:/var/lib/docker/overlay2/fa10d11839ed464f0bd78ba5d9cb8fef8212e391876569631c0c04a59aa6e3e3/diff:/var/lib/docker/overlay2/b3c96094f9204af39890d1b8101278a98d7cc6c9c96e76c8fa2efb19d6181a0b/diff:/var/lib/docker/overlay2/c8fe8f5fd4e56531f6452da6ad5e8d300f2b48042a0c72a18fe4e11b3a369aec/diff:/var/lib/docker/overlay2/d28d47c24554c918e4814ef21087b7b334d6b02055c22a690714d9fe905d2407/diff:/var/lib/docker/overlay2/7343c35e91fb791e62ec43253c0ae1705b54dbe72ab65b1361e3a33f7bea1610/diff:/var/lib/docker/overlay2/1ff46c566494d2451a35636d7b28461d0ea2f2c2dd2af2920de52ee25ba53529/diff:/var/lib/docker/overlay2/e736e69f6bb2b87efb5ff8d693c4fd37d887502a06a5b9fabff96ad8153c7f9c/diff:/var/lib/docker/overlay2/18a19eee18a38481e0db17be63f675b6edddba3c72f6ec3ea99b2446b44198c8/diff:/var/lib/docker/overlay2/1cab6ed396a099774fbf46013adbb04aae80e173af01b08bbaebd4330ee5417e/diff:/var/lib/docker/overlay2/0a990a330b637a03878dece926106670d67a6848220433163e8b614e26a4d5fe/diff:/var/lib/docker/overlay2/dcb2bdf25e93fc854e9f20db7af8a15d8121591d0fdc4adf6fd3897c6ad42794/diff:/var/lib/docker/overlay2/32ff4d2f742d16b700a2e71d3e6c4508a976046869a472e52fb7057e2bab2f6c/diff:/var/lib/docker/overlay2/09f6a5b7a03f34cd7ddd7fab9ba8fe9aa3ddf9e232fabf3c54fc8602d80a2f1f/diff"</span>,
                <span class="s2">"MergedDir"</span>: <span class="s2">"/var/lib/docker/overlay2/683812c5b66d7ff4a6efc7479adf1d1dd69ef966d721104cb240fc810d023f7d/merged"</span>,
                <span class="s2">"UpperDir"</span>: <span class="s2">"/var/lib/docker/overlay2/683812c5b66d7ff4a6efc7479adf1d1dd69ef966d721104cb240fc810d023f7d/diff"</span>,
                <span class="s2">"WorkDir"</span>: <span class="s2">"/var/lib/docker/overlay2/683812c5b66d7ff4a6efc7479adf1d1dd69ef966d721104cb240fc810d023f7d/work"</span>
            <span class="o">}</span>,
            <span class="s2">"Name"</span>: <span class="s2">"overlay2"</span>
        <span class="o">}</span>,
        <span class="s2">"Mounts"</span>: <span class="o">[</span>
            <span class="o">{</span>
                <span class="s2">"Type"</span>: <span class="s2">"volume"</span>,
                <span class="s2">"Name"</span>: <span class="s2">"506ba62d402f692daf45dad5a846cff4e553a710f541e78949466e0e92325ea9"</span>,
                <span class="s2">"Source"</span>: <span class="s2">"/var/lib/docker/volumes/506ba62d402f692daf45dad5a846cff4e553a710f541e78949466e0e92325ea9/_data"</span>,
                <span class="s2">"Destination"</span>: <span class="s2">"/sys/fs/cgroup"</span>,
                <span class="s2">"Driver"</span>: <span class="s2">"local"</span>,
                <span class="s2">"Mode"</span>: <span class="s2">""</span>,
                <span class="s2">"RW"</span>: <span class="nb">true</span>,
                <span class="s2">"Propagation"</span>: <span class="s2">""</span>
            <span class="o">}</span>
        <span class="o">]</span>,
        <span class="s2">"Config"</span>: <span class="o">{</span>
            <span class="s2">"Hostname"</span>: <span class="s2">"ffbdccd23b40"</span>,
            <span class="s2">"Domainname"</span>: <span class="s2">""</span>,
            <span class="s2">"User"</span>: <span class="s2">""</span>,
            <span class="s2">"AttachStdin"</span>: <span class="nb">false</span>,
            <span class="s2">"AttachStdout"</span>: <span class="nb">false</span>,
            <span class="s2">"AttachStderr"</span>: <span class="nb">false</span>,
            <span class="s2">"Tty"</span>: <span class="nb">false</span>,
            <span class="s2">"OpenStdin"</span>: <span class="nb">false</span>,
            <span class="s2">"StdinOnce"</span>: <span class="nb">false</span>,
            <span class="s2">"Env"</span>: <span class="o">[</span>
                <span class="s2">"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span>,
                <span class="s2">"container=docker"</span>,
                <span class="s2">"DEBIAN_FRONTEND=noninteractive"</span>,
                <span class="s2">"LANG=en_US.UTF-8"</span>,
                <span class="s2">"LANGUAGE=en_US:en"</span>,
                <span class="s2">"LC_ALL=en_US.UTF-8"</span>
            <span class="o">]</span>,
            <span class="s2">"Cmd"</span>: <span class="o">[</span>
                <span class="s2">"python3"</span>,
                <span class="s2">"WindPlatform.py"</span>
            <span class="o">]</span>,
            <span class="s2">"Image"</span>: <span class="s2">"fa7b17d27d4a"</span>,
            <span class="s2">"Volumes"</span>: <span class="o">{</span>
                <span class="s2">"/sys/fs/cgroup"</span>: <span class="o">{}</span>
            <span class="o">}</span>,
            <span class="s2">"WorkingDir"</span>: <span class="s2">"/app"</span>,
            <span class="s2">"Entrypoint"</span>: null,
            <span class="s2">"OnBuild"</span>: null,
            <span class="s2">"Labels"</span>: <span class="o">{}</span>
        <span class="o">}</span>,
        <span class="s2">"NetworkSettings"</span>: <span class="o">{</span>
            <span class="s2">"Bridge"</span>: <span class="s2">""</span>,
            <span class="s2">"SandboxID"</span>: <span class="s2">"5f09b2026536f58852715967f0f1487828195533aa71896838e9074634e2a403"</span>,
            <span class="s2">"HairpinMode"</span>: <span class="nb">false</span>,
            <span class="s2">"LinkLocalIPv6Address"</span>: <span class="s2">""</span>,
            <span class="s2">"LinkLocalIPv6PrefixLen"</span>: 0,
            <span class="s2">"Ports"</span>: <span class="o">{}</span>,
            <span class="s2">"SandboxKey"</span>: <span class="s2">"/var/run/docker/netns/5f09b2026536"</span>,
            <span class="s2">"SecondaryIPAddresses"</span>: null,
            <span class="s2">"SecondaryIPv6Addresses"</span>: null,
            <span class="s2">"EndpointID"</span>: <span class="s2">"d88f24d5ea6a94c7a9ee0359d7bd829cf66e4dc70ebe7d827b709a8c0a836dd2"</span>,
            <span class="s2">"Gateway"</span>: <span class="s2">"172.17.0.1"</span>,
            <span class="s2">"GlobalIPv6Address"</span>: <span class="s2">""</span>,
            <span class="s2">"GlobalIPv6PrefixLen"</span>: 0,
            <span class="s2">"IPAddress"</span>: <span class="s2">"172.17.0.2"</span>,
            <span class="s2">"IPPrefixLen"</span>: 16,
            <span class="s2">"IPv6Gateway"</span>: <span class="s2">""</span>,
            <span class="s2">"MacAddress"</span>: <span class="s2">"02:42:ac:11:00:02"</span>,
            <span class="s2">"Networks"</span>: <span class="o">{</span>
                <span class="s2">"bridge"</span>: <span class="o">{</span>
                    <span class="s2">"IPAMConfig"</span>: null,
                    <span class="s2">"Links"</span>: null,
                    <span class="s2">"Aliases"</span>: null,
                    <span class="s2">"NetworkID"</span>: <span class="s2">"8f3b1769f0151de1a0edac3bf15a02e0828f2ea16919098ec4cdfd43f0f90ad4"</span>,
                    <span class="s2">"EndpointID"</span>: <span class="s2">"d88f24d5ea6a94c7a9ee0359d7bd829cf66e4dc70ebe7d827b709a8c0a836dd2"</span>,
                    <span class="s2">"Gateway"</span>: <span class="s2">"172.17.0.1"</span>,
                    <span class="s2">"IPAddress"</span>: <span class="s2">"172.17.0.2"</span>,
                    <span class="s2">"IPPrefixLen"</span>: 16,
                    <span class="s2">"IPv6Gateway"</span>: <span class="s2">""</span>,
                    <span class="s2">"GlobalIPv6Address"</span>: <span class="s2">""</span>,
                    <span class="s2">"GlobalIPv6PrefixLen"</span>: 0,
                    <span class="s2">"MacAddress"</span>: <span class="s2">"02:42:ac:11:00:02"</span>,
                    <span class="s2">"DriverOpts"</span>: null
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">]</span>
</pre></table></code></div></div><h4 id="6容器文件交互">6.容器文件交互<a href="#6容器文件交互" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><div class="language-sh highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c"># 容器内文件拷贝到主机 	</span>
docker <span class="nb">cp </span>容器id:路径 宿主机路径
<span class="c"># 示例</span>
zhengkan03@ubuntu:~/桌面<span class="nv">$ </span>docker <span class="nb">cp </span>ffbdccd23b40:/app/ /home/zhengkan03/Desktop/
</pre></table></code></div></div><h4 id="7容器数据卷">7.容器数据卷<a href="#7容器数据卷" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>docker的理念： 将应用和环境打包为一个镜像！</p><p>数据如果保存在容器中，那么容器被删除，数据就会丢失。所以，需要数据的持久化，并保存到本地。这样即便出现删库跑路的情况，数据库中的数据仍能保存到本地。</p><div class="language-sh highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="c"># 方式一：直接使用-v数据挂载 </span>
<span class="c"># 功能是实现双向绑定:容器内部添加文件，可同步到主机;主机指定文件夹下添加文件可同步到容器内;</span>
docker run <span class="nt">-it</span> <span class="nt">-v</span> 宿主机目录:容器内路径

<span class="c"># 匿名挂载</span>
docker run <span class="nt">-d</span> <span class="nt">-P</span> <span class="nt">--name</span> nginx01 <span class="nt">-v</span> /etc/nginx nginx
<span class="nt">-v</span> 容器内路径  <span class="c"># 匿名挂载，不建议使用</span>
<span class="c"># 具名挂载</span>
<span class="nt">-v</span> 卷名:容器内路径  
<span class="nt">-v</span> 宿主机路径:容器内路径  <span class="c"># 指定路径挂载</span>

<span class="c"># 通过 -v 容器内路径：ro rw 改变读写权限  ，设置后只能通过宿主机操作，不能容器内操作，默认可读可写</span>
ro  <span class="nb">readonly</span>    <span class="c"># 容器内部只读</span>
rw  readwrite   <span class="c"># 容器内部可读可写</span>
docker run <span class="nt">-d</span> <span class="nt">-P</span> <span class="nt">--name</span> nginx02 <span class="nt">-v</span> jumping-nginx:/etc/nginx:/etc/nginx:ro nginx
docker run <span class="nt">-d</span> <span class="nt">-P</span> <span class="nt">--name</span> nginx02 <span class="nt">-v</span> jumping-nginx:/etc/nginx:/etc/nginx:rw nginx

<span class="c"># 启动后可以通过docker inspect 容器id 查看挂载-&gt;Mount</span>

<span class="c"># 方式二： 通过dockerfile中的VOLUME挂载</span>
</pre></table></code></div></div><p><strong>创建本地数据卷</strong></p><p>本地数据卷默认路径是在 <code class="language-plaintext highlighter-rouge">/var/lib/docker/volumes/ </code>下</p><div class="language-sh highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="c"># 创建本地数据卷</span>
docker volume create my-vol
<span class="c"># 列出本地数据卷</span>
docker volume <span class="nb">ls
</span>DRIVER    VOLUME NAME
<span class="nb">local     </span>my-vol
<span class="c"># 查看本地数据卷</span>
docker volume inspect my-vol
<span class="o">[</span>
    <span class="o">{</span>
        <span class="s2">"CreatedAt"</span>: <span class="s2">"2022-02-17T09:18:01+08:00"</span>,
        <span class="s2">"Driver"</span>: <span class="s2">"local"</span>,
        <span class="s2">"Labels"</span>: <span class="o">{}</span>,
        <span class="s2">"Mountpoint"</span>: <span class="s2">"/var/lib/docker/volumes/my-vol/_data"</span>,
        <span class="s2">"Name"</span>: <span class="s2">"my-vol"</span>,
        <span class="s2">"Options"</span>: <span class="o">{}</span>,
        <span class="s2">"Scope"</span>: <span class="s2">"local"</span>
    <span class="o">}</span>
<span class="o">]</span>
<span class="c"># 删除本地数据卷</span>
docker volume <span class="nb">rm </span>my-vol
</pre></table></code></div></div><p><strong>Dokcerfile中的VOLUME</strong></p><div class="language-dockerfile highlighter-rouge"><div class="code-header"> <span label-text="Dockerfile"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">FROM</span><span class="s"> centos</span>
<span class="k">VOLUME</span><span class="s"> ["volume1","volume2"]  # 这个地方进行匿名挂载,多个数据卷必须使用双引号分割</span>
<span class="k">CMD</span><span class="s"> echo "--end--"</span>
<span class="k">CMD</span><span class="s"> /bin/bash</span>
</pre></table></code></div></div><div class="language-sh highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>zhengkan@station-ThinkStation-P340:~<span class="nv">$ </span>docker run <span class="nt">-it</span> 17e4 bash
root@70e127257ef8:/# <span class="nb">ls
</span>bin   dev  home  lib32  libx32  mnt  proc  run   srv  tmp  var      volume2
boot  etc  lib   lib64  media   opt  root  sbin  sys  usr  volume1        <span class="c"># 出现创建的两个数据卷volume1 和 volume2</span>
</pre></table></code></div></div><div class="language-sh highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>root@station-ThinkStation-P340:/var/lib/docker/volumes# <span class="nb">ls
</span>19abfa4ee65418e8a78ee144bb582eccf026ca14c0c52cf3b88bec777cd58e6f  backingFsBlockDev
1c4bf795cb696fe0de894c5164adf8a93ae96b9ae1aa9bcd59599a19be88ff84  metadata.db
<span class="c"># 进入/var/lib/docker/volumes,可见对应volume1和volume2的两个数据卷</span>
<span class="c"># 每个卷中有个_data 文件夹与volume1、volume2中的内容对应</span>
</pre></table></code></div></div><p>此时在容器内部会创建<code class="language-plaintext highlighter-rouge">volume1</code>和<code class="language-plaintext highlighter-rouge">volume2</code>两个卷（文件夹），同时在宿主机的<code class="language-plaintext highlighter-rouge">/var/lib/docker/volumes/</code>下会有随机生成的数据卷（文件夹）与<code class="language-plaintext highlighter-rouge">volume1</code>和<code class="language-plaintext highlighter-rouge">volume2</code>对应绑定；</p><p><strong>当修改任意一个数据卷中的内容时，其对应数据卷中的内容也会发生更改</strong></p><p>在创建项目时，通常需要用到具名挂载，方便宿主机的数据查找和应用，这个就需要用到<code class="language-plaintext highlighter-rouge">docker-compose</code>中的数据挂载了，详见<code class="language-plaintext highlighter-rouge">docker-compose</code>部分</p><h3 id="4docker网络">4.Docker网络<a href="#4docker网络" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><h4 id="1docker0网卡">1.docker0网卡<a href="#1docker0网卡" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>Docker使用Linux桥接，在宿主机虚拟一个Docker网桥(docker0)，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP。</p><p>同时Docker网桥是每个容器的默认网关，因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。</p><div class="language-sh highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre>root@station-ThinkStation-P340:~# ip addr
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    <span class="nb">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eno1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000
    <span class="nb">link</span>/ether d8:bb:c1:7b:4f:3e brd ff:ff:ff:ff:ff:ff
    altname enp0s31f6
    inet 192.168.31.65/24 brd 192.168.31.255 scope global dynamic noprefixroute eno1
       valid_lft 33609sec preferred_lft 33609sec
    inet6 fe80::bc7:f2c9:9736:8be5/64 scope <span class="nb">link </span>noprefixroute 
       valid_lft forever preferred_lft forever
3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default 
    <span class="nb">link</span>/ether 02:42:b2:72:14:f2 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:b2ff:fe72:14f2/64 scope <span class="nb">link 
       </span>valid_lft forever preferred_lft forever
</pre></table></code></div></div><p>在每台装有docker的机器上，会有一张<code class="language-plaintext highlighter-rouge">docker0</code>的网卡，并且自动创建三个网络；docker内置的这三个网络可以在运行容器时，指定容器连接到那个网络；</p><div class="language-sh highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>root@station-ThinkStation-P340:~# docker network <span class="nb">ls
</span>NETWORK ID     NAME      DRIVER    SCOPE
88d2242caf7b   bridge    bridge    <span class="nb">local
</span>db2e9c36669e   host      host      <span class="nb">local
</span>7016f0320535   none      null      <span class="nb">local</span>

<span class="c"># 指定连接网络</span>
docker run <span class="nt">--network</span><span class="o">=</span>选项指定
root@station-ThinkStation-P340:~# docker run <span class="nt">-it</span> <span class="nt">--network</span><span class="o">=</span>host ubuntu
</pre></table></code></div></div><h4 id="2容器通讯">2.容器通讯<a href="#2容器通讯" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>Docker网桥是宿主机虚拟出来的，并不是真实存在的网络设备，外部网络是无法寻址到的，这也意味着外部网络无法通过直接Container-IP访问到容器。</p><p>如果容器希望外部访问能够访问到，可以通过映射容器端口到宿主主机（<strong>端口映射</strong>），即docker run创建容器时候通过 -p 或 -P 参数来启用，访问容器的时候就通过<strong>[宿主机IP]:[容器端口]</strong>访问容器。</p><h4 id="3网络模式">3.网络模式<a href="#3网络模式" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><div class="table-wrapper"><table><thead><tr><th>Docker 网络模式<th>配置<th>说明<tbody><tr><td>Host<td>– net = host<td>容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口<tr><td>Container<td>– net = container<td>创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围。<tr><td>None<td>– net = none<td>该模式关闭了容器的网络功能<tr><td>Bridge<td>– net= bridge<td>此模式会为每一个容器分配、设置IP等，并将容器连接到一个docker0虚拟网桥，通过docker0网桥以及Iptables nat表配置与宿主机通信 【默认是就是该模式】</table></div><h5 id="host模式">Host模式<a href="#host模式" class="anchor"><i class="fas fa-hashtag"></i></a></h5></h5><p>如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是<strong>和宿主机共用一个Network Namespace</strong>。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p><p>使用host模式的容器可以直接使用宿主机的IP地址与外界通信，容器内部的服务端口也可以使用宿主机的端口，不需要进行NAT，host最大的优势就是网络性能比较好。<strong>但是docker host上已经使用的端口就不能再用了，网络的隔离性不好。</strong></p><p><img data-src="../../assets/images/20220215docker/webp" alt="img" style="zoom:50%;" data-proofer-ignore></p><h5 id="container模式">Container模式<a href="#container模式" class="anchor"><i class="fas fa-hashtag"></i></a></h5></h5><p>这个模式指定<strong>新创建的容器和已经存在的一个容器共享一个 Network Namespace</strong>，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。</p><p><img data-src="../../assets/images/20220215docker/image-20220217143100868.png" alt="image-20220217143100868" style="zoom: 67%;" data-proofer-ignore></p><h5 id="none模式">None模式<a href="#none模式" class="anchor"><i class="fas fa-hashtag"></i></a></h5></h5><p>使用none模式，Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。也就是说，这个Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。</p><p><strong>这种网络模式下容器只有lo回环网络，没有其他网卡</strong>。none模式可以在容器创建时通过–network=none来指定。这种类型的网络没有办法联网，封闭的网络能很好的保证容器的安全性。</p><p><img data-src="../../assets/images/20220215docker/image-20220217143239419.png" alt="image-20220217143239419" style="zoom:67%;" data-proofer-ignore></p><h5 id="bridge模式">Bridge模式<a href="#bridge模式" class="anchor"><i class="fas fa-hashtag"></i></a></h5></h5><p>当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。</p><p>从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。在主机上创建一对虚拟网卡<code class="language-plaintext highlighter-rouge">veth pair</code>设备，Docker将<code class="language-plaintext highlighter-rouge">veth pair</code>设备的一端放在新创建的容器中，并命名为<code class="language-plaintext highlighter-rouge">eth0（容器的网卡）</code>，另一端放在主机中，以<code class="language-plaintext highlighter-rouge">vethxxx</code>这样类似的名字命名，并将这个网络设备加入到docker0网桥中。可以通过<code class="language-plaintext highlighter-rouge">brctl show</code>命令查看。</p><p>bridge模式是docker的默认网络模式，不写–net参数，就是bridge模式。使用<code class="language-plaintext highlighter-rouge">docker run -p</code>时，docker实际是在iptables做了DNAT(目的地址转换)规则，实现端口转发功能。可以使用<code class="language-plaintext highlighter-rouge">iptables -t nat -vnL</code>查看。</p><div class="language-sh highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre>docker network inspect bridge
<span class="o">[</span>
    <span class="o">{</span>
        <span class="s2">"Name"</span>: <span class="s2">"bridge"</span>,
        <span class="s2">"Id"</span>: <span class="s2">"88d2242caf7b6af84d1d0aa2415d730f01637c52ef5fb8ca4d3916e1374f0147"</span>,
        <span class="s2">"Created"</span>: <span class="s2">"2022-02-17T11:10:04.698146145+08:00"</span>,
        <span class="s2">"Scope"</span>: <span class="s2">"local"</span>,
        <span class="s2">"Driver"</span>: <span class="s2">"bridge"</span>,
        <span class="s2">"EnableIPv6"</span>: <span class="nb">false</span>,
        <span class="s2">"IPAM"</span>: <span class="o">{</span>
            <span class="s2">"Driver"</span>: <span class="s2">"default"</span>,
            <span class="s2">"Options"</span>: null,
            <span class="s2">"Config"</span>: <span class="o">[</span>
                <span class="o">{</span>
                    <span class="s2">"Subnet"</span>: <span class="s2">"172.17.0.0/16"</span>,
                    <span class="s2">"Gateway"</span>: <span class="s2">"172.17.0.1"</span>
                <span class="o">}</span>
            <span class="o">]</span>
        <span class="o">}</span>,
        <span class="s2">"Internal"</span>: <span class="nb">false</span>,
        <span class="s2">"Attachable"</span>: <span class="nb">false</span>,
        <span class="s2">"Ingress"</span>: <span class="nb">false</span>,
        <span class="s2">"ConfigFrom"</span>: <span class="o">{</span>
            <span class="s2">"Network"</span>: <span class="s2">""</span>
        <span class="o">}</span>,
        <span class="s2">"ConfigOnly"</span>: <span class="nb">false</span>,
        <span class="s2">"Containers"</span>: <span class="o">{}</span>,
        <span class="s2">"Options"</span>: <span class="o">{</span>
            <span class="s2">"com.docker.network.bridge.default_bridge"</span>: <span class="s2">"true"</span>,
            <span class="s2">"com.docker.network.bridge.enable_icc"</span>: <span class="s2">"true"</span>,
            <span class="s2">"com.docker.network.bridge.enable_ip_masquerade"</span>: <span class="s2">"true"</span>,
            <span class="s2">"com.docker.network.bridge.host_binding_ipv4"</span>: <span class="s2">"0.0.0.0"</span>,
            <span class="s2">"com.docker.network.bridge.name"</span>: <span class="s2">"docker0"</span>,
            <span class="s2">"com.docker.network.driver.mtu"</span>: <span class="s2">"1500"</span>
        <span class="o">}</span>,
        <span class="s2">"Labels"</span>: <span class="o">{}</span>
    <span class="o">}</span>
<span class="o">]</span>
</pre></table></code></div></div><p><img data-src="../../assets/images/20220215docker/image-20220217143400160.png" alt="image-20220217143400160" style="zoom:67%;" data-proofer-ignore></p><p>本节只是介绍了docker容器的4种网络模式，这些都是在创建容器的时候指定的，即通过<code class="language-plaintext highlighter-rouge">docker命令行</code>来执行，为了容器的编排与管理，后面会讲解<code class="language-plaintext highlighter-rouge">docker-compose</code>的内容，涉及到在文件中指定网络模式，详情见<code class="language-plaintext highlighter-rouge">docker-compose</code>文档。</p><h3 id="5docker可视化工具">5.docker可视化工具<a href="#5docker可视化工具" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>docker官方提供了管理工具<code class="language-plaintext highlighter-rouge">pointainer</code>，使用步骤如下</p><div class="language-sh highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c"># 1.拉取镜像</span>
docker pull portainer/portainer
<span class="c"># 2. 创建挂载卷,</span>
docker volume create portainer_data
<span class="c"># 3. 启动portainer</span>
docker run <span class="nt">-d</span> <span class="nt">-p</span>  8000:8000 <span class="nt">-p</span> 9000:9000 <span class="nt">--name</span><span class="o">=</span>portainer <span class="nt">--restart</span><span class="o">=</span>always <span class="nt">-v</span> /var/run/docker.sock:/var/run/docker.sock <span class="nt">-v</span> portainer_data:/data portainer/portainer-ce	 
<span class="c"># 4.访问https://localhost:9000 即可访问和管理本机或者远端的docker</span>
</pre></table></code></div></div><p><img data-src="../../assets/images/20220215docker/image-20220307164843004.png" alt="image-20220307164843004" style="zoom:80%;" data-proofer-ignore></p><h3 id="参考链接">参考链接<a href="#参考链接" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><hr /><ol><li><p><a href="https://www.jianshu.com/p/22a7032bb7bd">链接</a></p><li><p><a href="https://www.cnblogs.com/xiao987334176/p/10049844.html">docker多主机间容器通信</a></p></ol></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97/'>边缘计算</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/devops/" class="post-tag no-text-decoration" >DevOps</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Docker基础 - Technical Blogs&url=https://carmanzheng.github.io//posts/docker%E5%9F%BA%E7%A1%80/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Docker基础 - Technical Blogs&u=https://carmanzheng.github.io//posts/docker%E5%9F%BA%E7%A1%80/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Docker基础 - Technical Blogs&url=https://carmanzheng.github.io//posts/docker%E5%9F%BA%E7%A1%80/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Kubernetes%E6%A6%82%E8%BF%B0/">Kubernetes</a><li><a href="/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">MySQL存储引擎</a><li><a href="/posts/Linux%E5%9F%BA%E7%A1%80/">Linux基础</a><li><a href="/posts/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Python基操-多进程与多线程</a><li><a href="/posts/%E5%89%8D%E7%AB%AF-Vue%E8%B7%AF%E7%94%B1%E4%B8%8EVuex/">前端 Vue路由与vuex</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/mysql/">MySQL</a> <a class="post-tag" href="/tags/python%E5%9F%BA%E6%93%8D/">Python基操</a> <a class="post-tag" href="/tags/%E5%89%8D%E7%AB%AFjs/">前端JS</a> <a class="post-tag" href="/tags/%E5%89%8D%E7%AB%AFvue/">前端Vue</a> <a class="post-tag" href="/tags/%E5%89%8D%E7%AB%AFcss/">前端CSS</a> <a class="post-tag" href="/tags/devops/">DevOps</a> <a class="post-tag" href="/tags/linux%E5%9F%BA%E7%A1%80/">Linux基础</a> <a class="post-tag" href="/tags/%E5%89%8D%E7%AB%AFhtml/">前端HTML</a> <a class="post-tag" href="/tags/github/">Github</a> <a class="post-tag" href="/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91/">客户端开发</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Nginx/"><div class="card-body"> <em class="timeago small" date="2022-01-24 00:00:00 +0800" >01-24</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Nginx</h3><div class="text-muted small"><p> 本文主要介绍Nginx内容，Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。 它不仅是一个高性能的HTTP和反向代理服务器，同时也是一个IMAP/POP3/...</p></div></div></a></div><div class="card"> <a href="/posts/Docker-Compose-%E7%A9%BA/"><div class="card-body"> <em class="timeago small" date="2022-02-16 00:00:00 +0800" >02-16</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Docker-Compose</h3><div class="text-muted small"><p> 1. Docker Compose简介 ​ Docker Compose是一个用来定义和运行复杂应用的Docker工具。一个使用Docker容器的应用，通常由多个容器组成。使用Docker Compose不再需要使用shell脚本来启动容器。 ​ Docker Compose 通过一个配置文件（yml文件）来管理多个Docker容器，在配置文件中，所有的容器通过services来定义...</p></div></div></a></div><div class="card"> <a href="/posts/Kubernetes%E6%A6%82%E8%BF%B0/"><div class="card-body"> <em class="timeago small" date="2022-02-17 00:00:00 +0800" >02-17</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Kubernetes</h3><div class="text-muted small"><p> ​ K8s是谷歌在2014年开源的容器化集群管理系统，使用k8s进行容器化应用部署。k8s利于应用的扩展，让容器化应用更加简洁高效。 1.自动装箱 ​ 基于容器对应用运行环境的资源配置要求，自动部署应用容器 2.自我修复 ​ 当容器失败时，会对容器进行重启 ​ 当所部署的Node节点有问题时，会对容器进行重新部署和重新调度 ​ 当容器未通过监控检查时，会关闭此容器；直到容器正常...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Nginx/" class="btn btn-outline-primary" prompt="上一篇"><p>Nginx</p></a> <a href="/posts/Docker-Compose-%E7%A9%BA/" class="btn btn-outline-primary" prompt="下一篇"><p>Docker-Compose</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/carmanzheng">carmanzheng</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/mysql/">MySQL</a> <a class="post-tag" href="/tags/python%E5%9F%BA%E6%93%8D/">Python基操</a> <a class="post-tag" href="/tags/%E5%89%8D%E7%AB%AFjs/">前端JS</a> <a class="post-tag" href="/tags/%E5%89%8D%E7%AB%AFvue/">前端Vue</a> <a class="post-tag" href="/tags/%E5%89%8D%E7%AB%AFcss/">前端CSS</a> <a class="post-tag" href="/tags/devops/">DevOps</a> <a class="post-tag" href="/tags/linux%E5%9F%BA%E7%A1%80/">Linux基础</a> <a class="post-tag" href="/tags/%E5%89%8D%E7%AB%AFhtml/">前端HTML</a> <a class="post-tag" href="/tags/github/">Github</a> <a class="post-tag" href="/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91/">客户端开发</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
