<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="天前"><meta name="hour-prompt" content="小时前"><meta name="minute-prompt" content="分钟前"><meta name="justnow-prompt" content="刚刚"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="MySQL变量、流程控制和游标" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="1. 变量" /><meta property="og:description" content="1. 变量" /><link rel="canonical" href="https://carmanzheng.github.io//posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E5%8F%98%E9%87%8F-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%92%8C%E6%B8%B8%E6%A0%87/" /><meta property="og:url" content="https://carmanzheng.github.io//posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E5%8F%98%E9%87%8F-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%92%8C%E6%B8%B8%E6%A0%87/" /><meta property="og:site_name" content="Technical Blogs" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-06-16T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="MySQL变量、流程控制和游标" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"1. 变量","headline":"MySQL变量、流程控制和游标","dateModified":"2021-06-16T00:00:00+08:00","datePublished":"2021-06-16T00:00:00+08:00","url":"https://carmanzheng.github.io//posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E5%8F%98%E9%87%8F-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%92%8C%E6%B8%B8%E6%A0%87/","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://carmanzheng.github.io//posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E5%8F%98%E9%87%8F-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%92%8C%E6%B8%B8%E6%A0%87/"},"@context":"https://schema.org"}</script><title>MySQL变量、流程控制和游标 | Technical Blogs</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Technical Blogs"><meta name="application-name" content="Technical Blogs"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="zh-CN"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/favicons/android-chrome-192x192.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Technical Blogs</a></div><div class="site-subtitle font-italic">Learning by Doing, Sharing for more!</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/Carmanzheng" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['zhengkan1993','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>MySQL变量、流程控制和游标</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>MySQL变量、流程控制和游标</h1><div class="post-meta text-muted"><div> 作者 <em> <a href="https://github.com/carmanzheng">carmanzheng</a> </em></div><div class="d-flex"><div> <span> 发表于 <em class="timeago" date="2021-06-16 00:00:00 +0800" data-toggle="tooltip" data-placement="bottom" title="2021-06-16, 00:00 +0800" >2021-06-16</em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="9237 字"> <em>51 分钟</em>阅读</span></div></div></div><div class="post-content"><h2 id="1-变量">1. 变量<a href="#1-变量" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>​ 在MySQL数据库的存储过程和函数中，可以使用变量来存储查询或计算的中间结果数据，或者输出最终 的结果数据。 在 MySQL 数据库中，变量分为 <code class="language-plaintext highlighter-rouge">系统变量</code> 以及 <code class="language-plaintext highlighter-rouge">用户自定义变量</code> 。</p><h3 id="11-系统变量">1.1 系统变量<a href="#11-系统变量" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><h4 id="111-系统变量分类">1.1.1 系统变量分类<a href="#111-系统变量分类" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>​ 变量由系统定义，不是用户定义，属于 服务器 层面。启动MySQL服务，生成MySQL服务实例期间， MySQL将为MySQL服务器内存中的系统变量赋值，这些系统变量定义了当前MySQL服务实例的属性、特 征。这些系统变量的值要么是 编译MySQL时参数 的默认值，要么是 配置文件 （例如my.ini等）中的参数 值。大家可以通过网址 <code class="language-plaintext highlighter-rouge">https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html</code> 查看MySQL文档的系统变量。</p><p>​ 系统变量分为<code class="language-plaintext highlighter-rouge">全局系统变量</code>（需要添加 global 关键字）以及<code class="language-plaintext highlighter-rouge">会话系统变量</code>（需要添加 session 关键 字），有时也把全局系统变量简称为全局变量，有时也把会话系统变量称为local变量。如果不写，默认 会话级别。静态变量（在 MySQL 服务实例运行期间它们的值不能使用 set 动态修改）属于特殊的全局系 统变量。</p><p>​ 每一个MySQL客户机成功连接MySQL服务器后，都会产生与之对应的会话。会话期间，MySQL服务实例 会在MySQL服务器内存中生成与该会话对应的会话系统变量，这些会话系统变量的初始值是全局系统变 量值的复制。如下图：</p><p><img data-src="../../assets/images/20210616MysqlVariable/image-20220528171844456.png" alt="image-20220528171844456" data-proofer-ignore></p><ul><li><p>全局系统变量针对于所有会话（连接）有效，但<code class="language-plaintext highlighter-rouge"> 不能跨重启</code></p><li>会话系统变量仅针对于当前会话（连接）有效。会话期间，当前会话对某个会话系统变量值的修 改，不会影响其他会话同一个会话系统变量的值。<li>会话1对某个全局系统变量值的修改会导致会话2中同一个全局系统变量值的修改。</ul><p>​ 在MySQL中有些系统变量只能是全局的，例如 max_connections 用于限制服务器的最大连接数；有些系 统变量作用域既可以是全局又可以是会话，例如 character_set_client 用于设置客户端的字符集；有些系 统变量的作用域只能是当前会话，例如 pseudo_thread_id 用于标记当前会话的 MySQL 连接 ID。</p><h4 id="112-查看系统变量">1.1.2 查看系统变量<a href="#112-查看系统变量" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>查看所有或部分系统变量</p><pre><code class="language-mysql">#查看所有全局变量
SHOW GLOBAL VARIABLES;
#查看所有会话变量
SHOW SESSION VARIABLES;
或
SHOW VARIABLES;
</code></pre><pre><code class="language-mysql">#查看满足条件的部分系统变量。
SHOW GLOBAL VARIABLES LIKE '%标识符%';
#查看满足条件的部分会话变量
SHOW SESSION VARIABLES LIKE '%标识符%';
</code></pre><p>举例：</p><pre><code class="language-mysql">SHOW GLOBAL VARIABLES LIKE 'admin_%';
</code></pre><p>查看指定系统变量</p><p>​ 作为 MySQL 编码规范，MySQL 中的系统变量以 两个“@” 开头，其中“@@global”仅用于标记全局系统变 量，“@@session”仅用于标记会话系统变量。“@@”首先标记会话系统变量，如果会话系统变量不存在， 则标记全局系统变量。</p><pre><code class="language-mysql">#查看指定的系统变量的值
SELECT @@global.变量名;
#查看指定的会话变量的值
SELECT @@session.变量名;
#或者
SELECT @@变量名;
</code></pre><p>修改系统变量的值</p><p>​ 有些时候，数据库管理员需要修改系统变量的默认值，以便修改当前会话或者MySQL服务实例的属性、 特征。具体方法：</p><ul><li>方式1：修改MySQL 配置文件 ，继而修改MySQL系统变量的值（该方法需要重启MySQL服务）<li>方式2：在MySQL服务运行期间，使用“set”命令重新设置系统变量的值</ul><pre><code class="language-mysql">#为某个系统变量赋值
#方式1：
SET @@global.变量名=变量值;
#方式2：
SET GLOBAL 变量名=变量值;
#为某个会话变量赋值
#方式1：
SET @@session.变量名=变量值;
#方式2：
SET SESSION 变量名=变量值;
</code></pre><p>举例：</p><pre><code class="language-mysql">SELECT @@global.autocommit;
SET GLOBAL autocommit=0;

SELECT @@session.tx_isolation;
SET @@session.tx_isolation='read-uncommitted';

SET GLOBAL max_connections = 1000;
SELECT @@global.max_connections;

</code></pre><h3 id="12-用户变量">1.2 用户变量<a href="#12-用户变量" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><h4 id="121-用户变量分类">1.2.1 用户变量分类<a href="#121-用户变量分类" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>​ 用户变量是用户自己定义的，作为 MySQL 编码规范，MySQL 中的用户变量以 一个“@” 开头。根据作用 范围不同，又分为 会话用户变量 和 局部变量 。</p><ul><li><code class="language-plaintext highlighter-rouge">会话用户变量</code>：作用域和会话变量一样，只对 当前连接 会话有效。<li><code class="language-plaintext highlighter-rouge">局部变量</code>：只在 BEGIN 和 END 语句块中有效。局部变量只能在 存储过程和函数 中使用。</ul><h4 id="122-会话用户变量">1.2.2 会话用户变量<a href="#122-会话用户变量" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>变量的定义</p><pre><code class="language-mysql">#方式1：“=”或“:=”
SET @用户变量 = 值;
SET @用户变量 := 值;
#方式2：“:=” 或 INTO关键字
SELECT @用户变量 := 表达式 [FROM 等子句];
SELECT 表达式 INTO @用户变量 [FROM 等子句];
</code></pre><p>查看用户变量的值 （查看、比较、运算等）</p><p><code class="language-plaintext highlighter-rouge">SELECT @用户变量</code></p><p>举例</p><pre><code class="language-mysql">SET @a = 1;
SELECT @a;
</code></pre><pre><code class="language-mysql">SELECT @num := COUNT(*) FROM employees;
SELECT @num;
</code></pre><pre><code class="language-mysql">SELECT AVG(salary) INTO @avgsalary FROM employees;
SELECT @avgsalary;

SELECT @big; #查看某个未声明的变量时，将得到NULL值
</code></pre><h4 id="123-局部变量">1.2.3 局部变量<a href="#123-局部变量" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>定义：可以使用 DECLARE 语句定义一个局部变量</p><p>作用域：仅仅在定义它的 BEGIN … END 中有效</p><p>位置：只能放在 BEGIN … END 中，而且只能放在第一句</p><pre><code class="language-mysql">BEGIN
#声明局部变量
DECLARE 变量名1 变量数据类型 [DEFAULT 变量默认值];
DECLARE 变量名2,变量名3,... 变量数据类型 [DEFAULT 变量默认值];
#为局部变量赋值
SET 变量名1 = 值;
SELECT 值 INTO 变量名2 [FROM 子句];
#查看局部变量的值
SELECT 变量1,变量2,变量3;
END
</code></pre><p>1.定义变量</p><p><code class="language-plaintext highlighter-rouge">DECLARE 变量名 类型 [default 值]; # 如果没有DEFAULT子句，初始值为NULL</code></p><p>举例：</p><p><code class="language-plaintext highlighter-rouge">DECLARE myparam INT DEFAULT 100;</code></p><p>2.变量赋值</p><p>方式1：一般用于赋简单的值</p><pre><code class="language-mysql">SET 变量名=值;
SET 变量名:=值;
</code></pre><p>方式2：一般用于赋表中的字段值</p><p><code class="language-plaintext highlighter-rouge">SELECT 字段名或表达式 INTO 变量名 FROM 表;</code></p><p>3.使用变量（查看、比较、运算等）</p><p><code class="language-plaintext highlighter-rouge">SELECT 局部变量名;</code></p><p>举例1：声明局部变量，并分别赋值为employees表中employee_id为102的last_name和salary</p><pre><code class="language-mysql">DELIMITER //
CREATE PROCEDURE set_value()
BEGIN
DECLARE emp_name VARCHAR(25);
DECLARE sal DOUBLE(10,2);
SELECT last_name,salary INTO emp_name,sal
FROM employees
WHERE employee_id = 102;
SELECT emp_name,sal;
END //
DELIMITER ;
</code></pre><p>举例2：声明两个变量，求和并打印 （分别使用会话用户变量、局部变量的方式实现）</p><pre><code class="language-mysql">#方式1：使用用户变量
SET @m=1;
SET @n=1;
SET @sum=@m+@n;
SELECT @sum;
</code></pre><pre><code class="language-mysql">#方式2：使用局部变量
DELIMITER //
CREATE PROCEDURE add_value()
BEGIN
#局部变量
DECLARE m INT DEFAULT 1;
DECLARE n INT DEFAULT 3;
DECLARE SUM INT;
SET SUM = m+n;
SELECT SUM;
END //
DELIMITER ;
</code></pre><p>举例3：创建存储过程“different_salary”查询某员工和他领导的薪资差距，并用IN参数emp_id接收员工 id，用OUT参数dif_salary输出薪资差距结果。</p><pre><code class="language-mysql">#声明
DELIMITER //
CREATE PROCEDURE different_salary(IN emp_id INT,OUT dif_salary DOUBLE)
BEGIN
#声明局部变量
DECLARE emp_sal,mgr_sal DOUBLE DEFAULT 0.0;
DECLARE mgr_id INT;
SELECT salary INTO emp_sal FROM employees WHERE employee_id = emp_id;
SELECT manager_id INTO mgr_id FROM employees WHERE employee_id = emp_id;
SELECT salary INTO mgr_sal FROM employees WHERE employee_id = mgr_id;
SET dif_salary = mgr_sal - emp_sal;
END //
DELIMITER ;
#调用
SET @emp_id = 102;
CALL different_salary(@emp_id,@diff_sal);
#查看
SELECT @diff_sal;
</code></pre><h4 id="124-对比会话用户变量与局部变量">1.2.4 对比会话用户变量与局部变量<a href="#124-对比会话用户变量与局部变量" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><div class="table-wrapper"><table><thead><tr><th> <th>作用域<th>定义位置<th>语法<tbody><tr><td>会话用户变量<td>当前会话<td>会话的任何地方<td>加@符号，不用指定类型<tr><td>局部变量<td>定义它的BEGIN AND 中<td>BEGIN END的第一句话<td>一般不加@，需要指定类型</table></div><h2 id="2-定义条件与处理程序">2. 定义条件与处理程序<a href="#2-定义条件与处理程序" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p><code class="language-plaintext highlighter-rouge">定义条件 </code>是事先定义程序执行过程中可能遇到的问题， <code class="language-plaintext highlighter-rouge">处理程序</code>定义了在遇到问题时应当采取的处理方 式，并且保证存储过程或函数在遇到警告或错误时能继续执行。这样可以增强存储程序处理问题的能 力，避免程序异常停止运行。 说明：定义条件和处理程序在存储过程、存储函数中都是支持的。</p><h3 id="21-案例分析">2.1 案例分析<a href="#21-案例分析" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>案例分析：创建一个名称为“UpdateDataNoCondition”的存储过程。代码如下：</p><pre><code class="language-mysql">DELIMITER //
CREATE PROCEDURE UpdateDataNoCondition()
BEGIN
SET @x = 1;
UPDATE employees SET email = NULL WHERE last_name = 'Abel';
SET @x = 2;
UPDATE employees SET email = 'aabbel' WHERE last_name = 'Abel';
SET @x = 3;
END //
DELIMITER ;
</code></pre><p>调用存储过程：</p><pre><code class="language-mysql">mysql&gt; CALL UpdateDataNoCondition();
ERROR 1048 (23000): Column 'email' cannot be null
mysql&gt; SELECT @x;
+------+
| @x   |
+------+
| 1    |
+------+
1 row in set (0.00 sec)
</code></pre><p>​ 可以看到，此时@x变量的值为1。结合创建存储过程的SQL语句代码可以得出：在存储过程中未定义条件 和处理程序，且当存储过程中执行的SQL语句报错时，MySQL数据库会抛出错误，并退出当前SQL逻辑， 不再向下继续执行。</p><h3 id="22-定义条件">2.2 定义条件<a href="#22-定义条件" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>定义条件就是给MySQL中的错误码命名，这有助于存储的程序代码更清晰。它将一个 错误名字 和 指定的<code class="language-plaintext highlighter-rouge"> 错误条件</code> 关联起来。这个名字可以随后被用在定义处理程序的 DECLARE HANDLER 语句中。 定义条件使用DECLARE语句，语法格式如下：</p><p><code class="language-plaintext highlighter-rouge">DECLARE 错误名称 CONDITION FOR 错误码（或错误条件）</code></p><p>错误码的说明：</p><ul><li>MySQL_error_code 和 sqlstate_value 都可以表示MySQL的错误。<ul><li>MySQL_error_code是数值类型错误代码。<li>sqlstate_value是长度为5的字符串类型错误代码。</ul><li>例如，在ERROR 1418 (HY000)中，1418是MySQL_error_code，’HY000’是sqlstate_value。<li>例如，在ERROR 1142（42000）中，1142是MySQL_error_code，’42000’是sqlstate_value。</ul><p>举例1：定义“Field_Not_Be_NULL”错误名与MySQL中违反非空约束的错误类型是“ERROR 1048 (23000)”对 应。</p><pre><code class="language-mysql">#使用MySQL_error_code
DECLARE Field_Not_Be_NULL CONDITION FOR 1048;
#使用sqlstate_value
DECLARE Field_Not_Be_NULL CONDITION FOR SQLSTATE '23000';
</code></pre><p>举例2：定义”ERROR 1148(42000)”错误，名称为command_not_allowed。</p><pre><code class="language-mysql">#使用MySQL_error_code
DECLARE command_not_allowed CONDITION FOR 1148;
#使用sqlstate_value
DECLARE command_not_allowed CONDITION FOR SQLSTATE '42000';
</code></pre><h3 id="23-定义处理程序">2.3 定义处理程序<a href="#23-定义处理程序" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>可以为SQL执行过程中发生的某种类型的错误定义特殊的处理程序。定义处理程序时，使用DECLARE语句 的语法如下：</p><p><code class="language-plaintext highlighter-rouge">DECLARE 处理方式 HANDLER FOR 错误类型 处理语句</code></p><p>处理方式：处理方式有3个取值：CONTINUE、EXIT、UNDO。</p><ul><li>CONTINUE ：表示遇到错误不处理，继续执行。<li>EXIT ：表示遇到错误马上退出。<li>UNDO ：表示遇到错误后撤回之前的操作。MySQL中暂时不支持这样的操作。</ul><p>错误类型（即条件）可以有如下取值：</p><ul><li>SQLSTATE ‘字符串错误码’ ：表示长度为5的sqlstate_value类型的错误代码；<li>MySQL_error_code ：匹配数值类型错误代码；<li>错误名称 ：表示DECLARE … CONDITION定义的错误条件名称。<li>SQLWARNING ：匹配所有以01开头的SQLSTATE错误代码；<li>NOT FOUND ：匹配所有以02开头的SQLSTATE错误代码；<li>SQLEXCEPTION ：匹配所有没有被SQLWARNING或NOT FOUND捕获的SQLSTATE错误代码；</ul><p>处理语句：如果出现上述条件之一，则采用对应的处理方式，并执行指定的处理语句。语句可以是 像“ SET 变量 = 值 ”这样的简单语句，也可以是使用 BEGIN … END 编写的复合语句。</p><p>定义处理程序的几种方式，代码如下：</p><pre><code class="language-mysql">#方法1：捕获sqlstate_value
DECLARE CONTINUE HANDLER FOR SQLSTATE '42S02' SET @info = 'NO_SUCH_TABLE';
#方法2：捕获mysql_error_value
DECLARE CONTINUE HANDLER FOR 1146 SET @info = 'NO_SUCH_TABLE';
#方法3：先定义条件，再调用
DECLARE no_such_table CONDITION FOR 1146;
DECLARE CONTINUE HANDLER FOR NO_SUCH_TABLE SET @info = 'NO_SUCH_TABLE';
#方法4：使用SQLWARNING
DECLARE EXIT HANDLER FOR SQLWARNING SET @info = 'ERROR';
#方法5：使用NOT FOUND
DECLARE EXIT HANDLER FOR NOT FOUND SET @info = 'NO_SUCH_TABLE';
#方法6：使用SQLEXCEPTION
DECLARE EXIT HANDLER FOR SQLEXCEPTION SET @info = 'ERROR';
</code></pre><h3 id="24-案例解决">2.4 案例解决<a href="#24-案例解决" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>​ 在存储过程中，定义处理程序，捕获sqlstate_value值，当遇到MySQL_error_code值为1048时，执行 CONTINUE操作，并且将@proc_value的值设置为-1。</p><pre><code class="language-mysql">DELIMITER //
CREATE PROCEDURE UpdateDataNoCondition()
BEGIN
#定义处理程序
DECLARE CONTINUE HANDLER FOR 1048 SET @proc_value = -1;
SET @x = 1;
UPDATE employees SET email = NULL WHERE last_name = 'Abel';
SET @x = 2;
UPDATE employees SET email = 'aabbel' WHERE last_name = 'Abel';
SET @x = 3;
END //
DELIMITER ;

</code></pre><p>调用过程：</p><pre><code class="language-mysql">mysql&gt; CALL UpdateDataWithCondition();
Query OK, 0 rows affected (0.01 sec)
mysql&gt; SELECT @x,@proc_value;
+------+-------------+
| @x   | @proc_value |
+------+-------------+
| 3    | -1          |
+------+-------------+
1 row in set (0.00 sec)

</code></pre><p>举例：</p><p>创建一个名称为“InsertDataWithCondition”的存储过程，代码如下。</p><p>在存储过程中，定义处理程序，捕获sqlstate_value值，当遇到sqlstate_value值为23000时，执行EXIT操 作，并且将@proc_value的值设置为-1。</p><pre><code class="language-mysql">#准备工作
CREATE TABLE departments
AS
SELECT * FROM atguigudb.`departments`;
ALTER TABLE departments
ADD CONSTRAINT uk_dept_name UNIQUE(department_id);
</code></pre><pre><code class="language-mysql">DELIMITER //
CREATE PROCEDURE InsertDataWithCondition()
BEGIN
DECLARE duplicate_entry CONDITION FOR SQLSTATE '23000' ;
DECLARE EXIT HANDLER FOR duplicate_entry SET @proc_value = -1;
SET @x = 1;
INSERT INTO departments(department_name) VALUES('测试');
SET @x = 2;
INSERT INTO departments(department_name) VALUES('测试');
SET @x = 3;
END //
DELIMITER ;
</code></pre><p>调用存储过程：</p><pre><code class="language-mysql">mysql&gt; CALL InsertDataWithCondition();
Query OK, 0 rows affected (0.01 sec)
mysql&gt; SELECT @x,@proc_value;
+------+-------------+
| @x   | @proc_value |
+------+-------------+
| 2    | -1          |
+------+-------------+
1 row in set (0.00 sec)
</code></pre><h2 id="3-流程控制">3. 流程控制<a href="#3-流程控制" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>解决复杂问题不可能通过一个 SQL 语句完成，我们需要执行多个 SQL 操作。流程控制语句的作用就是控 制存储过程中 SQL 语句的执行顺序，是我们完成复杂操作必不可少的一部分。只要是执行的程序，流程 就分为三大类：</p><ul><li>顺序结构 ：程序从上往下依次执行<li>分支结构 ：程序按条件进行选择执行，从两条或多条路径中选择一条执行<li>循环结构 ：程序满足一定条件下，重复执行一组语句</ul><p>针对于MySQL 的流程控制语句主要有 3 类。注意：只能用于存储程序。</p><ul><li>条件判断语句 ：IF 语句和 CASE 语句<li>循环语句 ：LOOP、WHILE 和 REPEAT 语句<li>跳转语句 ：ITERATE 和 LEAVE 语句</ul><h3 id="31-分支结构之-if">3.1 分支结构之 IF<a href="#31-分支结构之-if" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>IF 语句的语法结构是：</p><pre><code class="language-mysql">IF 表达式1 THEN 操作1
[ELSEIF 表达式2 THEN 操作2]……
[ELSE 操作N]
END IF
</code></pre><p>根据表达式的结果为TRUE或FALSE执行相应的语句。这里“[]”中的内容是可选的。</p><p>特点：① 不同的表达式对应不同的操作 ② 使用在begin end中</p><p>举例1：</p><pre><code class="language-mysql">IF val IS NULL
THEN SELECT 'val is null';
ELSE SELECT 'val is not null';
END IF;
</code></pre><p>举例2：声明存储过程“update_salary_by_eid1”，定义IN参数emp_id，输入员工编号。判断该员工 薪资如果低于8000元并且入职时间超过5年，就涨薪500元；否则就不变。</p><pre><code class="language-mysql">DELIMITER //
CREATE PROCEDURE update_salary_by_eid1(IN emp_id INT)
BEGIN
DECLARE emp_salary DOUBLE;
DECLARE hire_year DOUBLE;
SELECT salary INTO emp_salary FROM employees WHERE employee_id = emp_id;
SELECT DATEDIFF(CURDATE(),hire_date)/365 INTO hire_year
FROM employees WHERE employee_id = emp_id;
IF emp_salary &lt; 8000 AND hire_year &gt; 5
THEN UPDATE employees SET salary = salary + 500 WHERE employee_id = emp_id;
END IF;
END //
DELIMITER ;

</code></pre><p>举例3：声明存储过程“update_salary_by_eid2”，定义IN参数emp_id，输入员工编号。判断该员工 薪资如果低于9000元并且入职时间超过5年，就涨薪500元；否则就涨薪100元。</p><pre><code class="language-mysql">DELIMITER //
CREATE PROCEDURE update_salary_by_eid2(IN emp_id INT)
BEGIN
DECLARE emp_salary DOUBLE;
DECLARE hire_year DOUBLE;
SELECT salary INTO emp_salary FROM employees WHERE employee_id = emp_id;
SELECT DATEDIFF(CURDATE(),hire_date)/365 INTO hire_year
FROM employees WHERE employee_id = emp_id;
IF emp_salary &lt; 8000 AND hire_year &gt; 5
THEN UPDATE employees SET salary = salary + 500 WHERE employee_id =
emp_id;
ELSE
UPDATE employees SET salary = salary + 100 WHERE employee_id = emp_id;
END IF;
END //
DELIMITER ;
</code></pre><p>举例4：声明存储过程“update_salary_by_eid3”，定义IN参数emp_id，输入员工编号。判断该员工 薪资如果低于9000元，就更新薪资为9000元；薪资如果大于等于9000元且低于10000的，但是奖金 比例为NULL的，就更新奖金比例为0.01；其他的涨薪100元。</p><pre><code class="language-mysql">DELIMITER //
CREATE PROCEDURE update_salary_by_eid3(IN emp_id INT)
BEGIN
DECLARE emp_salary DOUBLE;
DECLARE bonus DECIMAL(3,2);
SELECT salary INTO emp_salary FROM employees WHERE employee_id = emp_id;
SELECT commission_pct INTO bonus FROM employees WHERE employee_id = emp_id;
IF emp_salary &lt; 9000
THEN UPDATE employees SET salary = 9000 WHERE employee_id = emp_id;
DELIMITER //
CREATE PROCEDURE update_salary_by_eid3(IN emp_id INT)
BEGIN
DECLARE emp_salary DOUBLE;
DECLARE bonus DECIMAL(3,2);
SELECT salary INTO emp_salary FROM employees WHERE employee_id = emp_id;
SELECT commission_pct INTO bonus FROM employees WHERE employee_id = emp_id;
IF emp_salary &lt; 9000
THEN UPDATE employees SET salary = 9000 WHERE employee_id = emp_id;
</code></pre><h3 id="32-分支结构之-case">3.2 分支结构之 CASE<a href="#32-分支结构之-case" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>CASE 语句的语法结构1：</p><pre><code class="language-mysql">#情况一：类似于switch
CASE 表达式
WHEN 值1 THEN 结果1或语句1(如果是语句，需要加分号)
WHEN 值2 THEN 结果2或语句2(如果是语句，需要加分号)
...
ELSE 结果n或语句n(如果是语句，需要加分号)
END [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）
</code></pre><p>CASE 语句的语法结构2：</p><pre><code class="language-mysql">#情况二：类似于多重if
CASE
WHEN 条件1 THEN 结果1或语句1(如果是语句，需要加分号)
WHEN 条件2 THEN 结果2或语句2(如果是语句，需要加分号)
...
ELSE 结果n或语句n(如果是语句，需要加分号)
END [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）
</code></pre><p>举例1：</p><p>使用CASE流程控制语句的第1种格式，判断val值等于1、等于2，或者两者都不等。</p><pre><code class="language-mysql">CASE val
WHEN 1 THEN SELECT 'val is 1';
WHEN 2 THEN SELECT 'val is 2';
ELSE SELECT 'val is not 1 or 2';
END CASE;
</code></pre><p>举例2：</p><p>使用CASE流程控制语句的第2种格式，判断val是否为空、小于0、大于0或者等于0。</p><pre><code class="language-mysql">CASE
WHEN val IS NULL THEN SELECT 'val is null';
WHEN val &lt; 0 THEN SELECT 'val is less than 0';
WHEN val &gt; 0 THEN SELECT 'val is greater than 0';
ELSE SELECT 'val is 0';
END CASE;
</code></pre><p>举例3：</p><p>声明存储过程“update_salary_by_eid4”，定义IN参数emp_id，输入员工编号。判断该员工 薪资如果低于9000元，就更新薪资为9000元；薪资大于等于9000元且低于10000的，但是奖金比例 为NULL的，就更新奖金比例为0.01；其他的涨薪100元。</p><pre><code class="language-mysql">DELIMITER //
CREATE PROCEDURE update_salary_by_eid4(IN emp_id INT)
BEGIN
DECLARE emp_sal DOUBLE;
DECLARE bonus DECIMAL(3,2);
SELECT salary INTO emp_sal FROM employees WHERE employee_id = emp_id;
SELECT commission_pct INTO bonus FROM employees WHERE employee_id = emp_id;
CASE
WHEN emp_sal&lt;9000
THEN UPDATE employees SET salary=9000 WHERE employee_id = emp_id;
WHEN emp_sal&lt;10000 AND bonus IS NULL
THEN UPDATE employees SET commission_pct=0.01 WHERE employee_id = emp_id;
ELSE
UPDATE employees SET salary=salary+100 WHERE employee_id = emp_id;
END CASE;
END //
DELIMITER ;
</code></pre><p>举例4：声明存储过程update_salary_by_eid5，定义IN参数emp_id，输入员工编号。判断该员工的 入职年限，如果是0年，薪资涨50；如果是1年，薪资涨100；如果是2年，薪资涨200；如果是3年， 薪资涨300；如果是4年，薪资涨400；其他的涨薪500。</p><pre><code class="language-mysql">DELIMITER //
CREATE PROCEDURE update_salary_by_eid5(IN emp_id INT)
BEGIN
DECLARE emp_sal DOUBLE;
DECLARE hire_year DOUBLE;
SELECT salary INTO emp_sal FROM employees WHERE employee_id = emp_id;
SELECT ROUND(DATEDIFF(CURDATE(),hire_date)/365) INTO hire_year FROM employees
WHERE employee_id = emp_id;
CASE hire_year
WHEN 0 THEN UPDATE employees SET salary=salary+50 WHERE employee_id = emp_id;
WHEN 1 THEN UPDATE employees SET salary=salary+100 WHERE employee_id = emp_id;
WHEN 2 THEN UPDATE employees SET salary=salary+200 WHERE employee_id = emp_id;
WHEN 3 THEN UPDATE employees SET salary=salary+300 WHERE employee_id = emp_id;
WHEN 4 THEN UPDATE employees SET salary=salary+400 WHERE employee_id = emp_id;
ELSE UPDATE employees SET salary=salary+500 WHERE employee_id = emp_id;
END CASE;
END //
DELIMITER ;
</code></pre><h3 id="33-循环结构之loop">3.3 循环结构之LOOP<a href="#33-循环结构之loop" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>LOOP循环语句用来重复执行某些语句。LOOP内的语句一直重复执行直到循环被退出（使用LEAVE子 句），跳出循环过程。 LOOP语句的基本格式如下：</p><pre><code class="language-mysql">[loop_label:] LOOP
循环执行的语句
END LOOP [loop_label]
</code></pre><p>其中，loop_label表示LOOP语句的标注名称，该参数可以省略。</p><p>举例1： 使用LOOP语句进行循环操作，id值小于10时将重复执行循环过程。</p><pre><code class="language-mysql">DECLARE id INT DEFAULT 0;
add_loop:LOOP
SET id = id +1;
IF id &gt;= 10 THEN LEAVE add_loop;
END IF;
END LOOP add_loop;
</code></pre><p>举例2：当市场环境变好时，公司为了奖励大家，决定给大家涨工资。声明存储过程 “update_salary_loop()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家涨薪，薪资涨为 原来的1.1倍。直到全公司的平均薪资达到12000结束。并统计循环次数。</p><pre><code class="language-mysql">DELIMITER //
CREATE PROCEDURE update_salary_loop(OUT num INT)
BEGIN
DECLARE avg_salary DOUBLE;
DECLARE loop_count INT DEFAULT 0;
SELECT AVG(salary) INTO avg_salary FROM employees;
label_loop:LOOP
IF avg_salary &gt;= 12000 THEN LEAVE label_loop;
END IF;
UPDATE employees SET salary = salary * 1.1;
SET loop_count = loop_count + 1;
SELECT AVG(salary) INTO avg_salary FROM employees;
END LOOP label_loop;
SET num = loop_count;
END //
DELIMITER ;
</code></pre><h3 id="34-循环结构之while">3.4 循环结构之WHILE<a href="#34-循环结构之while" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>WHILE语句创建一个带条件判断的循环过程。WHILE在执行语句执行时，先对指定的表达式进行判断，如 果为真，就执行循环内的语句，否则退出循环。WHILE语句的基本格式如下：</p><pre><code class="language-mysql">[while_label:] WHILE 循环条件 DO
循环体
END WHILE [while_label];
</code></pre><p>while_label为WHILE语句的标注名称；如果循环条件结果为真，WHILE语句内的语句或语句群被执行，直 至循环条件为假，退出循环。</p><p>举例1： WHILE语句示例，i值小于10时，将重复执行循环过程，代码如下：</p><pre><code class="language-mysql">DELIMITER //
CREATE PROCEDURE test_while()
BEGIN
DECLARE i INT DEFAULT 0;
WHILE i &lt; 10 DO
SET i = i + 1;
END WHILE;
SELECT i;
END //
DELIMITER ;
#调用
CALL test_while();
</code></pre><p>举例2：市场环境不好时，公司为了渡过难关，决定暂时降低大家的薪资。声明存储过程 “update_salary_while()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家降薪，薪资降 为原来的90%。直到全公司的平均薪资达到5000结束。并统计循环次数。</p><pre><code class="language-mysql">DELIMITER //
CREATE PROCEDURE update_salary_while(OUT num INT)
BEGIN
DECLARE avg_sal DOUBLE ;
DECLARE while_count INT DEFAULT 0;
SELECT AVG(salary) INTO avg_sal FROM employees;
WHILE avg_sal &gt; 5000 DO
UPDATE employees SET salary = salary * 0.9;
SET while_count = while_count + 1;
SELECT AVG(salary) INTO avg_sal FROM employees;
END WHILE;
SET num = while_count;
END //
DELIMITER ;
</code></pre><h3 id="35-循环结构之repeat">3.5 循环结构之REPEAT<a href="#35-循环结构之repeat" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>​ REPEAT语句创建一个带条件判断的循环过程。与WHILE循环不同的是，REPEAT 循环首先会执行一次循 环，然后在 UNTIL 中进行表达式的判断，如果满足条件就退出，即 END REPEAT；如果条件不满足，则会 就继续执行循环，直到满足退出条件为止。 REPEAT语句的基本格式如下：</p><pre><code class="language-mysql">[repeat_label:] REPEAT
循环体的语句
UNTIL 结束循环的条件表达式
END REPEAT [repeat_label]
</code></pre><p>repeat_label为REPEAT语句的标注名称，该参数可以省略；REPEAT语句内的语句或语句群被重复，直至 expr_condition为真。</p><p>举例1：</p><pre><code class="language-mysql">DELIMITER //
CREATE PROCEDURE test_repeat()
BEGIN
DECLARE i INT DEFAULT 0;
REPEAT
SET i = i + 1;
UNTIL i &gt;= 10
END REPEAT;
SELECT i;
END //
DELIMITER ;
</code></pre><p>举例2：当市场环境变好时，公司为了奖励大家，决定给大家涨工资。声明存储过程 “update_salary_repeat()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家涨薪，薪资涨 为原来的1.15倍。直到全公司的平均薪资达到13000结束。并统计循环次数。</p><pre><code class="language-mysql">DELIMITER //
CREATE PROCEDURE update_salary_repeat(OUT num INT)
BEGIN
DECLARE avg_sal DOUBLE ;
DECLARE repeat_count INT DEFAULT 0;
SELECT AVG(salary) INTO avg_sal FROM employees;
REPEAT
UPDATE employees SET salary = salary * 1.15;
SET repeat_count = repeat_count + 1;
SELECT AVG(salary) INTO avg_sal FROM employees;
UNTIL avg_sal &gt;= 13000
END REPEAT;
SET num = repeat_count;
END //
DELIMITER ;
</code></pre><p>对比三种循环结构：</p><p>1、这三种循环都可以省略名称，但如果循环中添加了循环控制语句（LEAVE或ITERATE）则必须添加名 称。</p><p>2、 LOOP：一般用于实现简单的”死”循环 WHILE：先判断后执行 REPEAT：先执行后判断，无条件 至少执行一次</p><h3 id="36-跳转语句之leave语句">3.6 跳转语句之LEAVE语句<a href="#36-跳转语句之leave语句" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>LEAVE语句：可以用在循环语句内，或者以 BEGIN 和 END 包裹起来的程序体内，表示跳出循环或者跳出 程序体的操作。如果你有面向过程的编程语言的使用经验，你可以把 LEAVE 理解为 break。 基本格式如下：</p><pre><code class="language-mysql">LEAVE 标记名
</code></pre><p>其中，label参数表示循环的标志。LEAVE和BEGIN … END或循环一起被使用。</p><p>举例1：创建存储过程 “leave_begin()”，声明INT类型的IN参数num。给BEGIN…END加标记名，并在 BEGIN…END中使用IF语句判断num参数的值。</p><ul><li>如果num&lt;=0，则使用LEAVE语句退出BEGIN…END；<li>如果num=1，则查询“employees”表的平均薪资；<li>如果num=2，则查询“employees”表的最低薪资；<li>如果num&gt;2，则查询“employees”表的最高薪资。</ul><p>IF语句结束后查询“employees”表的总人数。</p><pre><code class="language-mysql">DELIMITER //
CREATE PROCEDURE leave_begin(IN num INT)
begin_label: BEGIN
IF num&lt;=0
THEN LEAVE begin_label;
ELSEIF num=1
THEN SELECT AVG(salary) FROM employees;
ELSEIF num=2
THEN SELECT MIN(salary) FROM employees;
ELSE
SELECT MAX(salary) FROM employees;
END IF;
SELECT COUNT(*) FROM employees;
END //
DELIMITER ;
</code></pre><p>举例2： 当市场环境不好时，公司为了渡过难关，决定暂时降低大家的薪资。声明存储过程“leave_while()”，声明 OUT参数num，输出循环次数，存储过程中使用WHILE循环给大家降低薪资为原来薪资的90%，直到全公 司的平均薪资小于等于10000，并统计循环次数。</p><pre><code class="language-mysql">DELIMITER //
CREATE PROCEDURE leave_while(OUT num INT)
BEGIN
#
DECLARE avg_sal DOUBLE;#记录平均工资
DECLARE while_count INT DEFAULT 0; #记录循环次数
SELECT AVG(salary) INTO avg_sal FROM employees; #① 初始化条件
while_label:WHILE TRUE DO #② 循环条件
#③ 循环体
IF avg_sal &lt;= 10000 THEN
LEAVE while_label;
END IF;
UPDATE employees SET salary = salary * 0.9;
SET while_count = while_count + 1;
#④ 迭代条件
SELECT AVG(salary) INTO avg_sal FROM employees;
END WHILE;
#赋值
SET num = while_count;
END //
DELIMITER ;
</code></pre><h3 id="37-跳转语句之iterate语句">3.7 跳转语句之ITERATE语句<a href="#37-跳转语句之iterate语句" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>ITERATE语句：只能用在循环语句（LOOP、REPEAT和WHILE语句）内，表示重新开始循环，将执行顺序 转到语句段开头处。如果你有面向过程的编程语言的使用经验，你可以把 ITERATE 理解为 continue，意 思为“再次循环”。 语句基本格式如下：</p><p><code class="language-plaintext highlighter-rouge">ITERATE label</code></p><p>label参数表示循环的标志。ITERATE语句必须跟在循环标志前面。</p><p>举例： 定义局部变量num，初始值为0。循环结构中执行num + 1操作。</p><ul><li>如果num &lt; 10，则继续执行循环；<li>如果num &gt; 15，则退出循环结构；</ul><pre><code class="language-mysql">DELIMITER //
CREATE PROCEDURE test_iterate()
BEGIN
DECLARE num INT DEFAULT 0;
my_loop:LOOP
SET num = num + 1;
IF num &lt; 10
THEN ITERATE my_loop;
ELSEIF num &gt; 15
THEN LEAVE my_loop;
END IF;
SELECT '尚硅谷：让天下没有难学的技术';
END LOOP my_loop;
END //
DELIMITER ;

</code></pre><h2 id="4-游标">4. 游标<a href="#4-游标" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="41-什么是游标或光标">4.1 什么是游标（或光标）<a href="#41-什么是游标或光标" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>​ 虽然我们也可以通过筛选条件 WHERE 和 HAVING，或者是限定返回记录的关键字 LIMIT 返回一条记录， 但是，却无法在结果集中像指针一样，向前定位一条记录、向后定位一条记录，或者是 随意定位到某一 条记录 ，并对记录的数据进行处理。</p><p>​ 这个时候，就可以用到游标。游标，提供了一种灵活的操作方式，让我们能够对结果集中的每一条记录 进行定位，并对指向的记录中的数据进行操作的数据结构。游标让 SQL 这种面向集合的语言有了面向过 程开发的能力。</p><p>​ 在 SQL 中，游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。这里游标 充当了 指针的作用 ，我们可以通过操作游标来对数据行进行操作。 MySQL中游标可以在存储过程和函数中使用。 比如，我们查询了 employees 数据表中工资高于15000的员工都有哪些：</p><pre><code class="language-mysql">SELECT employee_id,last_name,salary FROM employees
WHERE salary &gt; 15000;
</code></pre><p><img data-src="D:D:\07_GitHub\GitHub_Blogs\assets\images\20210616MysqlVariable\image-20220530143350975.png7_GitHub\GitHub_Blogs\assets\images0210616MysqlVariable\image-20220530143350975.png" alt="image-20220530143350975" data-proofer-ignore></p><p>​ 这里我们就可以通过游标来操作数据行，如图所示此时游标所在的行是“108”的记录，我们也可以在结果 集上滚动游标，指向结果集中的任意一行。</p><h3 id="42-使用游标步骤">4.2 使用游标步骤<a href="#42-使用游标步骤" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>​ 游标必须在声明处理程序之前被声明，并且变量和条件还必须在声明游标或处理程序之前被声明。 如果我们想要使用游标，一般需要经历四个步骤。不同的 DBMS 中，使用游标的语法可能略有不同。</p><p><strong>第一步，声明游标</strong></p><p>​ 在MySQL中，使用DECLARE关键字来声明游标，其语法的基本形式如下：</p><p><code class="language-plaintext highlighter-rouge">DECLARE cursor_name CURSOR FOR select_statement;</code></p><p>这个语法适用于 MySQL，SQL Server，DB2 和 MariaDB。</p><p>​ 如果是用 Oracle 或者 PostgreSQL，需要写成：</p><p><code class="language-plaintext highlighter-rouge">DECLARE cursor_name CURSOR IS select_statement;</code></p><p>​ 要使用 SELECT 语句来获取数据结果集，而此时还没有开始遍历数据，这里 select_statement 代表的是 SELECT 语句，返回一个用于创建游标的结果集。</p><p>比如：</p><pre><code class="language-mysql">DECLARE cur_emp CURSOR FOR
SELECT employee_id,salary FROM employees;
</code></pre><pre><code class="language-mysql">DECLARE cursor_fruit CURSOR FOR
SELECT f_name, f_price FROM fruits ;
</code></pre><p><strong>第二步，打开游标</strong></p><p>打开游标的语法如下：</p><p><code class="language-plaintext highlighter-rouge">OPEN cursor_name</code></p><p>​ 当我们定义好游标之后，如果想要使用游标，必须先打开游标。打开游标的时候 SELECT 语句的查询结 果集就会送到游标工作区，为后面游标的 逐条读取 结果集中的记录做准备。</p><p><code class="language-plaintext highlighter-rouge">OPEN cur_emp ;</code></p><p><strong>第三步，使用游标（从游标中取得数据）</strong></p><p>语法如下：</p><p><code class="language-plaintext highlighter-rouge">FETCH cursor_name INTO var_name [, var_name] ...</code></p><p>​ 这句的作用是使用 cursor_name 这个游标来读取当前行，并且将数据保存到 var_name 这个变量中，游 标指针指到下一行。如果游标读取的数据行有多个列名，则在 INTO 关键字后面赋值给多个变量名即可。 注意：var_name必须在声明游标之前就定义好。</p><p><code class="language-plaintext highlighter-rouge">FETCH cur_emp INTO emp_id, emp_sal ;</code></p><p>注意：游标的查询结果集中的字段数，必须跟 INTO 后面的变量数一致，否则，在存储过程执行的时 候，MySQL 会提示错误。</p><p><strong>第四步，关闭游标</strong></p><p><code class="language-plaintext highlighter-rouge">CLOSE cursor_name</code></p><p>​ 有 OPEN 就会有 CLOSE，也就是打开和关闭游标。当我们使用完游标后需要关闭掉该游标。因为游标会 占用系统资源 ，如果不及时关闭，游标会一直保持到存储过程结束，影响系统运行的效率。而关闭游标 的操作，会释放游标占用的系统资源。</p><p>​ 关闭游标之后，我们就不能再检索查询结果中的数据行，如果需要检索只能再次打开游标。</p><p><code class="language-plaintext highlighter-rouge">CLOSE cur_emp;</code></p><h3 id="43-举例">4.3 举例<a href="#43-举例" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>​ 创建存储过程<code class="language-plaintext highlighter-rouge">“get_count_by_limit_total_salary()”</code>，声明IN参数<code class="language-plaintext highlighter-rouge"> limit_total_salary</code>，<code class="language-plaintext highlighter-rouge">DOUBLE类型</code>；声明 OUT参数total_count，INT类型。函数的功能可以实现累加薪资最高的几个员工的薪资值，直到薪资总和 达到limit_total_salary参数的值，返回累加的人数给total_count。</p><pre><code class="language-MYSQL">DELIMITER //
CREATE PROCEDURE get_count_by_limit_total_salary(IN limit_total_salary DOUBLE,OUT
total_count INT)
BEGIN
DECLARE sum_salary DOUBLE DEFAULT 0; #记录累加的总工资
DECLARE cursor_salary DOUBLE DEFAULT 0; #记录某一个工资值
DECLARE emp_count INT DEFAULT 0; #记录循环个数
#定义游标
DECLARE emp_cursor CURSOR FOR SELECT salary FROM employees ORDER BY salary DESC;
#打开游标
OPEN emp_cursor;
REPEAT
#使用游标（从游标中获取数据）
FETCH emp_cursor INTO cursor_salary;
SET sum_salary = sum_salary + cursor_salary;
SET emp_count = emp_count + 1;
UNTIL sum_salary &gt;= limit_total_salary
END REPEAT;
SET total_count = emp_count;
#关闭游标
CLOSE emp_cursor;
END //
DELIMITER ;
</code></pre><h3 id="44小结">4.4小结<a href="#44小结" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>​ 游标是 MySQL 的一个重要的功能，为 逐条读取 结果集中的数据，提供了完美的解决方案。跟在应用层 面实现相同的功能相比，游标可以在存储程序中使用，效率高，程序也更加简洁。 但同时也会带来一些性能问题，比如在使用游标的过程中，会对数据行进行 加锁 ，这样在业务并发量大 的时候，不仅会影响业务之间的效率，还会 消耗系统资源 ，造成内存不足，这是因为游标是在内存中进 行的处理。 建议：养成用完之后就关闭的习惯，这样才能提高系统的整体效率。</p><h3 id="补充mysql-80的新特性全局变量的持久化">补充：MySQL 8.0的新特性—全局变量的持久化<a href="#补充mysql-80的新特性全局变量的持久化" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>​ 在MySQL数据库中，全局变量可以通过<code class="language-plaintext highlighter-rouge">SET GLOBAL</code>语句来设置。例如，设置服务器语句超时的限制，可 以通过设置系统变量max_execution_time来实现：</p><p><code class="language-plaintext highlighter-rouge">SET GLOBAL MAX_EXECUTION_TIME=2000;</code></p><p>​ 使用SET GLOBAL语句设置的变量值只会 临时生效 。 数据库重启后，服务器又会从MySQL配置文件中读取变量的默认值。 MySQL 8.0版本新增了<code class="language-plaintext highlighter-rouge"> SET PERSIST </code>命令。例如，设置服务器的最大连接数为1000：</p><p><code class="language-plaintext highlighter-rouge">SET PERSIST global max_connections = 1000;</code></p><p>​ MySQL会将该命令的配置保存到数据目录下的 <code class="language-plaintext highlighter-rouge">mysqld-auto.cnf </code>文件中，下次启动时会读取该文件，用 其中的配置来覆盖默认的配置文件。</p><p>举例： 查看全局变量max_connections的值，结果如下：</p><pre><code class="language-mysql">mysql&gt; show variables like '%max_connections%';
+------------------------+-------+
| Variable_name 		| Value |
+------------------------+-------+
| max_connections 		| 151   |
| mysqlx_max_connections | 100   |
+------------------------+-------+
2 rows in set, 1 warning (0.00 sec)
</code></pre><p>设置全局变量max_connections的值：</p><pre><code class="language-mysql">mysql&gt; set persist max_connections=1000;
Query OK, 0 rows affected (0.00 sec)
</code></pre><p>重启MySQL服务器 ，再次查询max_connections的值：</p><pre><code class="language-mysql">mysql&gt; show variables like '%max_connections%';
+------------------------+-------+
| Variable_name | Value |
+------------------------+-------+
| max_connections | 1000 |
| mysqlx_max_connections | 100 |
+------------------------+-------+
2 rows in set, 1 warning (0.00 sec)
</code></pre><h2 id="5课后练习">5.课后练习<a href="#5课后练习" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>1.创建函数get_count()，返回公司的员工个数</p><pre><code class="language-mysql">DELIMITER $
CREATE FUNCTION get_count()
RETURNS INT
BEGIN 
	# 声明变量
	DECLARE emp_count INT;
	# 赋值
	SELECT COUNT(*) INTO emp_count FROM employees
	RETURN emp_count;
END $
DELIMITER ;
</code></pre><p>调用</p><pre><code class="language-mysql">SELECT get_count();
</code></pre><p>2.创建函数ename_salary()，根据员工姓名，返回它的工资</p><pre><code class="language-MYSQL">DELIMITER $
CREATE FUNCTION ename_salary(emp_name VARCHAR(15))
RETURN DOUBLE
BEGIN 
	# 声明变量，定义一个会话用户变量
	SET @sal = 0;
	# 赋值
	SELECT salary INTO @sal FROM employees WHERE last_name = emp_name
	RETURN  @sal;
END $
DELIMITER ;
</code></pre><p>调用</p><pre><code class="language-mysql">SELECT ename_salary('Abel')
</code></pre><p>3.创建函数dept_sal()，根据部门名，返回该部门的平均工资</p><pre><code class="language-mysql">DELIMITER //
CREATE FUNCTION dept_sal(dept_name VARCHAR(15))
RETURNS DOUBLE
BEGIN
	DECLARE avg_sal DOUBLE;
	SELECT AVG(salary) INTO avg_sal
           FROM employees e JOIN departments d
           ON e.department_id = d.department_id
           WHERE d.department_name = dept_name;
    RETURN avg_sal;
 END // 
 DELIMITER ;
</code></pre><p>调用</p><pre><code class="language-mysql">SELECT dept_sal('Marketing');
</code></pre><p>4.创建函数add_float()，实现传入两个float，返回二者之和</p><pre><code class="language-mysql">DELIMITER //
CREATE FUNCTION add_float(value1 FLOAT,value2 FLOAT)
RETURNS FLOAT
BEGIN
	DECLARE sun_val FLOAT;
	SET sum_val =  value1 + value2;
	RETURN sum_val;
END // 
DELIMITER ;
</code></pre><p>调用</p><pre><code class="language-mysql">SET @V1 :=12.2;
SET @V2 = 2.3;
SELECT add_float(@v1,@v2);
</code></pre><p>5.创建函数<code class="language-plaintext highlighter-rouge">test_if_case()</code>，实现传入成绩，如果成绩&gt;90，返回A；如果成绩大于80，返回B；如果成绩大于60，返回C，否则返回D。要求分别使用if结构和case结构实现。</p><pre><code class="language-mysql">DELIMITER $
CREATE FUNCTION test_if_case1(score DOUBLE)
RETURNS CHAR
BEGIN 
	DECLARE score_level CHAR;
	IF score &gt;90
		THEN SET score_level = 'A';
	IF score &gt;80
		THEN SET score_level = 'B';
    IF score &gt;60
		THEN SET score_level = 'C';
	ELSE 
		SET score_level = 'D';
	END IF;
	RETURNS score_level;
END $
DELIMITER ;
</code></pre><p>调用</p><pre><code class="language-mysql">SELECT test_if_case1(56);
</code></pre><p>6.游标的使用。创建存储过程update_salary()</p><p>参数1为IN的INT类型变量dept_id，表示部门id；</p><p>参数2为IN的INT类型变量change_sal_count，表示要调整薪资的员工个数。</p><p>查询指定id部门的员工，按照salary升序排列，根据hire_date的情况，调整前change_sal_count个员工的薪资，详情如下。</p><pre><code class="language-mysql">DELIMITER $
CREATE PROCEDURE update_salary(IN dept_id INT,IN change_sal_count INT)
BEGIN
	# 声明变量
	DECLARE emp_id INT;
	DECLARE emp_hire_date DATE;
	DECLARE init_count INT DEFAULT 1; 
	DECLARE add_sal_rate DOUBLE;
	# 声明游标
	DECLARE emp_cursor cursor FOR select employee_id hire_date FROM employees
	WHERE department_id = dept_id ORDER BY salary ASC;
	# 打开游标
	OPEN emp_cursor;
	WHILE init_count &lt;= change_sal_count DO
        # 使用游标
        FETCH emp_cursor INTO emp_id,emp_hire_date;
        IF(YEAR(emp_hire_date)&lt;1995)
        	THEN SET add_sal_rate=1.2;
        ELSEIF(YEAR(emp_hire_date)&lt;1998)
        	THEN SET add_sal_rate=1.15;
        ELSEIF(YEAR(emp_hire_date)&lt;2001)
        	THEN SET add_sal_rate=1.10;	
        ELSE
        	SET add_sal_rate=1.05;	
        END IF ;
        # 涨薪操作
        UPDATE employees SET salary * add_sal_rate
        WHERE employee_id =emp_id;
        # 迭代条件的更新
        SET init_count = init_count+1;
    END WHILE;
    CLOSE emp_cursor;
END $
DELIMITER ;
</code></pre><p>调用</p><pre><code class="language-MYSQL">SELECT update_salary(50,2)
</code></pre></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/'>数据库</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/mysql/" class="post-tag no-text-decoration" >MySQL</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=MySQL变量、流程控制和游标 - Technical Blogs&url=https://carmanzheng.github.io//posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E5%8F%98%E9%87%8F-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%92%8C%E6%B8%B8%E6%A0%87/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=MySQL变量、流程控制和游标 - Technical Blogs&u=https://carmanzheng.github.io//posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E5%8F%98%E9%87%8F-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%92%8C%E6%B8%B8%E6%A0%87/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=MySQL变量、流程控制和游标 - Technical Blogs&url=https://carmanzheng.github.io//posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E5%8F%98%E9%87%8F-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%92%8C%E6%B8%B8%E6%A0%87/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Kubernetes%E6%A6%82%E8%BF%B0/">Kubernetes</a><li><a href="/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">MySQL存储引擎</a><li><a href="/posts/Linux%E5%9F%BA%E7%A1%80/">Linux基础</a><li><a href="/posts/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Python基操-多进程与多线程</a><li><a href="/posts/%E5%89%8D%E7%AB%AF-Vue%E8%B7%AF%E7%94%B1%E4%B8%8EVuex/">前端 Vue路由与vuex</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/mysql/">MySQL</a> <a class="post-tag" href="/tags/python%E5%9F%BA%E6%93%8D/">Python基操</a> <a class="post-tag" href="/tags/%E5%89%8D%E7%AB%AFjs/">前端JS</a> <a class="post-tag" href="/tags/%E5%89%8D%E7%AB%AFvue/">前端Vue</a> <a class="post-tag" href="/tags/%E5%89%8D%E7%AB%AFcss/">前端CSS</a> <a class="post-tag" href="/tags/devops/">DevOps</a> <a class="post-tag" href="/tags/linux%E5%9F%BA%E7%A1%80/">Linux基础</a> <a class="post-tag" href="/tags/%E5%89%8D%E7%AB%AFhtml/">前端HTML</a> <a class="post-tag" href="/tags/github/">Github</a> <a class="post-tag" href="/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91/">客户端开发</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><div class="card-body"> <em class="timeago small" date="2021-07-06 00:00:00 +0800" >2021-07-06</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>MySQL存储引擎</h3><div class="text-muted small"><p> 1.为什么使用索引 假如给数据使用 二叉树 这样的数据结构进行存储，如下图所示 2. 索引及其优缺点 2.1 索引概述 MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。 索引的本质：索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。 这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 ...</p></div></div></a></div><div class="card"> <a href="/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E5%9F%BA%E7%A1%80/"><div class="card-body"> <em class="timeago small" date="2021-06-01 00:00:00 +0800" >2021-06-01</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>MySQL基础</h3><div class="text-muted small"><p> 1. 数据库功能 ​ 持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多 通过各种关系数据库来完成。 ​ 持久化的主要作用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数 据文件中。 2.数据库与数据库管理系统 2....</p></div></div></a></div><div class="card"> <a href="/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E5%AE%89%E8%A3%85/"><div class="card-body"> <em class="timeago small" date="2021-06-02 00:00:00 +0800" >2021-06-02</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>MySQL安装</h3><div class="text-muted small"><p> 1. 下载软件 官网：https://www.mysql.com 下载地址：https://dev.mysql.com/downloads/windows/installer/8.0.html MySQL Community Server 社区版本，开源免费，自由下载，但不提供官方技术支持，适用于 大多数普通用户。 MySQL Enterprise Edition 企业版本，...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0/" class="btn btn-outline-primary" prompt="上一篇"><p>MySQL存储过程与存储函数</p></a> <a href="/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E8%A7%A6%E5%8F%91%E5%99%A8/" class="btn btn-outline-primary" prompt="下一篇"><p>MySQL触发器</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/carmanzheng">carmanzheng</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/mysql/">MySQL</a> <a class="post-tag" href="/tags/python%E5%9F%BA%E6%93%8D/">Python基操</a> <a class="post-tag" href="/tags/%E5%89%8D%E7%AB%AFjs/">前端JS</a> <a class="post-tag" href="/tags/%E5%89%8D%E7%AB%AFvue/">前端Vue</a> <a class="post-tag" href="/tags/%E5%89%8D%E7%AB%AFcss/">前端CSS</a> <a class="post-tag" href="/tags/devops/">DevOps</a> <a class="post-tag" href="/tags/linux%E5%9F%BA%E7%A1%80/">Linux基础</a> <a class="post-tag" href="/tags/%E5%89%8D%E7%AB%AFhtml/">前端HTML</a> <a class="post-tag" href="/tags/github/">Github</a> <a class="post-tag" href="/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91/">客户端开发</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
