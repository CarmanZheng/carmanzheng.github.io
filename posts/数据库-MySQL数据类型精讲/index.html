<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="天前"><meta name="hour-prompt" content="小时前"><meta name="minute-prompt" content="分钟前"><meta name="justnow-prompt" content="刚刚"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="MySQL数据类型精讲" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="1.MySQL中的数据类型" /><meta property="og:description" content="1.MySQL中的数据类型" /><link rel="canonical" href="https://carmanzheng.github.io//posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2/" /><meta property="og:url" content="https://carmanzheng.github.io//posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2/" /><meta property="og:site_name" content="Technical Blogs" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-06-12T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="MySQL数据类型精讲" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"1.MySQL中的数据类型","headline":"MySQL数据类型精讲","dateModified":"2022-05-26T20:50:58+08:00","datePublished":"2021-06-12T00:00:00+08:00","url":"https://carmanzheng.github.io//posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2/","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://carmanzheng.github.io//posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2/"},"@context":"https://schema.org"}</script><title>MySQL数据类型精讲 | Technical Blogs</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Technical Blogs"><meta name="application-name" content="Technical Blogs"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="zh-CN"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/favicons/android-chrome-192x192.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Technical Blogs</a></div><div class="site-subtitle font-italic">Learning by Doing, Sharing for more!</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/Carmanzheng" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['zhengkan1993','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>MySQL数据类型精讲</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>MySQL数据类型精讲</h1><div class="post-meta text-muted"><div> 作者 <em> <a href="https://github.com/carmanzheng">carmanzheng</a> </em></div><div class="d-flex"><div> <span> 发表于 <em class="timeago" date="2021-06-12 00:00:00 +0800" data-toggle="tooltip" data-placement="bottom" title="2021-06-12, 00:00 +0800" >2021-06-12</em> </span> <span> 更新于 <em class="timeago" date="2022-05-26 20:50:58 +0800 " data-toggle="tooltip" data-placement="bottom" title="2022-05-26, 20:50 +0800" >05-26</em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="11094 字"> <em>61 分钟</em>阅读</span></div></div></div><div class="post-content"><h2 id="1mysql中的数据类型">1.MySQL中的数据类型<a href="#1mysql中的数据类型" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><div class="table-wrapper"><table><thead><tr><th>类型<th>类型举例<tbody><tr><td>整数类型<td>TINYINT、SMALLINT、MEDIUMINT、<em>INT(或INTEGER)</em>、BIGINT<tr><td>浮点类型<td>FLOAT、DOUBLE<tr><td>定点数类型<td><em>DECIMAL</em><tr><td>位类型<td>BIT<tr><td>日期时间类型<td>YEAR、TIME、DATE、DATETIME、TIMESTAMP<tr><td>文本字符串类型<td>CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT<tr><td>枚举类型<td>ENUM<tr><td>集合类型<td>SET<tr><td>二进制字符串类型<td>BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB<tr><td>JSON类型<td>JSON对象、JSON数组<tr><td>空间数据类型<td>单值类型：GEOMETRY、POINT、LINESTRING、POLYGON；<br />集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、 GEOMETRYCOLLECTION</table></div><p>常见数据类型的属性，如下：</p><div class="table-wrapper"><table><thead><tr><th>MySQL关键字<th>含义<tbody><tr><td>NULL<td>数据列可包含NULL值<tr><td>NOT NULL<td>数据列不允许包含NULL值<tr><td>DEFAULT<td>默认值<tr><td>PRIMARY KEY<td>主键<tr><td>AUTO_INCREMENT<td>自动递增，适用于整数类型<tr><td>UNSIGNED<td>无符号<tr><td>CHARACTER SET name<td>指定一个字符集 ，如<code class="language-plaintext highlighter-rouge">utf8</code></table></div><h2 id="2-整数类型">2. 整数类型<a href="#2-整数类型" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="21-类型介绍">2.1 类型介绍<a href="#21-类型介绍" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>​ 整数类型一共有 5 种，包括 TINYINT、SMALLINT、MEDIUMINT、INT（INTEGER）和 BIGINT。 它们的区别如下表所示：</p><div class="table-wrapper"><table><thead><tr><th>整数类型<th>字节<th>有符号数取值范围<th>无符号数取值范围<tbody><tr><td>TINYINT<td>1<td>-128~127<td>0~255<tr><td>SMALLINT<td>2<td>-32768~32767<td>0~65535<tr><td>MEDIUMINT<td>3<td>-8388608~8388607<td>0~16777215<tr><td>INT、INTEGER<td>4<td>-2147483648~2147483647<td>0~4294967295<tr><td>BIGINT<td>8<td>-9223372036854775808~9223372036854775807<td>0~18446744073709551615</table></div><h3 id="22-可选属性">2.2 可选属性<a href="#22-可选属性" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>整数类型的可选属性有三个：</p><h4 id="221-m">2.2.1 M<a href="#221-m" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>​ <code class="language-plaintext highlighter-rouge">M </code>: 表示显示宽度，M的取值范围是(0, 255)。例如，int(5)：当数据宽度小于5位的时候在数字前面需要用 字符填满宽度。该项功能需要配合<code class="language-plaintext highlighter-rouge">ZEROFILL</code>使用，表示用“0”填满宽度，否则指定显示宽度无效。 如果设置了显示宽度，那么插入的数据宽度超过显示宽度限制，会不会截断或插入失败？ 答案：不会对插入的数据有任何影响，还是按照类型的实际宽度进行保存，即 <code class="language-plaintext highlighter-rouge">显示宽度与类型可以存储的 值范围无关 </code>。</p><p>​ <strong>从MySQL 8.0.17开始，整数数据类型不推荐使用显示宽度属性</strong>。 整型数据类型可以在定义表结构时指定所需要的显示宽度，如果不指定，则系统为每一种类型指定默认 的宽度值。</p><p>举例：</p><pre><code class="language-mysql">CREATE TABLE test_int1 ( x TINYINT, y SMALLINT, z MEDIUMINT, m INT, n BIGINT );
</code></pre><p>查看表结构 （MySQL8中不再显式范围）</p><pre><code class="language-mysql">mysql&gt; desc test_int1;
+-------+-----------+------+-----+---------+-------+
| Field | Type      | Null | Key | Default | Extra |
+-------+-----------+------+-----+---------+-------+
| x     | tinyint   | YES  |     | NULL    |       |
| y     | smallint  | YES  |     | NULL    |       |
| z     | mediumint | YES  |     | NULL    |       |
| m     | int       | YES  |     | NULL    |       |
| n     | bigint    | YES  |     | NULL    |       |
+-------+-----------+------+-----+---------+-------+
5 rows in set
</code></pre><p>​ TINYINT有符号数和无符号数的取值范围分别为<code class="language-plaintext highlighter-rouge">-128~127和0~255</code>，由于负号占了一个数字位，因此 TINYINT默认的显示宽度为<code class="language-plaintext highlighter-rouge">4</code>。同理，其他整数类型的默认显示宽度与其有符号数的最小值的宽度相同。</p><h4 id="222-unsigned">2.2.2 UNSIGNED<a href="#222-unsigned" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>​ <code class="language-plaintext highlighter-rouge">UNSIGNED</code> : 无符号类型（非负），所有的整数类型都有一个可选的属性UNSIGNED（无符号属性），无 符号整数类型的最小取值为0。所以，如果需要在MySQL数据库中保存非负整数值时，可以将整数类型设 置为无符号类型。</p><p>​ int类型默认显示宽度为int(11)，无符号int类型默认显示宽度为int(10)。</p><pre><code class="language-mysql">CREATE TABLE test_int3(
    f1 INT UNSIGNED
);

mysql&gt; desc test_int3;
+-------+--------------+------+-----+---------+-------+
| Field | Type         | Null | Key | Default | Extra |
+-------+--------------+------+-----+---------+-------+
| f1    | int unsigned | YES  |     | NULL    |       |
+-------+--------------+------+-----+---------+-------+
1 row in set
</code></pre><h4 id="223-zerofill">2.2.3 ZEROFILL<a href="#223-zerofill" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>​ <code class="language-plaintext highlighter-rouge">ZEROFILL</code> : 0填充,（如果某列是ZEROFILL，那么MySQL会自动为当前列添加UNSIGNED属性），如果指 定了ZEROFILL只是表示不够M位时，用0在左边填充，如果超过M位，只要不超过数据存储范围即可。</p><p>​ 原来，在 int(M) 中，M 的值跟 int(M) 所占多少存储空间并无任何关系。 int(3)、int(4)、int(8) 在磁盘上都 是占用 4 bytes 的存储空间。<code class="language-plaintext highlighter-rouge">也就是说，int(M)，必须和UNSIGNED ZEROFILL一起使用才有意义</code>。如果整 数值超过M位，就按照实际位数存储。只是无须再用字符 0 进行填充。</p><h3 id="23-适用场景">2.3 适用场景<a href="#23-适用场景" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>TINYINT ：一般用于枚举数据，比如系统设定取值范围很小且固定的场景。</p><p>SMALLINT ：可以用于较小范围的统计数据，比如统计工厂的固定资产库存数量等。</p><p>MEDIUMINT ：用于较大整数的计算，比如车站每日的客流量等。</p><p>INT、INTEGER ：取值范围足够大，一般情况下不用考虑超限问题，用得最多。比如商品编号。</p><p>BIGINT ：只有当你处理特别巨大的整数时才会用到。比如双十一的交易量、大型门户网站点击量、证 券公司衍生产品持仓等。</p><h3 id="24-如何选择">2.4 如何选择？<a href="#24-如何选择" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>​ 在评估用哪种整数类型的时候，你需要考虑 <code class="language-plaintext highlighter-rouge">存储空间</code> 和 <code class="language-plaintext highlighter-rouge">可靠性</code> 的平衡问题：一方面，用占用字节数少 的整数类型可以节省存储空间；另一方面，要是为了节省存储空间， 使用的整数类型取值范围太小，一 旦遇到超出取值范围的情况，就可能引起 系统错误 ，影响可靠性。</p><p>​ 举个例子，商品编号采用的数据类型是 INT。原因就在于，客户门店中流通的商品种类较多，而且，每天都有旧商品下架，新商品上架，这样不断迭代，日积月累。 如果使用 SMALLINT 类型，虽然占用字节数比 INT 类型的整数少，但是却不能保证数据不会超出范围 65535。相反，使用 INT，就能确保有足够大的取值范围，不用担心数据超出范围影响可靠性的问题。 你要注意的是，在实际工作中，<em>系统故障产生的成本远远超过增加几个字段存储空间所产生的成本</em>。因 此，我建议你首先确保数据不会超过取值范围，在这个前提之下，再去考虑如何节省存储空间。</p><h2 id="3-浮点类型">3. 浮点类型<a href="#3-浮点类型" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="31-类型介绍">3.1 类型介绍<a href="#31-类型介绍" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>​ 浮点数和定点数类型的特点是可以处理小数 ，你可以把整数看成小数的一个特例。因此，浮点数和定点 数的使用场景，比整数大多了。 MySQL支持的浮点数类型，分别是 FLOAT、DOUBLE、REAL。</p><ul><li>FLOAT 表示单精度浮点数；<li>DOUBLE 表示双精度浮点数；</ul><div class="table-wrapper"><table><thead><tr><th>类型<th>有符号数范围<th>无符号数取值范围<th>占用字节数<tbody><tr><td>FLOAT<td>(-3.40E+38，-1.17E-38)，0，(1.17E-38，3.40E+38)<td>0，(1.17E-38，3.40E+38)<td>4<tr><td>DOUBLE<td>(-1.79E+308，-2.25E-308)，0，(2.25E-308，1.79E+308)<td>0，(2.25E-308，1.79E+308)<td>8</table></div><p>​ REAL默认就是 DOUBLE。如果你把 SQL 模式设定为启用“ REAL_AS_FLOAT ”，那么，MySQL 就认为 REAL 是 FLOAT。如果要启用“REAL_AS_FLOAT”，可以通过以下 SQL 语句实现：</p><pre><code class="language-mysql">SET sql_mode = “REAL_AS_FLOAT”;
</code></pre><p><strong>问题1：FLOAT 和 DOUBLE 这两种数据类型的区别是啥呢？</strong></p><p>​ FLOAT 占用字节数少，取值范围小；DOUBLE 占用字节数多，取值范围也大。</p><p><strong>问题2：为什么浮点数类型的无符号数取值范围，只相当于有符号数取值范围的一半，也就是只相当于 有符号数取值范围大于等于零的部分呢？</strong></p><p>​ MySQL 存储浮点数的格式为： 符号(S) 、 尾数(M) 和 阶码(E) 。因此，无论有没有符号，MySQL 的浮 点数都会存储表示符号的部分。因此， 所谓的无符号数取值范围，其实就是有符号数取值范围大于等于 零的部分。</p><h3 id="32-数据精度说明">3.2 数据精度说明<a href="#32-数据精度说明" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>对于浮点类型，在MySQL中单精度值使用 4 个字节，双精度值使用 8 个字节。</p><ul><li>MySQL允许使用 非标准语法 （其他数据库未必支持，因此如果涉及到数据迁移，则最好不要这么 用）： FLOAT(M,D) 或 DOUBLE(M,D) 。这里，M称为 精度 ，D称为标度 。(M,D)中 M=整数位+小数 位，D=小数位。 D&lt;=M&lt;=255，0&lt;=D&lt;=30。 例如，定义为FLOAT(5,2)的一个列可以显示为-999.99-999.99。如果超过这个范围会报错。<li>FLOAT和DOUBLE类型在不指定(M,D)时，默认会按照实际的精度（由实际的硬件和操作系统决定） 来显示。<li>说明：浮点类型，也可以加 UNSIGNED ，但是不会改变数据范围，例如：<code class="language-plaintext highlighter-rouge">FLOAT(3,2) UNSIGNED仍然 只能表示0-9.99的范围</code>。<li>不管是否显式设置了精度(M,D)，这里MySQL的处理方案如下：<ul><li>如果存储时，整数部分超出了范围，MySQL就会报错，不允许存这样的值 如果存储时，小数点部分若超出范围，就分以下情况：<ul><li>若四舍五入后，整数部分没有超出范围，则只警告，但能成功操作并四舍五入删除多余 的小数位后保存。例如在FLOAT(5,2)列内插入999.009，近似结果是999.01。<li>若四舍五入后，整数部分超出范围，则MySQL报错，并拒绝处理。如FLOAT(5,2)列内插入 999.995和-999.995都会报错。</ul></ul><li><strong>从MySQL 8.0.17开始，FLOAT(M,D) 和DOUBLE(M,D)用法在官方文档中已经明确不推荐使用，将来可能被移除</strong>。另外，关于浮点型FLOAT和DOUBLE的UNSIGNED也不推荐使用了，将来也可能被移除。</ul><pre><code class="language-mysql">CREATE TABLE test_double1(
f1 FLOAT,
f2 FLOAT(5,2),
f3 DOUBLE,
f4 DOUBLE(5,2)
);
DESC test_double1;
INSERT INTO test_double1
VALUES(123.456,123.456,123.4567,123.45);
#Out of range value for column 'f2' at row 1
INSERT INTO test_double1
VALUES(123.456,1234.456,123.4567,123.45);
SELECT * FROM test_double1;
</code></pre><h3 id="33-精度误差说明">3.3 精度误差说明<a href="#33-精度误差说明" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>​ 浮点数类型有个缺陷，就是不精准。下面我来重点解释一下为什么 MySQL 的浮点数不够精准。比如，我 们设计一个表，有f1这个字段，插入值分别为0.47,0.44,0.19，我们期待的运行结果是：0.47 + 0.44 + 0.19 = 1.1。而使用sum之后查询：</p><pre><code class="language-mysql">CREATE TABLE test_double2(
    f1 DOUBLE
);
INSERT INTO test_double2
VALUES(0.47),(0.44),(0.19);

SELECT SUM(f1) FROM test_double2;
+--------------------+
| SUM(f1)            |
+--------------------+
| 1.0999999999999999 |
+--------------------+
1 row in set
</code></pre><pre><code class="language-mysql">SELECT SUM(f1) = 1.1,1.1 = 1.1 FROM test_double2;
+---------------+-----------+
| SUM(f1) = 1.1 | 1.1 = 1.1 |
+---------------+-----------+
|             0 |         1 |
+---------------+-----------+
1 row in set
</code></pre><p>​ 查询结果是 1.0999999999999999。看到了吗？虽然误差很小，但确实有误差。 你也可以尝试把数据类型 改成 FLOAT，然后运行求和查询，得到的是， 1.0999999940395355。显然，误差更大了。</p><p>​ 那么，为什么会存在这样的误差呢？问题还是出在 MySQL 对浮点类型数据的存储方式上。</p><p>​ MySQL 用 4 个字节存储 FLOAT 类型数据，用 8 个字节来存储 DOUBLE 类型数据。无论哪个，都是采用二进制的方式来进行存储的。比如 9.625，用二进制来表达，就是 1001.101，或者表达成 1.001101×2^3。如果尾数不是 0 或 5（比如 9.624），你就无法用一个二进制数来精确表达。进而，就只好在取值允许的范 围内进行四舍五入。</p><p>​ 在编程中，如果用到浮点数，要特别注意误差问题，<strong>因为浮点数是不准确的，所以我们要避免使用“=”来 判断两个数是否相等</strong>。同时，在一些对精确度要求较高的项目中，千万不要使用浮点数，不然会导致结 果错误，甚至是造成不可挽回的损失。那么，MySQL 有没有精准的数据类型呢？当然有，这就是定点数类型： <code class="language-plaintext highlighter-rouge">DECIMAL</code> 。</p><h2 id="4-定点数类型">4. 定点数类型<a href="#4-定点数类型" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="41-类型介绍">4.1 类型介绍<a href="#41-类型介绍" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>​ MySQL中的定点数类型只有 DECIMAL 一种类型。</p><div class="table-wrapper"><table><thead><tr><th>数据类型<th>字节数<th>含义<tbody><tr><td>DECIMAL(M,D),DEC,NUMERIC<td>M+2字节<td>有效范围由M和D决定</table></div><p>​ 使用 DECIMAL(M,D) 的方式表示高精度小数。其中，M被称为精度，D被称为标度。0&lt;=M&lt;=65， 0&lt;=D&lt;=30，D被称为标度。0&lt;=M&lt;=65，0&lt;=D&lt;=30，D&lt;M。</p><p>例如，定义DECIMAL（5,2）的类型，表示该列取值范围是-999.99~999.99。</p><p>​ <strong>DECIMAL(M,D)的最大取值范围与DOUBLE类型一样</strong>，但是有效的数据范围是由M和D决定的。 DECIMAL 的存储空间并不是固定的，由精度值M决定，总共占用的存储空间为M+2个字节。也就是 说，在一些对精度要求不高的场景下，比起占用同样字节长度的定点数，浮点数表达的数值范围可 以更大一些。</p><p>​ 定点数在MySQL内部是以 字符串 的形式进行存储，这就决定了它一定是精准的。</p><p>​ 当DECIMAL类型不指定精度和标度时，其默认为DECIMAL(10,0)。当数据的精度超出了定点数类型的 精度范围时，则MySQL同样会进行四舍五入处理。</p><p><strong>浮点数 vs 定点数</strong></p><p>​ 浮点数相对于定点数的优点是在长度一定的情况下，浮点类型取值范围大，但是不精准，适用于需要取值范围大，又可以容忍微小误差的科学计算场景（比如计算化学、分子建模、流体动 力学等） 定点数类型取值范围相对小，但是精准，没有误差，适合于对精度要求极高的场景 （比如涉 及金额计算的场景）</p><pre><code class="language-mysql">CREATE TABLE test_decimal1(
    f1 DECIMAL,
    f2 DECIMAL(5,2)
);
DESC test_decimal1;
INSERT INTO test_decimal1(f1,f2)
VALUES(123.123,123.456);
#Out of range value for column 'f2' at row 1
INSERT INTO test_decimal1(f2)
VALUES(1234.34);

mysql&gt; SELECT * FROM test_decimal1;
+-----+--------+
| f1  | f2     |
+-----+--------+
| 123 | 123.46 |
+-----+--------+
1 row in set
</code></pre><p>举例:</p><p>​ 我们运行下面的语句，把test_double2表中字段“f1”的数据类型修改为 DECIMAL(5,2)：</p><pre><code class="language-mysql">ALTER TABLE test_double2
MODIFY f1 DECIMAL(5,2);
</code></pre><p>然后，我们再一次运行求和语句：</p><pre><code class="language-mysql">mysql&gt; SELECT SUM(f1) FROM test_double2;
+---------+
| SUM(f1) |
+---------+
| 1.10    |
+---------+
1 row in set (0.00 sec)
</code></pre><pre><code class="language-mysql">mysql&gt; SELECT SUM(f1) = 1.1 FROM test_double2;
+---------------+
| SUM(f1) = 1.1 |
+---------------+
| 1 		   |
+---------------+
1 row in set (0.00 sec)
</code></pre><h3 id="42-开发中经验">4.2 开发中经验<a href="#42-开发中经验" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><pre><code class="language-mysql">“由于 DECIMAL 数据类型的精准性，在我们的项目中，除了极少数（比如商品编号）用到整数类型外，其他的数值都用的是 DECIMAL，原因就是这个项目所处的零售行业，要求精准，一分钱也不能差。 ”
																												——来自某项目经理
</code></pre><h2 id="5-位类型bit">5. 位类型：BIT<a href="#5-位类型bit" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>BIT类型中存储的是二进制值，类似010110。</p><div class="table-wrapper"><table><thead><tr><th>二进制字符串类型<th>长度<th>长度范围<th>占用空间<tbody><tr><td>BIT(M)<td>M<td>1 &lt;= M &lt;= 64<td>约为(M + 7)/8个字节</table></div><p>BIT类型，如果没有指定(M)，默认是1位。这个1位，表示只能存1位的二进制值。这里(M)是表示二进制的 位数，位数最小值为1，最大值为64。</p><pre><code class="language-MYSQL">CREATE TABLE test_bit1(
    f1 BIT,
    f2 BIT(5),
    f3 BIT(64)
);
INSERT INTO test_bit1(f1)
VALUES(1);
#Data too long for column 'f1' at row 1
INSERT INTO test_bit1(f1)
VALUES(2);
INSERT INTO test_bit1(f2)
VALUES(23);
</code></pre><p>注意：在向BIT类型的字段中插入数据时，一定要确保插入的数据在BIT类型支持的范围内。</p><p>使用SELECT命令查询位字段时，可以用 BIN() 或 HEX() 函数进行读取。</p><pre><code class="language-mysql">mysql&gt; SELECT * FROM test_bit1;
+------------+------------+------------+
| f1 		|  f2 		 | f3 		 |
+------------+------------+------------+
| 0x01 		 | NULL 	  | NULL      |
| NULL       | 0x17        | NULL      |
+------------+------------+------------+
2 rows in set (0.00 sec)

</code></pre><pre><code class="language-mysql">mysql&gt; SELECT BIN(f2),HEX(f2) FROM test_bit1;
+---------+---------+
| BIN(f2) | HEX(f2) |
+---------+---------+
| NULL    | NULL    |
| 10111   | 17      |
+---------+---------+
2 rows in set (0.00 sec)
</code></pre><pre><code class="language-mysql">mysql&gt; SELECT f2 + 0 FROM test_bit1;
+--------+
| f2 + 0 |
+--------+
| NULL   |
| 23     |
+--------+
2 rows in set (0.00 sec)
</code></pre><p>可以看到，使用b+0查询数据时，可以直接查询出存储的十进制数据的值。</p><h2 id="6-日期与时间类型">6. 日期与时间类型<a href="#6-日期与时间类型" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>​ 日期与时间是重要的信息，在我们的系统中，几乎所有的数据表都用得到。原因是客户需要知道数据的 时间标签，从而进行数据查询、统计和处理。</p><p>​ MySQL有多种表示日期和时间的数据类型，不同的版本可能有所差异，MySQL8.0版本支持的日期和时间 类型主要有：YEAR类型、TIME类型、DATE类型、DATETIME类型和TIMESTAMP类型。</p><pre><code class="language-mysql">YEAR 类型通常用来表示年
DATE 类型通常用来表示年、月、日
TIME 类型通常用来表示时、分、秒
DATETIME 类型通常用来表示年、月、日、时、分、秒
TIMESTAMP 类型通常用来表示带时区的年、月、日、时、分、秒
</code></pre><div class="table-wrapper"><table><thead><tr><th>类型<th>名称<th>字节<th>日期格式<th>最小值<th>最大值<tbody><tr><td>YEAR<td>年<td>1<td>YYYY或YY<td>1901<td>2155<tr><td>TIME<td>时间<td>3<td>HH:MM:SS<td>-838:59:59<td>838:59:59<tr><td>DATE<td>日期<td>3<td>YYYY-MM-DD<td>1000-01-01<td>9999-12-03<tr><td>DATETIME<td>日期 时间<td>8<td>YYYY-MM-DD HH:MM:SS<td>1000-01-01 00:00:00<td>9999-12-31 23:59:59<tr><td>TIMESTAMP<td>日期 时间<td>4<td>YYYY-MM-DD HH:MM:SS<td>1970-01-01 00:00:00 UTC<td>2038-01-19 03:14:07UTC</table></div><p>​ 可以看到，不同数据类型表示的时间内容不同、取值范围不同，而且占用的字节数也不一样，你要根据 实际需要灵活选取。</p><p><strong>为什么时间类型 TIME 的取值范围不是 -23:59:59～23:59:59 呢？</strong></p><p>​ 原因是 MySQL 设计的 TIME 类型，不光表 示一天之内的时间，而且可以用来表示一个时间间隔，这个时间间隔可以超过 24 小时。</p><h3 id="61-year类型">6.1 YEAR类型<a href="#61-year类型" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>​ YEAR类型用来表示年份，在所有的日期时间类型中所占用的存储空间最小，只需要 1个字节 的存储空间。</p><ul><li>在MySQL中，YEAR有以下几种存储格式： 以4位字符串或数字格式表示YEAR类型，其格式为YYYY，最小值为1901，最大值为2155。<li>以2位字符串格式表示YEAR类型，最小值为00，最大值为99。<ul><li>当取值为01到69时，表示2001到2069；<li>当取值为70到99时，表示1970到1999；<li>当取值整数的0或00添加的话，那么是0000年；<li>当取值是日期/字符串的’0’添加的话，是2000年。</ul></ul><p><strong>从MySQL5.5.27开始，2位格式的YEAR已经不推荐使用</strong>。YEAR默认格式就是“YYYY”，没必要写成YEAR(4)， 从MySQL 8.0.19开始，不推荐使用指定显示宽度的YEAR(4)数据类型。</p><pre><code class="language-mysql">CREATE TABLE test_year(
    f1 YEAR,
    f2 YEAR(4)
);

mysql&gt; DESC test_year;
+-------+---------+------+-----+---------+-------+
| Field | Type    | Null | Key | Default | Extra |
+-------+---------+------+-----+---------+-------+
| f1    | year(4) | YES  |     | NULL    |       |
| f2    | year(4) | YES  |     | NULL    |       |
+-------+---------+------+-----+---------+-------+
2 rows in set (0.00 sec)

INSERT INTO test_year
VALUES('2020','2021');

mysql&gt; SELECT * FROM test_year;
+------+------+
| f1   | f2   |
+------+------+
| 2020 | 2021 |
+------+------+
1 rows in set (0.00 sec)

</code></pre><pre><code class="language-mysql">INSERT INTO test_year
VALUES('45','71');
INSERT INTO test_year
VALUES(0,'0');

mysql&gt; SELECT * FROM test_year;
+------+------+
| f1   | f2   |
+------+------+
| 2020 | 2021 |
| 2045 | 1971 |
| 0000 | 2000 |
+------+------+
3 rows in set (0.00 sec)

</code></pre><h3 id="62-date类型">6.2 DATE类型<a href="#62-date类型" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>​ DATE类型表示日期，没有时间部分，格式为 YYYY-MM-DD ，其中，YYYY表示年份，MM表示月份，DD表示 日期。需要 3个字节 的存储空间。在向DATE类型的字段插入数据时，同样需要满足一定的格式条件。</p><ul><li>以 YYYY-MM-DD 格式或者 YYYYMMDD 格式表示的字符串日期，其最小取值为1000-01-01，最大取值为 9999-12-03。YYYYMMDD格式会被转化为YYYY-MM-DD格式。<li>以 YY-MM-DD 格式或者 YYMMDD 格式表示的字符串日期，此格式中，年份为两位数值或字符串满足 YEAR类型的格式条件为：当年份取值为00到69时，会被转化为2000到2069；当年份取值为70到99 时，会被转化为1970到1999。<li>使用 CURRENT_DATE() 或者 NOW() 函数，会插入当前系统的日期。</ul><p>举例： 创建数据表，表中只包含一个DATE类型的字段f1</p><pre><code class="language-mysql">CREATE TABLE test_date1(
    f1 DATE
);
Query OK, 0 rows affected (0.13 sec)
</code></pre><p>插入数据</p><pre><code class="language-mysql">INSERT INTO test_date1
VALUES ('2020-10-01'), ('20201001'),(20201001);
INSERT INTO test_date1
VALUES ('00-01-01'), ('000101'), ('69-10-01'), ('691001'), ('70-01-01'), ('700101'),
('99-01-01'), ('990101');

INSERT INTO test_date1
VALUES (000301), (690301), (700301), (990301);
INSERT INTO test_date1
VALUES (CURRENT_DATE()), (NOW());

SELECT *
FROM test_date1;
+------------+
| f1         |
+------------+
| 2020-10-01 |
| 2020-10-01 |
| 2020-10-01 |
| 2000-01-01 |
| 2000-01-01 |
| 2069-10-01 |
| 2069-10-01 |
| 1970-01-01 |
| 1970-01-01 |
| 1999-01-01 |
| 1999-01-01 |
| 2000-03-01 |
| 2069-03-01 |
| 1970-03-01 |
| 1999-03-01 |
| 2022-05-25 |
| 2022-05-25 |
+------------+
17 rows in set
</code></pre><h3 id="63-time类型">6.3 TIME类型<a href="#63-time类型" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>​ TIME类型用来表示时间，不包含日期部分。在MySQL中，需要 3个字节 的存储空间来存储TIME类型的数 据，可以使用“HH:MM:SS”格式来表示TIME类型，其中，HH表示小时，MM表示分钟，SS表示秒。 在MySQL中，向TIME类型的字段插入数据时，也可以使用几种不同的格式。</p><p>（1）可以使用带有冒号的 字符串，比如<code class="language-plaintext highlighter-rouge">' D HH:MM:SS' 、' HH:MM:SS '、' HH:MM '、' D HH:MM '、' D HH '或' SS '格式</code>，都能被正 确地插入TIME类型的字段中。其中D表示天，其最小值为0，最大值为34。如果使用带有D格式的字符串 插入TIME类型的字段时，D会被转化为小时，计算格式为D*24+HH。当使用带有冒号并且不带D的字符串 表示时间时，表示当天的时间，比如12:10表示12:10:00，而不是00:12:10。</p><p>（2）可以使用不带有冒号的 字符串或者数字，格式为<code class="language-plaintext highlighter-rouge">' HHMMSS '</code>或者<code class="language-plaintext highlighter-rouge"> HHMMSS </code>。如果插入一个不合法的字符串或者数字，MySQL在存 储数据时，会将其自动转化为00:00:00进行存储。比如1210，MySQL会将最右边的两位解析成秒，表示 00:12:10，而不是12:10:00。</p><p>（3）使用 CURRENT_TIME() 或者 NOW() ，会插入当前系统的时间。</p><p>举例： 创建数据表，表中包含一个TIME类型的字段f1。</p><pre><code class="language-mysql">CREATE TABLE test_time1(
    f1 TIME
);
Query OK, 0 rows affected (0.02 sec)
</code></pre><pre><code class="language-mysql">INSERT INTO test_time1
VALUES('2 12:30:29'), ('12:35:29'), ('12:40'), ('2 12:40'),('1 05'), ('45');
INSERT INTO test_time1
VALUES ('123520'), (124011),(1210);
INSERT INTO test_time1
VALUES (NOW()), (CURRENT_TIME());
SELECT * FROM test_time1;
</code></pre><h3 id="64-datetime类型">6.4 DATETIME类型<a href="#64-datetime类型" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>DATETIME类型在所有的日期时间类型中占用的存储空间最大，总共需要 8 个字节的存储空间。在格式上 为DATE类型和TIME类型的组合，可以表示为 YYYY-MM-DD HH:MM:SS ，其中YYYY表示年份，MM表示月 份，DD表示日期，HH表示小时，MM表示分钟，SS表示秒。</p><p>在向DATETIME类型的字段插入数据时，同样需要满足一定的格式条件。</p><ul><li>以<code class="language-plaintext highlighter-rouge"> YYYY-MM-DD HH:MM:SS</code> 格式或者 <code class="language-plaintext highlighter-rouge">YYYYMMDDHHMMSS </code>格式的字符串插入DATETIME类型的字段时， 最小值为1000-01-01 00:00:00，最大值为9999-12-03 23:59:59。<ul><li>以YYYYMMDDHHMMSS格式的数字插入DATETIME类型的字段时，会被转化为YYYY-MM-DD HH:MM:SS格式。<li>以 YY-MM-DD HH:MM:SS 格式或者 YYMMDDHHMMSS 格式的字符串插入DATETIME类型的字段时，两位数的年份规则符合YEAR类型的规则，00到69表示2000到2069；70到99表示1970到1999。<li>使用函数 CURRENT_TIMESTAMP() 和 NOW() ，可以向DATETIME类型的字段插入系统的当前日期和 时间。</ul></ul><p>举例： 创建数据表，表中包含一个DATETIME类型的字段dt。</p><pre><code class="language-mysql">CREATE TABLE test_datetime1(
dt DATETIME
);
Query OK, 0 rows affected (0.02 sec)
</code></pre><p>插入数据</p><pre><code class="language-mysql">INSERT INTO test_datetime1
VALUES ('2021-01-01 06:50:30'), ('20210101065030');
INSERT INTO test_datetime1
VALUES ('99-01-01 00:00:00'), ('990101000000'), ('20-01-01 00:00:00'),
('200101000000');
INSERT INTO test_datetime1
VALUES (20200101000000), (200101000000), (19990101000000), (990101000000);
INSERT INTO test_datetime1
VALUES (CURRENT_TIMESTAMP()), (NOW());

</code></pre><h3 id="65-timestamp类型">6.5 TIMESTAMP类型<a href="#65-timestamp类型" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>​ TIMESTAMP类型也可以表示日期时间，其显示格式与DATETIME类型相同，都是<code class="language-plaintext highlighter-rouge"> YYYY-MM-DD HH:MM:SS</code> ，需要4个字节的存储空间。但是TIMESTAMP存储的时间范围比DATETIME要小很多，只能存储<code class="language-plaintext highlighter-rouge"> “1970-01-01 00:00:01 UTC”到“2038-01-19 03:14:07 UTC”</code>之间的时间。其中，UTC表示世界统一时间，也叫 作世界标准时间。</p><p>​ <strong>存储数据的时候需要对当前时间所在的时区进行转换，查询数据的时候再将时间转换回当前的时 区。因此，使用TIMESTAMP存储的同一个时间值，在不同的时区查询时会显示不同的时间。</strong></p><p>​ 向TIMESTAMP类型的字段插入数据时，当插入的数据格式满足YY-MM-DD HH:MM:SS和YYMMDDHHMMSS 时，两位数值的年份同样符合YEAR类型的规则条件，只不过表示的时间范围要小很多。 如果向TIMESTAMP类型的字段插入的时间超出了TIMESTAMP类型的范围，则MySQL会抛出错误信息。</p><p>举例： 创建数据表，表中包含一个TIMESTAMP类型的字段ts。</p><pre><code class="language-mysql">CREATE TABLE test_timestamp1(
    ts TIMESTAMP
);

</code></pre><p>插入数据：</p><pre><code class="language-mysql">INSERT INTO test_timestamp1
VALUES ('1999-01-01 03:04:50'), ('19990101030405'), ('99-01-01 03:04:05'),
('990101030405');

INSERT INTO test_timestamp1
VALUES ('2020@01@01@00@00@00'), ('20@01@01@00@00@00');

INSERT INTO test_timestamp1
VALUES (CURRENT_TIMESTAMP()), (NOW());

#Incorrect datetime value
INSERT INTO test_timestamp1
VALUES ('2038-01-20 03:14:07');

</code></pre><p><strong>TIMESTAMP和DATETIME的区别</strong>：</p><ul><li>TIMESTAMP存储空间比较小，表示的日期时间范围也比较小<li>底层存储方式不同，TIMESTAMP底层存储的是毫秒值，距离1970-1-1 0:0:0 0毫秒的毫秒值。<li>两个日期比较大小或日期计算时，TIMESTAMP更方便、更快。<li>TIMESTAMP和时区有关。TIMESTAMP会根据用户的时区不同，显示不同的结果。而DATETIME则只能 反映出插入时当地的时区，其他时区的人查看数据必然会有误差的。</ul><pre><code class="language-mysql">CREATE TABLE temp_time(
    d1 DATETIME,
    d2 TIMESTAMP
);

INSERT INTO temp_time VALUES('2021-9-2 14:45:52','2021-9-2 14:45:52');
INSERT INTO temp_time VALUES(NOW(),NOW());

</code></pre><pre><code class="language-mysql">mysql&gt; SELECT * FROM temp_time;
+---------------------+---------------------+
| d1 				 | d2				 |
+---------------------+---------------------+
| 2021-09-02 14:45:52 | 2021-09-02 14:45:52 |
| 2021-11-03 17:38:17 | 2021-11-03 17:38:17 |
+---------------------+---------------------+
2 rows in set (0.00 sec)
</code></pre><pre><code class="language-mysql">#修改当前的时区
SET time_zone = '+9:00';
</code></pre><pre><code class="language-mysql">mysql&gt; SELECT * FROM temp_time;
+---------------------+---------------------+
| d1 				 | d2 				 |
+---------------------+---------------------+
| 2021-09-02 14:45:52 | 2021-09-02 15:45:52 |
| 2021-11-03 17:38:17 | 2021-11-03 18:38:17 |
+---------------------+---------------------+
2 rows in set (0.00 sec
</code></pre><h3 id="66-开发中经验">6.6 开发中经验<a href="#66-开发中经验" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>​ 用得最多的日期时间类型，就是<code class="language-plaintext highlighter-rouge"> DATETIME</code> 。虽然 MySQL 也支持 YEAR（年）、 TIME（时间）、 DATE（日期），以及 TIMESTAMP 类型，但是在实际项目中，尽量用 DATETIME 类型。因为这个数据类型 包括了完整的日期和时间信息，取值范围也最大，使用起来比较方便。毕竟，如果日期时间信息分散在 好几个字段，很不容易记，而且查询的时候，SQL 语句也会更加复杂。</p><p>​ 此外，<code class="language-plaintext highlighter-rouge">一般存注册时间、商品发布时间等，不建议使用DATETIME存储，而是使用 时间戳 </code>，因为 DATETIME虽然直观，但不便于计算。</p><pre><code class="language-mysql">mysql&gt; SELECT UNIX_TIMESTAMP();
+------------------+
| UNIX_TIMESTAMP() |
+------------------+
| 1635932762       |
+------------------+
1 row in set (0.00 sec)

</code></pre><h2 id="7-文本字符串类型">7. 文本字符串类型<a href="#7-文本字符串类型" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>​ 在实际的项目中，我们还经常遇到一种数据，就是字符串数据。 MySQL中，文本字符串总体上分为 CHAR 、 VARCHAR 、 TINYTEXT 、 TEXT 、 MEDIUMTEXT 、 LONGTEXT 、 ENUM 、 SET 等类型。</p><div class="table-wrapper"><table><thead><tr><th>文本字符串类型<th>值的长度<th>长度范围<th>占用的存储空间<tbody><tr><td>CHAR(M)<td>M<td>0&lt;=M&lt;=255<td>M个字节<tr><td>VARCHAR(M)<td>M<td>0&lt;=M&lt;=65535<td>M+1个字节<tr><td>TINYTEXT<td>L<td>0&lt;=L&lt;=255<td>L+2个字节<tr><td>TEXT<td>L<td>0&lt;=L&lt;=65535<td>L+2个字节<tr><td>MEDIUMTEXT<td>L<td>0&lt;=L&lt;=16777215<td>L+3个字节<tr><td>LONGTEXT<td>L<td>0&lt;=L&lt;=4294967295<td>L+4个字节<tr><td>ENUM<td>L<td>1&lt;=L&lt;=65535<td>1或2个字节<tr><td>SET<td>L<td>0&lt;=L&lt;=64<td>1,2,3,4或8个字节</table></div><h3 id="71-char与varchar类型">7.1 CHAR与VARCHAR类型<a href="#71-char与varchar类型" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p><strong>CHAR类型</strong>：</p><ul><li>CHAR(M) 类型一般需要预先定义字符串长度。如果不指定(M)，则表示长度默认是1个字符。<li>如果保存时，数据的实际长度比CHAR类型声明的长度小，则会在 右侧填充 空格以达到指定的长 度。当MySQL检索CHAR类型的数据时，CHAR类型的字段会去除尾部的空格。<li>定义CHAR类型字段时，声明的字段长度即为CHAR类型字段所占的存储空间的字节数。</ul><pre><code class="language-mysql">CREATE TABLE test_char1(
    c1 CHAR,
    c2 CHAR(5)
);
DESC test_char1;

INSERT INTO test_char1
VALUES('a','Tom');
SELECT c1,CONCAT(c2,'***') FROM test_char1;

INSERT INTO test_char1(c2)
VALUES('a ');

SELECT CHAR_LENGTH(c2)
FROM test_char1;
</code></pre><p><strong>VARCHAR类型</strong>：</p><ul><li>VARCHAR(M) 定义时， 必须指定 长度M，否则报错。<li>MySQL4.0版本以下，varchar(20)：指的是20字节，如果存放UTF8汉字时，只能存6个（每个汉字3字 节） ；MySQL5.0版本以上，varchar(20)：指的是20字符。<li>检索VARCHAR类型的字段数据时，会保留数据尾部的空格。VARCHAR类型的字段所占用的存储空间 为字符串实际长度加1个字节。</ul><pre><code class="language-mysql">CREATE TABLE test_varchar1(
    NAME VARCHAR #错误
);
</code></pre><pre><code class="language-mysql">#Column length too big for column 'NAME' (max = 21845);
CREATE TABLE test_varchar2(
    NAME VARCHAR(65535) #错误
);

CREATE TABLE test_varchar3(
    NAME VARCHAR(5)
);
INSERT INTO test_varchar3
VALUES('尚硅谷'),('尚硅谷教育');
#Data too long for column 'NAME' at row 1
INSERT INTO test_varchar3
VALUES('尚硅谷IT教育');

</code></pre><p><strong>哪些情况使用 CHAR 或 VARCHAR 更好</strong></p><div class="table-wrapper"><table><thead><tr><th>类型<th>特点<th>空间上<th>时间上<th>适用场景<tbody><tr><td>CHAR(M)<td>固定长度<td>浪费存储空间<td>效率高<td>存储不大，速度要求高<tr><td>VARCHAR(M)<td>可变长度<td>节省存储空间<td>效率低<td>非CHAR的情况</table></div><p>情况1：存储很短的信息。比如门牌号码101，201……这样很短的信息应该用char，因为varchar还要占个 byte用于存储信息长度，本来打算节约存储的，结果得不偿失。</p><p>情况2：固定长度的。比如使用uuid作为主键，那用char应该更合适。因为他固定长度，varchar动态根据 长度的特性就消失了，而且还要占个长度信息。</p><p>情况3：十分频繁改变的column。因为varchar每次存储都要有额外的计算，得到长度等工作，如果一个 非常频繁改变的，那就要有很多的精力用于计算，而这些对于char来说是不需要的。</p><p>情况4：具体存储引擎中的情况：</p><ul><li>MyISAM 数据存储引擎和数据列：<code class="language-plaintext highlighter-rouge">MyISAM数据表，最好使用固定长度(CHAR)的数据列代替可变长度(VARCHAR)的数据列</code>。这样使得整个表静态化，从而使 数据检索更快 ，用空间换时间。<li>MEMORY 存储引擎和数据列：MEMORY数据表目前都使用固定长度的数据行存储，因此无论使用 CHAR或VARCHAR列都没有关系，两者都是作为CHAR类型处理的。<li>InnoDB 存储引擎，<code class="language-plaintext highlighter-rouge">建议使用VARCHAR类型</code>。因为对于InnoDB数据表，内部的行存储格式并没有区 分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），而且主要影响性能的因素 是数据行使用的存储总量，由于char平均占用的空间多于varchar，所以除了简短并且固定长度的， 其他考虑varchar。这样节省空间，对磁盘I/O和数据存储总量比较好。</ul><h3 id="72-text类型">7.2 TEXT类型<a href="#72-text类型" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>​ 在MySQL中，TEXT用来保存文本类型的字符串，总共包含4种类型，分别为TINYTEXT、TEXT、 MEDIUMTEXT 和 LONGTEXT 类型。 在向TEXT类型的字段保存和查询数据时，系统自动按照实际长度存储，不需要预先定义长度。这一点和 VARCHAR类型相同。 每种TEXT类型保存的数据长度和所占用的存储空间不同，如下：</p><div class="table-wrapper"><table><thead><tr><th>文本字符串类型<th>值的长度<th>长度范围<th>占用的存储空间<tbody><tr><td>TINYTEXT<td>L<td>0&lt;=L&lt;=255<td>L+2个字节<tr><td>TEXT<td>L<td>0&lt;=L&lt;=65535<td>L+2个字节<tr><td>MEDIUMTEXT<td>L<td>0&lt;=L&lt;=16777215<td>L+3个字节<tr><td>LONGTEXT<td>L<td>0&lt;=L&lt;=4294967295<td>L+4个字节</table></div><p><strong>由于实际存储的长度不确定，MySQL 不允许 TEXT 类型的字段做主键</strong>。遇到这种情况，你只能采用 CHAR(M)，或者 VARCHAR(M)。</p><p>创建数据表：</p><pre><code class="language-mysql">CREATE TABLE test_text(
    tx TEXT
);

INSERT INTO test_text
VALUES('atguigu ');
SELECT CHAR_LENGTH(tx)
FROM test_text; #10
</code></pre><p>说明在保存和查询数据时，并没有删除TEXT类型的数据尾部的空格。</p><p><strong>开发中经验</strong>：</p><p>​ TEXT文本类型，可以存比较大的文本段，搜索速度稍慢，因此如果不是特别大的内容，建议使用CHAR， VARCHAR来代替。还有TEXT类型不用加默认值，加了也没用。而且text和blob类型的数据删除后容易导致 “空洞”，使得文件碎片比较多，<code class="language-plaintext highlighter-rouge">所以频繁使用的表不建议包含TEXT类型字段，建议单独分出去，单独用 一个表</code>。</p><h2 id="8-enum类型">8. ENUM类型<a href="#8-enum类型" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>​ ENUM类型也叫作枚举类型，ENUM类型的取值范围需要在定义字段时进行指定。设置字段值时，ENUM 类型只允许从成员中选取单个值，不能一次选取多个值。 其所需要的存储空间由定义ENUM类型时指定的成员个数决定。</p><div class="table-wrapper"><table><thead><tr><th>文本字符串类型<th>值的长度<th>长度范围<th>占用的存储空间<tbody><tr><td>ENUM<td>L<td>1&lt;=L&lt;=65535<td>1或2个字节</table></div><ul><li>当ENUM类型包含1～255个成员时，需要1个字节的存储空间；<li>当ENUM类型包含256～65535个成员时，需要2个字节的存储空间。<li>ENUM类型的成员个数的上限为65535个。</ul><p>举例：</p><p>创建表如下：</p><pre><code class="language-mysql">CREATE TABLE test_enum(
    season ENUM('春','夏','秋','冬','unknow')
);
</code></pre><p>添加数据：</p><pre><code class="language-mysql">INSERT INTO test_enum
VALUES('春'),('秋');
# 忽略大小写
INSERT INTO test_enum
VALUES('UNKNOW');
# 允许按照角标的方式获取指定索引位置的枚举值
INSERT INTO test_enum
VALUES('1'),(3);
# Data truncated for column 'season' at row 1
INSERT INTO test_enum
VALUES('ab');
# 当ENUM类型的字段没有声明为NOT NULL时，插入NULL也是有效的
INSERT INTO test_enum
VALUES(NULL);

</code></pre><h2 id="9-set类型">9. SET类型<a href="#9-set类型" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>​ SET表示一个字符串对象，可以包含0个或多个成员，但成员个数的上限为 64 。设置字段值时，可以取 取值范围内的 0 个或多个值。 当SET类型包含的成员个数不同时，其所占用的存储空间也是不同的，具体如下：</p><div class="table-wrapper"><table><thead><tr><th>成员个数范围（L表示实际成员个数）<th>占用的存储空间<tbody><tr><td>1 &lt;= L &lt;= 8<td>1个字节<tr><td>9 &lt;= L &lt;= 16<td>2个字节<tr><td>17 &lt;= L &lt;= 24<td>3个字节<tr><td>25 &lt;= L &lt;= 32<td>4个字节<tr><td>33 &lt;= L &lt;= 64<td>8个字节</table></div><p>SET类型在存储数据时成员个数越多，其占用的存储空间越大。注意：SET类型在选取成员时，可以一次 选择多个成员，这一点与ENUM类型不同。</p><p>举例： 创建表：</p><pre><code class="language-mysql">    CREATE TABLE test_set(
    s SET ('A', 'B', 'C')
    );
</code></pre><pre><code class="language-mysql">INSERT INTO test_set (s) VALUES ('A'), ('A,B');
#插入重复的SET类型成员时，MySQL会自动删除重复的成员
INSERT INTO test_set (s) VALUES ('A,B,C,A');
#向SET类型的字段插入SET成员中不存在的值时，MySQL会抛出错误。
INSERT INTO test_set (s) VALUES ('A,B,C,D');
SELECT *
FROM test_set;
</code></pre><h2 id="10-二进制字符串类型">10. 二进制字符串类型<a href="#10-二进制字符串类型" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>MySQL中的二进制字符串类型主要存储一些二进制数据，比如可以存储图片、音频和视频等二进制数据。</p><p>MySQL中支持的二进制字符串类型主要包括BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB类型。</p><p><strong>BINARY与VARBINARY类型</strong></p><p>​ BINARY和VARBINARY类似于CHAR和VARCHAR，只是它们存储的是二进制字符串。</p><p>​ BINARY (M)为固定长度的二进制字符串，M表示最多能存储的字节数，取值范围是0~255个字符。如果未 指定(M)，表示只能存储 1个字节 。例如BINARY (8)，表示最多能存储8个字节，如果字段值不足(M)个字 节，将在右边填充’\0’以补齐指定长度。</p><p>​ VARBINARY (M)为可变长度的二进制字符串，M表示最多能存储的字节数，总字节数不能超过行的字节长 度限制65535，另外还要考虑额外字节开销，VARBINARY类型的数据除了存储数据本身外，还需要1或2个 字节来存储数据的字节数。VARBINARY类型 必须指定(M) ，否则报错。</p><div class="table-wrapper"><table><thead><tr><th>二进制字符串类型<th>特点<th>值的长度<th>占用空间<tbody><tr><td>BINARY(M)<td>固定长度<td>M （0 &lt;= M &lt;= 255）<td>M个字节<tr><td>VARBINARY(M)<td>可变长度<td>M（0 &lt;= M &lt;= 65535）<td>M+1个字节</table></div><pre><code class="language-mysql">CREATE TABLE test_binary1(
    f1 BINARY,
    f2 BINARY(3),
    # f3 VARBINARY,
    f4 VARBINARY(10)
);

INSERT INTO test_binary1(f1,f2)
VALUES('a','a');
INSERT INTO test_binary1(f1,f2)
VALUES('尚','尚');#失败

INSERT INTO test_binary1(f2,f4)
VALUES('ab','ab');
mysql&gt; SELECT LENGTH(f2),LENGTH(f4)
-&gt; FROM test_binary1;
+------------+------------+
| LENGTH(f2) | LENGTH(f4) |
+------------+------------+
| 3          | NULL       |
| 3          | 2          |
+------------+------------+
2 rows in set (0.00 sec)

</code></pre><p>**BLOB类型 **</p><p>​ BLOB是一个 <code class="language-plaintext highlighter-rouge">二进制大对象</code> ，可以容纳可变数量的数据。 MySQL中的BLOB类型包括TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB 4种类型，它们可容纳值的最大 长度不同。可以存储一个二进制的大对象，比如 图片 、 音频 和 视频 等。 需要注意的是，在实际工作中，往往不会在MySQL数据库中使用BLOB类型存储大对象数据，通常会将图 片、音频和视频文件存储到 服务器的磁盘上 ，并将图片、音频和视频的访问路径存储到MySQL中。</p><div class="table-wrapper"><table><thead><tr><th>二进制字符串类型<th>值的长度<th>长度范围<th>占用空间<tbody><tr><td>TINYBLOB<td>L<td>0=&lt;L&lt;=255<td>L+1个字节<tr><td>BLOB<td>L<td>0=&lt;L&lt;=65535(相当于64kb)<td>L+2个字节<tr><td>MEDIUMBLOB<td>L<td>0=&lt;L&lt;=16777215(相当于16MB)<td>L+3个字节<tr><td>TINYBLOB<td>L<td>0=&lt;L&lt;=4294967295(相当于4GB)<td>L+4个字节</table></div><pre><code class="language-MYSQL">CREATE TABLE test_blob1(
    id INT,
    img MEDIUMBLOB
);
</code></pre><p><strong>TEXT和BLOB的使用注意事项</strong>：</p><p>在使用text和blob字段类型时要注意以下几点，以便更好的发挥数据库的性能。</p><p>① BLOB和TEXT值也会引起自己的一些问题，特别是执行了大量的删除或更新操作的时候。删除这种值 会在数据表中留下很大的” 空洞 “，以后填入这些”空洞”的记录可能长度不同。为了提高性能，建议定期 使用 OPTIMIZE TABLE 功能对这类表进行 碎片整理 。</p><p>② 如果需要对大文本字段进行模糊查询，MySQL 提供了 前缀索引 。但是仍然要在不必要的时候避免检 索大型的BLOB或TEXT值。例如，SELECT * 查询就不是很好的想法，除非你能够确定作为约束条件的 WHERE子句只会找到所需要的数据行。否则，你可能毫无目的地在网络上传输大量的值。</p><p>③ 把BLOB或TEXT列 分离到单独的表 中。在某些环境中，如果把这些数据列移动到第二张数据表中，可 以让你把原数据表中的数据列转换为固定长度的数据行格式，那么它就是有意义的。这会 减少主表中的 碎片 ，使你得到固定长度数据行的性能优势。它还使你在主数据表上运行 <code class="language-plaintext highlighter-rouge">SELECT * </code>查询的时候不会通过 网络传输大量的BLOB或TEXT值。</p><h2 id="11-json-类型">11. JSON 类型<a href="#11-json-类型" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>​ JSON（JavaScript Object Notation）是一种轻量级的数据交换格式 。简洁和清晰的层次结构使得 JSON 成 为理想的数据交换语言。它易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效 率。<strong>JSON 可以将 JavaScript 对象中表示的一组数据转换为字符串，然后就可以在网络或者程序之间轻 松地传递这个字符串，并在需要的时候将它还原为各编程语言所支持的数据格式</strong>。</p><p>​ 在MySQL 5.7中，就已经支持JSON数据类型。在MySQL 8.x版本中，JSON类型提供了可以进行自动验证的 JSON文档和优化的存储结构，使得在MySQL中存储和读取JSON类型的数据更加方便和高效。 创建数据 表，表中包含一个JSON类型的字段 js 。</p><pre><code class="language-MYSQL">CREATE TABLE test_json(
    js json
);
</code></pre><p>向表中插入JSON数据。</p><pre><code class="language-mysql">INSERT INTO test_json (js)
VALUES ('{"name":"songhk", "age":18, "address":{"province":"beijing",
        "city":"beijing"}}');
</code></pre><p>查询t19表中的数据。</p><pre><code class="language-mysql">mysql&gt; SELECT * FROM test_json;
</code></pre><pre><code class="language-mysql">mysql&gt; SELECT js -&gt; '$.name' AS NAME,js -&gt; '$.age' AS age ,js -&gt; '$.address.province'
AS province, js -&gt; '$.address.city' AS city
-&gt; FROM test_json;
+----------+------+-----------+-----------+
| NAME     | age  | province  | city      |
+----------+------+-----------+-----------+
| "songhk" | 18   | "beijing" | "beijing" |
+----------+------+-----------+-----------+
1 row in set (0.00 sec)

</code></pre><p>通过<code class="language-plaintext highlighter-rouge">-&gt;</code>和<code class="language-plaintext highlighter-rouge">-&gt;&gt;</code>符号，从JSON字段中正确查询出了指定的JSON数据的值。</p><h2 id="12-空间类型">12. 空间类型<a href="#12-空间类型" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>​ MySQL 空间类型扩展支持地理特征的生成、存储和分析。</p><p>​ 这里的地理特征表示世界上具有位置的任何东 西，可以是一个实体，例如一座山；可以是空间，例如一座办公楼；也可以是一个可定义的位置，例如 一个十字路口等等。MySQL中使用 Geometry（几何） 来表示所有地理特征。Geometry指一个点或点的 集合，代表世界上任何具有位置的事物。 MySQL的空间数据类型（Spatial Data Type）对应于OpenGIS类，包括单值类型：GEOMETRY、POINT、 LINESTRING、POLYGON以及集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、 GEOMETRYCOLLECTION 。</p><ul><li>Geometry是所有空间集合类型的基类，其他类型如POINT、LINESTRING、POLYGON都是Geometry的 子类。<ul><li>Point，顾名思义就是点，有一个坐标值。例如POINT(121.213342 31.234532)，POINT(30 10)， 坐标值支持DECIMAL类型，经度（longitude）在前，维度（latitude）在后，用空格分隔。 LineString，线，由一系列点连接而成。如果线从头至尾没有交叉，那就是简单的 （simple）；如果起点和终点重叠，那就是封闭的（closed）。例如LINESTRING(30 10,10 30,40 40)，点与点之间用逗号分隔，一个点中的经纬度用空格分隔，与POINT格式一致。<li>Polygon，多边形。可以是一个实心平面形，即没有内部边界，也可以有空洞，类似纽扣。最 简单的就是只有一个外边界的情况，例如POLYGON((0 0,10 0,10 10, 0 10))。</ul></ul><p>下面展示几种常见的几何图形元素：</p><p><img data-src="../../assets/images/20210612MysqlDigitalType/image-20220525160632429.png" alt="image-20220525160632429" data-proofer-ignore></p><p>MultiPoint、MultiLineString、MultiPolygon、GeometryCollection 这4种类型都是集合类，是多个 Point、LineString或Polygon组合而成。</p><p>下面展示的是多个同类或异类几何图形元素的组合：</p><p><img data-src="../../assets/images/20210612MysqlDigitalType/image-20220525160648750.png" alt="image-20220525160648750" data-proofer-ignore></p><h2 id="13-小结及选择建议">13. 小结及选择建议<a href="#13-小结及选择建议" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>​ 在定义数据类型时，</p><div class="language-sh highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>1. 如果确定是 整数 ，就用 INT ； 
2. 如果是 小数 ，一定用定点数类型 DECIMAL<span class="o">(</span>M,D<span class="o">)</span> ； 
3. 如果是日期与时间，就用 DATETIME 。
</pre></table></code></div></div>这样做的好处是，首先确保你的系统不会因为数据类型定义出错。不过，凡事都是有两面的，可靠性 好，并不意味着高效。比如，TEXT 虽然使用方便，但是效率不如 CHAR(M) 和 VARCHAR(M)。 关于字符串的选择，建议参考如下阿里巴巴的《Java开发手册》规范：<p><strong>阿里巴巴《Java开发手册》之MySQL数据库</strong>：</p><ul><li><code class="language-plaintext highlighter-rouge">任何字段如果为非负数，必须是 UNSIGNED</code> <code class="language-plaintext highlighter-rouge">【 强制 】</code>小数类型为 DECIMAL，禁止使用 FLOAT 和 DOUBLE。 说明：在存储的时候，FLOAT 和 DOUBLE 都存在精度损失的问题，很可能在比较值的时候，得 到不正确的结果。如果存储的数据范围超过 DECIMAL 的范围，建议将数据拆成整数和小数并 分开存储。<li><code class="language-plaintext highlighter-rouge">【 强制 】</code>如果存储的字符串长度几乎相等，使用 CHAR 定长字符串类型。<li><code class="language-plaintext highlighter-rouge">【 强制 】</code>VARCHAR 是可变长字符串，不预先分配存储空间，长度不要超过 5000。如果存储长度大 于此值，定义字段类型为 TEXT，独立出来一张表，用主键来对应，避免影响其它字段索引效率</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/'>数据库</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/mysql/" class="post-tag no-text-decoration" >MySQL</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=MySQL数据类型精讲 - Technical Blogs&url=https://carmanzheng.github.io//posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=MySQL数据类型精讲 - Technical Blogs&u=https://carmanzheng.github.io//posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=MySQL数据类型精讲 - Technical Blogs&url=https://carmanzheng.github.io//posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Kubernetes%E6%A6%82%E8%BF%B0/">Kubernetes</a><li><a href="/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">MySQL存储引擎</a><li><a href="/posts/Linux%E5%9F%BA%E7%A1%80/">Linux基础</a><li><a href="/posts/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Python基操-多进程与多线程</a><li><a href="/posts/%E5%89%8D%E7%AB%AF-Vue%E8%B7%AF%E7%94%B1%E4%B8%8EVuex/">前端 Vue路由与vuex</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/mysql/">MySQL</a> <a class="post-tag" href="/tags/python%E5%9F%BA%E6%93%8D/">Python基操</a> <a class="post-tag" href="/tags/%E5%89%8D%E7%AB%AFjs/">前端JS</a> <a class="post-tag" href="/tags/%E5%89%8D%E7%AB%AFvue/">前端Vue</a> <a class="post-tag" href="/tags/%E5%89%8D%E7%AB%AFcss/">前端CSS</a> <a class="post-tag" href="/tags/devops/">DevOps</a> <a class="post-tag" href="/tags/linux%E5%9F%BA%E7%A1%80/">Linux基础</a> <a class="post-tag" href="/tags/%E5%89%8D%E7%AB%AFhtml/">前端HTML</a> <a class="post-tag" href="/tags/github/">Github</a> <a class="post-tag" href="/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91/">客户端开发</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><div class="card-body"> <em class="timeago small" date="2021-07-06 00:00:00 +0800" >2021-07-06</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>MySQL存储引擎</h3><div class="text-muted small"><p> 1.为什么使用索引 假如给数据使用 二叉树 这样的数据结构进行存储，如下图所示 2. 索引及其优缺点 2.1 索引概述 MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。 索引的本质：索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。 这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 ...</p></div></div></a></div><div class="card"> <a href="/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E5%9F%BA%E7%A1%80/"><div class="card-body"> <em class="timeago small" date="2021-06-01 00:00:00 +0800" >2021-06-01</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>MySQL基础</h3><div class="text-muted small"><p> 1. 数据库功能 ​ 持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多 通过各种关系数据库来完成。 ​ 持久化的主要作用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数 据文件中。 2.数据库与数据库管理系统 2....</p></div></div></a></div><div class="card"> <a href="/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E5%AE%89%E8%A3%85/"><div class="card-body"> <em class="timeago small" date="2021-06-02 00:00:00 +0800" >2021-06-02</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>MySQL安装</h3><div class="text-muted small"><p> 1. 下载软件 官网：https://www.mysql.com 下载地址：https://dev.mysql.com/downloads/windows/installer/8.0.html MySQL Community Server 社区版本，开源免费，自由下载，但不提供官方技术支持，适用于 大多数普通用户。 MySQL Enterprise Edition 企业版本，...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8B%E5%A2%9E%E5%88%A0%E6%94%B9/" class="btn btn-outline-primary" prompt="上一篇"><p>MySQL数据处理之增删改</p></a> <a href="/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E7%BA%A6%E6%9D%9F/" class="btn btn-outline-primary" prompt="下一篇"><p>MySQL约束</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/carmanzheng">carmanzheng</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/mysql/">MySQL</a> <a class="post-tag" href="/tags/python%E5%9F%BA%E6%93%8D/">Python基操</a> <a class="post-tag" href="/tags/%E5%89%8D%E7%AB%AFjs/">前端JS</a> <a class="post-tag" href="/tags/%E5%89%8D%E7%AB%AFvue/">前端Vue</a> <a class="post-tag" href="/tags/%E5%89%8D%E7%AB%AFcss/">前端CSS</a> <a class="post-tag" href="/tags/devops/">DevOps</a> <a class="post-tag" href="/tags/linux%E5%9F%BA%E7%A1%80/">Linux基础</a> <a class="post-tag" href="/tags/%E5%89%8D%E7%AB%AFhtml/">前端HTML</a> <a class="post-tag" href="/tags/github/">Github</a> <a class="post-tag" href="/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91/">客户端开发</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
