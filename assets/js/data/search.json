[ { "title": "Kubernetes", "url": "/posts/Kubernetes%E6%A6%82%E8%BF%B0/", "categories": "边缘计算", "tags": "DevOps", "date": "2022-02-17 00:00:00 +0800", "snippet": "​ K8s是谷歌在2014年开源的容器化集群管理系统，使用k8s进行容器化应用部署。k8s利于应用的扩展，让容器化应用更加简洁高效。1.自动装箱​ 基于容器对应用运行环境的资源配置要求，自动部署应用容器2.自我修复​ 当容器失败时，会对容器进行重启​ 当所部署的Node节点有问题时，会对容器进行重新部署和重新调度​ 当容器未通过监控检查时，会关闭此容器；直到容器正常运行时，才对外提供服务3.水平扩展​ 通过简单的命令、用户UI界面或基于CPU等资源的使用情况，对应用容器进行规模化扩大或规模剪裁4.滚动更新​ 可以根据应用的变化，对运行的应用进行一次性或者批量式更新5.版本回退​ 根据应用部署情况，进行历史版本的即时回退6.秘钥和配置管理​ 在不需要重新构建镜像的情况下，可以部署和更新秘钥和应用配置，类似热部署7.存储编排​ 自动实现存储系统挂载和应用，特别对有状态应用实现数据持久化非常重要。存储系统可以来自本地目录、网络存储（NFS、Gluster、Ceph等）、公共云存储服务8.批处理​ 提供一次性任务、定时任务；满足批量数据处理和分析的场景。1.部署方式 部署方 式 说明 传统部署方式 应用直接在物理机上部署，机器的资源分配不好，出现bug时，可能机器的大部分资源被某个应用占用，导致其他应用无法正常运行，无法做到应用隔离 虚拟机部署 在单个物理机上运行多个虚拟机， 每个虚拟机都是完整独立的系统，性能损耗大 容器部署 所有容器共享主机的系统，相当于轻量级的虚拟机，性能损耗小，资源隔离，CPU内存实现按需分配 2.应用场景 集群规模 部署方式 单台机器 直接使用docker + docker-compose就够了，方便轻松 多台机器（3-4台） 单台机器单独配置运行环境+负载均衡器、，亦可以轻松化解 n多台机器（成百上千） 借助k8s，可实现集中式的管理集群机器和应用，加机器、版本升级、版本回滚、不停机的灰度更新，确保高可用、高性能、高扩展 3.Kubernetes集群架构说明 概念 说明 master node 主节点：控制平台，不需要很高的性能、不跑任务，通常一个就行了，也可以开多个主节点来提高集群的可用度 kube-apiserver API 服务器，公开了 Kubernetes API；集群同一入口，以restful方式，交给etcd存储 etcd 存储系统，保存 Kubernetes 所有集群数据的后台数据库 kube-scheduler 节点调度，调度 Pod 到哪个节点运行 kube-controller 集群控制器，处理集群中常规后台任务，一个资源对应一个控制器 cloud-controller 与云服务商交互 概念 说明 worker node 工作节点：可以是物理机或者虚拟机，任务都在这里跑，机器的性能需要好点；通常有很多个，可以不断的加机器扩大集群；每个工作节点都由主节点管理 Pod K8S管理和调度的最小单位；每个pod都有自己的虚拟IP。Pod内部容器共享同一IP；一个工作节点可以有多个pod，一个pod可以包含一个或多个容器；主节点会考量负载自动调度pod的运行位置； kublet master排到node的节点代表，管理本机容器 kube-proxy 提供网络代理，负载均衡等操作 4.Kubernetes集群部署方式https://github.com/lework/kainstall K8S部署方式 说明 特点 minikube Minicube是一个工具，可以在本地快速运行一个单点的Kubernetes，仅用于尝试kubernetes或日常开发的用户使用 参考 ：https://minikube.sigs.k8s.io/docs/tutorials/   kubeadm Kubeadm也是一个工具，提供kubeadm init 和kubeadm join，用于快速部署Kubernetes集群，参考：https://kubernetes.io/docs/tasks/tools/ 快速，但是产生错误不好排除 二进制 推荐，从官方下载发行版的二进制包，手动部署每个组件，组成k8s集群 手动，配置过程较为复杂，但是出现问题能够良好的排除，且能了解K8S的详细流程 5.Kubeadm搭建​ kubeadm是官方社区推出的一个用于快速部署k8s集群的工具，这个工具能通过两条指令完成一个k8s集群的部署。第一步，创建一个Master节点 kubeadm init第二步，将Node节点加入到已创建的Master节点中 kubeadm join Master的ip和端口1.系统初始化 一台或者多台机器，操作系统centos7以上版本 硬件配置：RAM至少2GB，CPU至少2核，硬盘至少30GB 集群中所有机器之间网络互通 可以访问外网（需要拉取镜像） 进制swap分区每台机器执行# 关闭防火墙systemctl stop firewallsystemctl disable firewall# 关闭selinuxsed -i &#39;s/enforcing/disable&#39; /etc/selinux/config # 永久关闭setenforce 0 # 临时关闭# 关闭swapsed -ri &#39;s/.*swap.*/%&amp;amp;/&#39; /etc/fstab #永久关闭swapoff -a # 临时关闭三台机器分别执行# 根据规划设置主机名hostnamectl set-hostname k8smasterhostnamectl set-hostname k8snode1hostnamectl set-hostname k8snode2# 将桥接的IPV4流量传递到iptables的链路cat /etc/sysctl.d/k8s.conf &amp;lt;&amp;lt; EOFnet.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1EOF system --system # 生效# 时间同步yum install ntpdate -yntpdate time.windows.com在master主机上添加cat &amp;gt;&amp;gt; /etc/hosts &amp;lt;&amp;lt; EOF192.168.44.146 k8smaster192.168.44.147 k8snode1192.168.44.148 k8snode2EOF2.所有节点安装软件所有节点都需要安装Docker、kubeadm和kubelet三台机器操作# （1）安装 Docker$ wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O/etc/yum.repos.d/docker-ce.repo$ yum -y install docker-ce-18.06.1.ce-3.el7$ systemctl enable docker &amp;amp;&amp;amp; systemctl start docker$ docker --version# （2）添加阿里云 YUM 软件源# 设置仓库地址$ cat &amp;gt; /etc/docker/daemon.json &amp;lt;&amp;lt; EOF{&quot;registry-mirrors&quot;: [&quot;https://b9pmyelo.mirror.aliyuncs.com&quot;]}EOF# 重启docker$ systemctl restart docker# 设置yum源$ cat &amp;gt; /etc/yum.repos.d/kubernetes.repo &amp;lt;&amp;lt; EOF[kubernetes]name=Kubernetebaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0repo_gpgcheck=0gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpghttps://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF#（3）安装 kubeadm，kubelet 和 kubect$ yum install -y kubelet kubeadm kubectl$ systemctl enable kubelet3.部署k8s Master 和 Node在192.168.44.146（master节点）上执行$ kubeadm init \\--apiserver-advertise-address=192.168.44.146 \\ # 与master节点ip对应--image-repository registry.aliyuncs.com/google_containers \\ # 镜像仓库--kubernetes-version v1.17.0 \\ # 填写当前k8s版本--service-cidr=10.96.0.0/12 \\ # 填写与当前ip不同的IP段--pod-network-cidr=10.244.0.0/16 # 填写与当前ip不同的IP段这个过程使用docker拉取官方镜像，由于默认拉取镜像地址 k8s.gcr.io 国内无法访问，这里指定阿里云镜像仓库地址（即aliyuncs.com/google_containers仓库）。后面就会出现拉取成功的提示Your Kubernetes control-plane has initialized successfully!....提示语....You should ... Then ...(这个后面的提示在node节点执行)使用kubectl创建,在master节点(You should 后面出现的话)$ mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config在node节点(出现在提示中then后面的话)向集群添加新节点，执行在 kubeadm init 输出的 kubeadm join命令$ kubeadm join 192.168.44.146:6443 --token esce21.q6hetwm8si29qxwn \\--discovery-token-ca-cert-hashsha256:00603a05805807501d7181c3d60b478788408cfe6cedefedb1f97569708be9c5加入完之后，在master中查看节点$ kubectl get nodes4.安装Pod网络插件（CNI）在master节点$ kubectl apply –f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml$ kubectl get pods -n kube-systemhttps://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml如下内容---apiVersion: policy/v1beta1kind: PodSecurityPolicymetadata: name: psp.flannel.unprivileged annotations: seccomp.security.alpha.kubernetes.io/allowedProfileNames: docker/default seccomp.security.alpha.kubernetes.io/defaultProfileName: docker/default apparmor.security.beta.kubernetes.io/allowedProfileNames: runtime/default apparmor.security.beta.kubernetes.io/defaultProfileName: runtime/defaultspec: privileged: false volumes: - configMap - secret - emptyDir - hostPath allowedHostPaths: - pathPrefix: &quot;/etc/cni/net.d&quot; - pathPrefix: &quot;/etc/kube-flannel&quot; - pathPrefix: &quot;/run/flannel&quot; readOnlyRootFilesystem: false # Users and groups runAsUser: rule: RunAsAny supplementalGroups: rule: RunAsAny fsGroup: rule: RunAsAny # Privilege Escalation allowPrivilegeEscalation: false defaultAllowPrivilegeEscalation: false # Capabilities allowedCapabilities: [&#39;NET_ADMIN&#39;, &#39;NET_RAW&#39;] defaultAddCapabilities: [] requiredDropCapabilities: [] # Host namespaces hostPID: false hostIPC: false hostNetwork: true hostPorts: - min: 0 max: 65535 # SELinux seLinux: # SELinux is unused in CaaSP rule: &#39;RunAsAny&#39;---kind: ClusterRoleapiVersion: rbac.authorization.k8s.io/v1metadata: name: flannelrules:- apiGroups: [&#39;extensions&#39;] resources: [&#39;podsecuritypolicies&#39;] verbs: [&#39;use&#39;] resourceNames: [&#39;psp.flannel.unprivileged&#39;]- apiGroups: - &quot;&quot; resources: - pods verbs: - get- apiGroups: - &quot;&quot; resources: - nodes verbs: - list - watch- apiGroups: - &quot;&quot; resources: - nodes/status verbs: - patch---kind: ClusterRoleBindingapiVersion: rbac.authorization.k8s.io/v1metadata: name: flannelroleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: flannelsubjects:- kind: ServiceAccount name: flannel namespace: kube-system---apiVersion: v1kind: ServiceAccountmetadata: name: flannel namespace: kube-system---kind: ConfigMapapiVersion: v1metadata: name: kube-flannel-cfg namespace: kube-system labels: tier: node app: flanneldata: cni-conf.json: | { &quot;name&quot;: &quot;cbr0&quot;, &quot;cniVersion&quot;: &quot;0.3.1&quot;, &quot;plugins&quot;: [ { &quot;type&quot;: &quot;flannel&quot;, &quot;delegate&quot;: { &quot;hairpinMode&quot;: true, &quot;isDefaultGateway&quot;: true } }, { &quot;type&quot;: &quot;portmap&quot;, &quot;capabilities&quot;: { &quot;portMappings&quot;: true } } ] } net-conf.json: | { &quot;Network&quot;: &quot;10.244.0.0/16&quot;, &quot;Backend&quot;: { &quot;Type&quot;: &quot;vxlan&quot; } }---apiVersion: apps/v1kind: DaemonSetmetadata: name: kube-flannel-ds namespace: kube-system labels: tier: node app: flannelspec: selector: matchLabels: app: flannel template: metadata: labels: tier: node app: flannel spec: affinity: nodeAffinity: requiredDuringSchedulingIgnoredDuringExecution: nodeSelectorTerms: - matchExpressions: - key: kubernetes.io/os operator: In values: - linux hostNetwork: true priorityClassName: system-node-critical tolerations: - operator: Exists effect: NoSchedule serviceAccountName: flannel initContainers: - name: install-cni-plugin #image: flannelcni/flannel-cni-plugin:v1.1.0 for ppc64le and mips64le (dockerhub limitations may apply) image: rancher/mirrored-flannelcni-flannel-cni-plugin:v1.1.0 command: - cp args: - -f - /flannel - /opt/cni/bin/flannel volumeMounts: - name: cni-plugin mountPath: /opt/cni/bin - name: install-cni #image: flannelcni/flannel:v0.18.1 for ppc64le and mips64le (dockerhub limitations may apply) image: rancher/mirrored-flannelcni-flannel:v0.18.1 command: - cp args: - -f - /etc/kube-flannel/cni-conf.json - /etc/cni/net.d/10-flannel.conflist volumeMounts: - name: cni mountPath: /etc/cni/net.d - name: flannel-cfg mountPath: /etc/kube-flannel/ containers: - name: kube-flannel #image: flannelcni/flannel:v0.18.1 for ppc64le and mips64le (dockerhub limitations may apply) image: rancher/mirrored-flannelcni-flannel:v0.18.1 command: - /opt/bin/flanneld args: - --ip-masq - --kube-subnet-mgr resources: requests: cpu: &quot;100m&quot; memory: &quot;50Mi&quot; limits: cpu: &quot;100m&quot; memory: &quot;50Mi&quot; securityContext: privileged: false capabilities: add: [&quot;NET_ADMIN&quot;, &quot;NET_RAW&quot;] env: - name: POD_NAME valueFrom: fieldRef: fieldPath: metadata.name - name: POD_NAMESPACE valueFrom: fieldRef: fieldPath: metadata.namespace - name: EVENT_QUEUE_DEPTH value: &quot;5000&quot; volumeMounts: - name: run mountPath: /run/flannel - name: flannel-cfg mountPath: /etc/kube-flannel/ - name: xtables-lock mountPath: /run/xtables.lock volumes: - name: run hostPath: path: /run/flannel - name: cni-plugin hostPath: path: /opt/cni/bin - name: cni hostPath: path: /etc/cni/net.d - name: flannel-cfg configMap: name: kube-flannel-cfg - name: xtables-lock hostPath: path: /run/xtables.lock type: FileOrCreate5.测试 kubernetes 集群在 Kubernetes 集群中创建一个 pod，验证是否正常运行：$ kubectl create deployment nginx --image=nginx$ kubectl expose deployment nginx --port=80 --type=NodePort # NodPort需要定义,此时为本pod的ip$ kubectl get pod访问地址：http://NodeIP:Port，在master节点上此时就是 192.168.44.146:32753,其中端口需要看上面命令(get pod)给出来的暴露端口6.二进制源码搭建1.系统初始化 一台或者多台机器，操作系统centos7以上版本 硬件配置：RAM至少2GB，CPU至少2核，硬盘至少30GB 集群中所有机器之间网络互通 可以访问外网（需要拉取镜像） 进制swap分区# 关闭防火墙systemctl stop firewalldsystemctl disable firewalld# 关闭selinux, 所有节点关闭 SELinuxsetenforce 0sed -i --follow-symlinks &#39;s/SELINUX=enforcing/SELINUX=disabled/g&#39; /etc/sysconfig/selinux# 关闭swap# 同步服务器时间 (ntpdate time.windows.com),不联网可以自己设定时间，总之保持时间一致# 更改HOST文件(基于主机名通信，所以要进行IP和主机名的绑定，这个在Master机器上更改就行)vim /etc/hosts172.16.32.2 node1172.16.32.6 node2172.16.0.4 master# 每个节点分别设置对应主机名homenamectl set-homename k8s-masterhomenamectl set-homename k8s-node1homenamectl set-homename k8s-node22.签发证书# 准备cfssl工具# 自签etcd ssl证书wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64chmod +x cfssl_linux-amd64 cfssljson_linux-amd64 cfssl-certinfo_linux-amd64mv cfssl_linux-amd64 /usr/local/bin/cfsslmv cfssljson_linux-amd64 /usr/local/bin/cfssljsonmv cfssl-certinfo_linux-amd64 /usr/bin/cfssl-certinfo3.下发证书二进制包下载地址：https://github.com/etcd-io/etcd/releases# 部署etcd" }, { "title": "Docker-Compose", "url": "/posts/Docker-Compose-%E7%A9%BA/", "categories": "边缘计算", "tags": "DevOps", "date": "2022-02-16 00:00:00 +0800", "snippet": "1. Docker Compose简介​ Docker Compose是一个用来定义和运行复杂应用的Docker工具。一个使用Docker容器的应用，通常由多个容器组成。使用Docker Compose不再需要使用shell脚本来启动容器。 ​ Docker Compose 通过一个配置文件（yml文件）来管理多个Docker容器，在配置文件中，所有的容器通过services来定义，然后使用docker-compose脚本来启动，停止和重启应用，和应用中的服务以及所有依赖服务的容器，非常适合组合使用多个容器进行开发的场景。原文链接：https://blog.csdn.net/pushiqiang/article/details/78682323版本需求 Compose file format Docker Engine release Compose specification 19.03.0+ 3.8 19.03.0+ 3.7 18.06.0+ 3.6 18.02.0+ 3.5 17.12.0+ 3.4 17.09.0+ 3.3 17.06.0+ 3.2 17.04.0+ 3.1 1.13.1+ 3.0 1.13.0+ 2.4 17.12.0+ 2.3 17.06.0+ 2.2 1.13.0+ 2.1 1.12.0+ 2.0 1.10.0+ 2. 安装​ 见Ubuntu装机专栏的内容3. 使用​ 参考Nginx专栏的内容1.yml文件格式# 1. 基本语法1、yml文件以缩进代表层级关系2、缩进不允许使用tab只能使用空格3、空格的个数不重要，只要相同层级的元素左对齐即可4、大小写敏感5、数据格式为，名称:(空格)值# 数据格式1、对象：键值对的集合(key:value) 字符串不用使用双引号或单引号圈起来 双引号圈住时不会转义字符串中的特殊字符 单引号圈住时会转义字符串中的特殊字符 2、数组：一组按顺序排列的值 数组名: -元素1 -元素2 行内写法： 数组名:[元素1,元素2,元素3] 3、字面量：单个的、不可再分的值（数字、字符串、布尔值）2.docker-compose CLIDefine and run multi-container applications with Docker. # 基于Docker定义和运行多容器Usage: docker-compose [-f &amp;lt;arg&amp;gt;...] [--profile &amp;lt;name&amp;gt;...] [options] [COMMAND] [ARGS...] docker-compose -h|--helpOptions: -f, --file FILE Specify an alternate compose file # 指定运行compose文件 (default: docker-compose.yml) -p, --project-name NAME Specify an alternate project name # 指定项目名 (default: directory name) --profile NAME Specify a profile to enable --verbose Show more output --log-level LEVEL DEPRECATED and not working from 2.0 - Set log level (DEBUG, INFO, WARNING, ERROR, CRITICAL) --no-ansi Do not print ANSI control characters -v, --version Print version and exit -H, --host HOST Daemon socket to connect to --tls Use TLS; implied by --tlsverify --tlscacert CA_PATH Trust certs signed only by this CA --tlscert CLIENT_CERT_PATH Path to TLS certificate file --tlskey TLS_KEY_PATH Path to TLS key file --tlsverify Use TLS and verify the remote --skip-hostname-check Don&#39;t check the daemon&#39;s hostname against the name specified in the client certificate --project-directory PATH Specify an alternate working directory (default: the path of the Compose file) --compatibility If set, Compose will attempt to convert deploy keys in v3 files to their non-Swarm equivalentCommands: build Build or rebuild services bundle Generate a Docker bundle from the Compose file config Validate and view the Compose file create Create services down Stop and remove containers, networks, images, and volumes events Receive real time events from containers exec Execute a command in a running container help Get help on a command images List images kill Kill containers logs View output from containers pause Pause services port Print the public port for a port binding ps List containers pull Pull service images push Push service images restart Restart services rm Remove stopped containers run Run a one-off command scale Set number of containers for a service start Start services stop Stop services top Display the running processes unpause Unpause services up Create and start containers version Show the Docker-Compose version information常用命令docker-compose up -d # 后台运行,拉起服务dokcer-compose down # 停止服务，并移除容器、网络、镜像和挂载卷docker-compose version # 查看版本docker-compose start [服务名] # 启动服务docker-compose stop [服务名] # 停止服务docker-compose top # 查看运行的进程docker-compose logs [服务名] # 查看日志3.环境变量​ 和docker一样，docker-compose环境变量写在同目录下的.env文件中。也可以写在别的目录中，启动时候通过--env-file指定路径，一般写在同一目录下。在docker-compose.yml文件中通过${变量名}引用变量。.envTAG=v1.5docker-compose.ymlversion:&#39;3&#39;services: web: images:&quot;webapp:${TAG}&quot;$ docker configversion:&#39;3&#39;services: web: images:&quot;webapp:v1.5&quot;" }, { "title": "Docker基础", "url": "/posts/docker%E5%9F%BA%E7%A1%80/", "categories": "边缘计算", "tags": "DevOps", "date": "2022-02-15 00:00:00 +0800", "snippet": "本文主要对docker的基础知识进行介绍，了解docker的镜像、容器和仓库。1.镜像docker的镜像实由一层一层的文件系统组成，这种层级的文件系统采用联合文件系统编写（UnionFS)，优点：共享资源。即有多个镜像从相同的base镜像构建而来，那么宿主机上只需要在磁盘上保存一份base镜像，同时内存中只需要加载一份base镜像，就可以为所有容器提供服务了，且镜像的每一层都能被共享。bootfs(boot files system)​ 主要包含bootloader和kernel，bootloader主要是引导加载kernel。Linux刚启动会加载bootfs文件系统，在docker镜像的最底层就是bootfs。这一层与典型的Linux/Unix系统一样的，包含boot加载器和内核。当boot加载完成后，整个内核就在内存当中，此时内存的使用权由bootfs转交为内核，然后系统也会卸载bootfs。典型的Linux启动到运行需要两个FS - bootfs + rootfs (从功能角度而非文件系统角度)rootfs​ rootfs（(root file system) ）在bootfs之上，包含的就是典型的Linux系统中的/dev,/proc,/bin,/ect等标准目录和文件。rootfs就是不同操作系统的发行版，比如Ubuntu，CentOS等等。​ 典型的Linux在启动后，首先将 rootfs 置为 readonly, 进行一系列检查, 然后将其切换为 “readwrite” 供用户使用。在docker中，起初也是将 rootfs 以readonly方式加载并检查，然而接下来利用 union mount 的将一个 readwrite 文件系统挂载在 readonly 的rootfs之上，并且允许再次将下层的 file system设定为readonly 并且向上叠加, 这样一组readonly和一个writeable的结构构成一个container的运行目录, 每一个被称作一个Layer。（图 [1,2]）   参考 ：https://baike.baidu.com/item/Docker/13344470?fr=aladdin2.镜像命令Docker中与镜像操作相关的命令都在docker image这条子命令下，通过docker image –help这条命令，可以看到docker image子命令的详细文档，如下：Usage: docker image COMMANDManage imagesCommands: build Build an image from a Dockerfile(构建镜像的命令) history Show the history of an image(显示镜像构建历史过程) import Import the contents from a tarball to create a filesystem image(导入一个由容器导出的镜像) inspect Display detailed information on one or more images(显示一个镜像的详细信息) load Load an image from a tar archive or STDIN(从一个文件或标准输入流中导入镜像) ls List images(查看镜像列表) prune Remove unused images(删除虚悬镜像) pull Pull an image or a repository from a registry(从仓库拉取镜像) push Push an image or a repository to a registry(推送镜像到仓库) rm Remove one or more images(删除镜像) save Save one or more images to a tar archive (streamed to STDOUT by default)(保存镜像到文件) tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE(给镜像打标签)1.构建镜像构建镜像方式： 从官方仓库或其他镜像仓库拉取别人构建好的镜像 构建自己的镜像 【1. commit方法 2.dockerfile方法（推荐）】 # 拉取镜像# 下载最新版本(base) zhengkan03@ubuntu:~/桌面$ docker pull mysqlUsing default tag: latestlatest: Pulling from library/mysql69692152171a: Pull complete # 分层下载1651b0be3df3: Pull complete 951da7386bc8: Pull complete 0f86c95aa242: Pull complete 37ba2d8bd4fe: Pull complete 6d278bb05e94: Pull complete 497efbd93a3e: Pull complete f7fddf10c2c2: Pull complete 16415d159dfb: Pull complete 0e530ffc6b73: Pull complete b0a4a1a77178: Pull complete cd90f92aa9ef: Pull complete Digest: sha256:d50098d7fcb25b1fcb24e2d3247cae3fc55815d64fec640dc395840f8fa80969Status: Downloaded newer image for mysql:latestdocker.io/library/mysql:latest# 等价# docker pull mysql # docker pull docker.io/library/mysql:latest# 下载指定版本# docker pull 镜像名[:版本号]# docker pull mysql:5.7# 构建镜像# 1. commit方法# 使用docker commit命令，我们可以将修改过的容器重新提交为一个镜像，如：$ docker commit [容器ID] [新生成的文件名]$ docker commit conntaner_id my-hello:1.0$ docker commit -m=&#39;要提交的信息&#39; -a=&#39;作者&#39; 容器ID 要创建的目标镜像名：版本号一般推荐编写Dockerfile来构建一种镜像，Docker Hub上的镜像都是采用这种方式构建的.好处:我们不用把镜像分发给别人，而只是把Dockerfile和相应需要写入镜像的资料发给别人，别人也能自己构建镜像，安全透明1. 构建步骤 编写一个dockerfile文件 docker build 构建成为一个镜像 docker run 运行镜像 docker push 发布镜像（dockerHub,阿里云）2. Dockerfile指令FROM # 基础镜像，一切从这里开始MAINTIANER # 镜像是谁编写的，姓名+邮箱RUN # 镜像构建时候需要运行的命令ADD # 步骤，tomcat镜像，添加内容WORKDIR # 镜像的工作目录VOLUME # 挂载的目录EXPOSE # 暴露对外端口CMD # 指定这个容器的启动时候的命令 ,只有最后一个会生效ENTRYPOINT # 指定 容器启动时候要运行的命令，可以追加命令ONBUILD # 当构建一个被继承Dockerfile，这个时候就会运行ONBUILDCOPY # 类似ADD ,将文件拷贝到镜像中ENV # 构建的时候设置环境变量Dockerfile文件# 1.构建镜像文件FROM ubuntuMAINTAINER ZhengRUN apt-get updateRUN apt-get install -y python3RUN apt-get install -y python3-pipRUN apt-get install -y vimRUN pip3 install FlaskRUN mkdir appADD . /appWORKDIR /app/appCMD [&quot;python3&quot;,&quot;flask01.py&quot;]开始构建镜像编写好Dockerfile文件后，需要使用docker build命令进行构建，docker build命令的格式如下：# 2. 通过这个文件创建镜像#命令 docker build -f dockerfile文件路径 -t 镜像名:版本号docker build -f Dockerfile myapp:1.0测试运行刚创建的镜像# 3.测试运行docker run -it mycentos：1.0# 可以使用docker inspect 镜像名 来查看镜像构建历史3.CMD与ENTRYPOINT# ENTRYPOINT 两种写法ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] # 这是 exec 模式的写法，注意需要使用双引号ENTRYPOINT command param1 param2 # 这是 shell 模式的写法1. 配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖。2. 每个 Dockerfile 中只能有一个 ENTRYPOINT，当指定多个时，只有最后一个起效。# CMD 三种写法CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] # 使用 exec 执行，推荐方式；CMD command param1 param2 # 在 /bin/sh 中执行，提供给需要交互的应用；CMD [&quot;param1&quot;,&quot;param2&quot;] # 提供给 ENTRYPOINT 的默认参数；1. 每个 Dockerfile 只能有一条 CMD 命令。如果指定了多条命令，只有最后一条会被执行。2. 如果用户启动容器时候指定了运行的命令，则会覆盖掉 CMD 指定的命令。举例说明，参考链接： https://www.cnblogs.com/lienhua34/p/5170335.html从上面的说明，我们可以看到有两个共同点： 都可以指定shell或exec函数调用的方式执行命令； 当存在多个CMD指令或ENTRYPOINT指令时，只有最后一个生效；而它们有如下差异： CMD ENTRYPOINT 容器启动时命令可以被docker run指定的命令覆盖 docker run指定的参数当做ENTRYPOINT指定命令的参数 可以为ENTRYPOINT指令设置默认参数 参数可以由CMD提供 3.1 差异1/diff1_folder|--- startup.sh|--- Dockerfilestartup.sh#!/bin/bashecho &quot;in startup, args: $@&quot;DockerfileFROM ubuntu:14.04MAINTAINER lienhua34@xxx.comADD startup /optRUN chmod a+x /opt/startupCMD [&quot;/opt/startup&quot;]# 使用docker build 创建镜像sudo docker build -t test ....Successfully built 18a2d5066346# 用docker run启动两个test:latest镜像的容器# 第一个docker run命令没有指定容器启动时命令# 第二个docker run命令指定了容器启动时的命令为 /bin/bash -c &#39;echo Hello&#39;lienhua34@test$ sudo docker run -ti --rm=true testin startup, args: lienhua34@test$ sudo docker run -ti --rm=true test /bin/bash -c &#39;echo Hello&#39;Hello#可以看出， docker run命令启动容器时,指定的运行命令覆盖了Dockerfile文件中CMD指令指定的命令开始对比，同样的手法对于ENTRYPOINT/diff1_folder|--- startup.sh|--- Dockerfilestartup.sh与上相同DockerfileFROM ubuntu:14.04MAINTAINER lienhua34@xxx.comADD startup /optRUN chmod a+x /opt/startupENTRYPOINT [“/opt/startup”]# 使用docker build 创建镜像sudo docker build -t test ....Successfully built 78f8aca2edc2# 用docker run启动两个test:latest镜像的容器# 第一个docker run命令没有指定容器启动时命令# 第二个docker run命令指定了容器启动时的命令为 /bin/bash -c &#39;echo Hello&#39; lienhua34@test$ sudo docker run -ti --rm=true testin startup, args: lienhua34@test$ sudo docker run -ti --rm=true test /bin/bash -c &#39;echo Hello&#39;in startup, args: /bin/bash -c echo Hello# 可以看出，docker run命令指定的容器运行命令不能覆盖Dockerfile文件中ENTRYPOINT指令指定的命令，反而被当做参数传递给ENTRYPOINT指令指定的命令3.2 差异2/diff2_folder|--- startup.sh|--- Dockerfilestartup.sh#!/bin/bashecho &quot;in startup, args: $@&quot;DockerfileFROM ubuntu:14.04MAINTAINER lienhua34@xxx.com ADD startup /optRUN chmod a+x /opt/startupENTRYPOINT [&quot;/opt/startup&quot;, &quot;arg1&quot;]CMD [&quot;arg2&quot;]lienhua34@test$ sudo docker build -t test ....Successfully built 4684ba457cc2# docker run启动两个test:latest镜像的容器# 第一条docker run命令没有指定参数# 第二条docker run命令指定了参数arg3，其运行结果如下lienhua34@test$ sudo docker run -ti --rm=true testin startup, args: arg1 arg2lienhua34@test$ sudo docker run -ti --rm=true test arg3in startup, args: arg1 arg3# 可以看出,CMD指令为ENTRYPOINT指令设置了默认参数；从第二个容器的运行结果看出，docker run命令指定的参数覆盖了CMD指令指定的参数(arg3覆盖了arg2) Dockerfile中出现ENTRYPOINT，则该ENTRYPOINT就是该容器启动命令；如果没有ENTRYPOINT，则CMD后面内容为容器启动命令； 一个Dockerfile中必须有一个CMD或者ENTRYPOINT 如果两者同时出现，CMD后面的内容为ENTRYPOINT的参数，且该内容可以被docker run后面的内容覆盖 如果出现多个CMD或者ENTRYPOINT,则前面的CMD被最后一个CMD覆盖；前面的ENTRYPOINT被最后一个ENTRYPOINT覆盖2.删除镜像镜像在被运行后，就形成了容器；一般如果镜像已经被使用来创建容器，使用docker rmi命令来删除镜像会报下面的错误，告诉我们该镜像已经被使用，不允许删除。Error response from daemon: conflict: unable to remove repository reference &quot;mysql:5.7&quot; (must force) - container ccd406c07a78 is using its referenced image e1e1680ac726对于已经被用于创建容器的镜像，删除方法有两种# 一种是先把容器删除，再删除镜像【推荐】# 另一种则只需要在删除镜像的命令中跟一个-f参数便可，如：# docker rmi 镜像名docker rmi 镜像iddocker rmi -f 镜像id # 强制删除镜像docker rmi -f $(docker ps -aq) # 删除所有镜像3.拉取镜像官方的https://hub.docker.com/提供了数十万个镜像提供大家下载，以拉取个人公有centos7.3镜像为例：# docker pull 用户/仓库：标签docker pull kennyyaohong/public:centos7.34.镜像推送# 第一步 打标签 docker tag 镜像id 要推入仓库的用户名/要推入的仓库名:新定义的tag docker tag e12a9ec48ab7 kennyyaohong/public:myproject_centos7.3# 第二步 推送 docker push 要推入仓库的用户名/要推入的仓库名:镜像标签docker push kennyyaohong/public:myproject_centos7.33. 容器命令容器(Container)与镜像的关系，就如同面向编程中对象与类之间的关系。因为容器是通过镜像来创建的，所以必须先有镜像才能创建容器，而生成的容器是一个独立于宿主机的隔离进程，并且有属于容器自己的网络和命名空间。镜像由多个中间层(layer)组成，生成的镜像是只读的，但容器却是可读可写的，这是因为容器是在镜像上面添一层读写层(writer/read layer)来实现的。Usage: docker container COMMANDManage containersCommands: attach Attach local standard input, output, and error streams to a running container commit Create a new image from a container&#39;s changes(把容器保存为镜像) cp Copy files/folders between a container and the local filesystem create Create a new container(创建一个新的容器) diff Inspect changes to files or directories on a container&#39;s filesyste m exec Run a command in a running container(在一个运行的容器中执行命令) export Export a container&#39;s filesystem as a tar archive inspect Display detailed information on one or more containers kill Kill one or more running containers(杀死一个或多个正在运行的容器) logs Fetch the logs of a container ls List containers(显示本地容器列表) pause Pause all processes within one or more containers port List port mappings or a specific mapping for the container prune Remove all stopped containers rename Rename a container(重命名容器) restart Restart one or more containers(重启一个或多个容器) rm Remove one or more containers(删除一个或多个容器) run Run a command in a new container(运行一个新的容器) start Start one or more stopped containers stats Display a live stream of container(s) resource usage statistics stop Stop one or more running containers(停止一个或多个容器) top Display the running processes of a container unpause Unpause all processes within one or more containers update Update configuration of one or more containers wait Block until one or more containers stop, then print their exit codes1.启动/停止容器# 通过镜像创建容器，指定容器name # -i interactive -t persu ttydocker run -it --name myu1 ubuntu # 启动/停止容器docker start 容器iddocker restart 容器iddocker stop 容器iddocker kill 容器id # 强制停止当前容器2.进入容器# 进入容器docker exec -it 容器id /bin/bash# 示例zhengkan03@ubuntu:~/桌面$ docker exec -it ffbdccd23b40 /bin/bashroot@ffbdccd23b40:/app# lsdata Dockerfile LSTM.py __pycache__ README.md requirements.txt static templates WindPlatform.py# 进入容器docker attach# 区别docker exec # 进入容器后开启一个新的终端docker attach # 进入容器正在执行的终端，不会启动新的进程3.退出容器exit # 直接容器停止并退出CTRL + P + Q # 容器不停止，退出4.删除容器docker rm 容器id # 删除指定容器 ，不能删除正在运行的容器docker rm -f $(docker ps -aq) # 删除所有容器(强制)5.查看容器# 查看日志docker logs docker logs -tf -tail n 容器id # 查看最后n条日志 -t 显示时间戳 -f 跟随时间戳# 示例zhengkan03@ubuntu:~/桌面$ docker logs -tf --tail 10 26b6aea91aaa2021-06-22T07:48:50.905093443Z 2021-06-22T07:48:50.905095407Z To try something more ambitious, you can run an Ubuntu container with:2021-06-22T07:48:50.905097543Z $ docker run -it ubuntu bash2021-06-22T07:48:50.905099590Z 2021-06-22T07:48:50.905101646Z Share images, automate workflows, and more with a free Docker ID:2021-06-22T07:48:50.905103754Z https://hub.docker.com/2021-06-22T07:48:50.905105835Z 2021-06-22T07:48:50.905107823Z For more examples and ideas, visit:2021-06-22T07:48:50.905109929Z https://docs.docker.com/get-started/2021-06-22T07:48:50.905112002Z # 查看进程信息docker top 容器id# 示例hengkan03@ubuntu:~/桌面$ docker top ffbdccd23b40UID PID PPID C STIME TTY root 4003 3981 1 16:02 ? root 4048 4003 2 16:02 ? # 查看容器元数据docker inspect 容器id# 示例zhengkan03@ubuntu:~/桌面$ docker inspect ffbdccd23b40[ { &quot;Id&quot;: &quot;ffbdccd23b400f0e42060189c76b8497b6b97911c1bd98937d57417ea7751496&quot;, &quot;Created&quot;: &quot;2021-06-22T08:02:15.072353163Z&quot;, &quot;Path&quot;: &quot;python3&quot;, &quot;Args&quot;: [ &quot;WindPlatform.py&quot; ], &quot;State&quot;: { &quot;Status&quot;: &quot;running&quot;, &quot;Running&quot;: true, &quot;Paused&quot;: false, &quot;Restarting&quot;: false, &quot;OOMKilled&quot;: false, &quot;Dead&quot;: false, &quot;Pid&quot;: 4003, &quot;ExitCode&quot;: 0, &quot;Error&quot;: &quot;&quot;, &quot;StartedAt&quot;: &quot;2021-06-22T08:02:15.329542854Z&quot;, &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot; }, &quot;Image&quot;: &quot;sha256:fa7b17d27d4a5dffbfef573effc6c11f8e08050df1d5479d58196a9d3e57e3e4&quot;, &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/ffbdccd23b400f0e42060189c76b8497b6b97911c1bd98937d57417ea7751496/resolv.conf&quot;, &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/ffbdccd23b400f0e42060189c76b8497b6b97911c1bd98937d57417ea7751496/hostname&quot;, &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/ffbdccd23b400f0e42060189c76b8497b6b97911c1bd98937d57417ea7751496/hosts&quot;, &quot;LogPath&quot;: &quot;/var/lib/docker/containers/ffbdccd23b400f0e42060189c76b8497b6b97911c1bd98937d57417ea7751496/ffbdccd23b400f0e42060189c76b8497b6b97911c1bd98937d57417ea7751496-json.log&quot;, &quot;Name&quot;: &quot;/nifty_euclid&quot;, &quot;RestartCount&quot;: 0, &quot;Driver&quot;: &quot;overlay2&quot;, &quot;Platform&quot;: &quot;linux&quot;, &quot;MountLabel&quot;: &quot;&quot;, &quot;ProcessLabel&quot;: &quot;&quot;, &quot;AppArmorProfile&quot;: &quot;docker-default&quot;, &quot;ExecIDs&quot;: null, &quot;HostConfig&quot;: { &quot;Binds&quot;: null, &quot;ContainerIDFile&quot;: &quot;&quot;, &quot;LogConfig&quot;: { &quot;Type&quot;: &quot;json-file&quot;, &quot;Config&quot;: {} }, &quot;NetworkMode&quot;: &quot;default&quot;, &quot;PortBindings&quot;: {}, &quot;RestartPolicy&quot;: { &quot;Name&quot;: &quot;no&quot;, &quot;MaximumRetryCount&quot;: 0 }, &quot;AutoRemove&quot;: false, &quot;VolumeDriver&quot;: &quot;&quot;, &quot;VolumesFrom&quot;: null, &quot;CapAdd&quot;: null, &quot;CapDrop&quot;: null, &quot;CgroupnsMode&quot;: &quot;host&quot;, &quot;Dns&quot;: [], &quot;DnsOptions&quot;: [], &quot;DnsSearch&quot;: [], &quot;ExtraHosts&quot;: null, &quot;GroupAdd&quot;: null, &quot;IpcMode&quot;: &quot;private&quot;, &quot;Cgroup&quot;: &quot;&quot;, &quot;Links&quot;: null, &quot;OomScoreAdj&quot;: 0, &quot;PidMode&quot;: &quot;&quot;, &quot;Privileged&quot;: false, &quot;PublishAllPorts&quot;: false, &quot;ReadonlyRootfs&quot;: false, &quot;SecurityOpt&quot;: null, &quot;UTSMode&quot;: &quot;&quot;, &quot;UsernsMode&quot;: &quot;&quot;, &quot;ShmSize&quot;: 67108864, &quot;Runtime&quot;: &quot;runc&quot;, &quot;ConsoleSize&quot;: [ 0, 0 ], &quot;Isolation&quot;: &quot;&quot;, &quot;CpuShares&quot;: 0, &quot;Memory&quot;: 0, &quot;NanoCpus&quot;: 0, &quot;CgroupParent&quot;: &quot;&quot;, &quot;BlkioWeight&quot;: 0, &quot;BlkioWeightDevice&quot;: [], &quot;BlkioDeviceReadBps&quot;: null, &quot;BlkioDeviceWriteBps&quot;: null, &quot;BlkioDeviceReadIOps&quot;: null, &quot;BlkioDeviceWriteIOps&quot;: null, &quot;CpuPeriod&quot;: 0, &quot;CpuQuota&quot;: 0, &quot;CpuRealtimePeriod&quot;: 0, &quot;CpuRealtimeRuntime&quot;: 0, &quot;CpusetCpus&quot;: &quot;&quot;, &quot;CpusetMems&quot;: &quot;&quot;, &quot;Devices&quot;: [], &quot;DeviceCgroupRules&quot;: null, &quot;DeviceRequests&quot;: null, &quot;KernelMemory&quot;: 0, &quot;KernelMemoryTCP&quot;: 0, &quot;MemoryReservation&quot;: 0, &quot;MemorySwap&quot;: 0, &quot;MemorySwappiness&quot;: null, &quot;OomKillDisable&quot;: false, &quot;PidsLimit&quot;: null, &quot;Ulimits&quot;: null, &quot;CpuCount&quot;: 0, &quot;CpuPercent&quot;: 0, &quot;IOMaximumIOps&quot;: 0, &quot;IOMaximumBandwidth&quot;: 0, &quot;MaskedPaths&quot;: [ &quot;/proc/asound&quot;, &quot;/proc/acpi&quot;, &quot;/proc/kcore&quot;, &quot;/proc/keys&quot;, &quot;/proc/latency_stats&quot;, &quot;/proc/timer_list&quot;, &quot;/proc/timer_stats&quot;, &quot;/proc/sched_debug&quot;, &quot;/proc/scsi&quot;, &quot;/sys/firmware&quot; ], &quot;ReadonlyPaths&quot;: [ &quot;/proc/bus&quot;, &quot;/proc/fs&quot;, &quot;/proc/irq&quot;, &quot;/proc/sys&quot;, &quot;/proc/sysrq-trigger&quot; ] }, &quot;GraphDriver&quot;: { &quot;Data&quot;: { &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/683812c5b66d7ff4a6efc7479adf1d1dd69ef966d721104cb240fc810d023f7d-init/diff:/var/lib/docker/overlay2/17a7729fae872dc47beaddd86c02f5a95d1c8b17525e49e9457ff52e126dfc17/diff:/var/lib/docker/overlay2/fa10d11839ed464f0bd78ba5d9cb8fef8212e391876569631c0c04a59aa6e3e3/diff:/var/lib/docker/overlay2/b3c96094f9204af39890d1b8101278a98d7cc6c9c96e76c8fa2efb19d6181a0b/diff:/var/lib/docker/overlay2/c8fe8f5fd4e56531f6452da6ad5e8d300f2b48042a0c72a18fe4e11b3a369aec/diff:/var/lib/docker/overlay2/d28d47c24554c918e4814ef21087b7b334d6b02055c22a690714d9fe905d2407/diff:/var/lib/docker/overlay2/7343c35e91fb791e62ec43253c0ae1705b54dbe72ab65b1361e3a33f7bea1610/diff:/var/lib/docker/overlay2/1ff46c566494d2451a35636d7b28461d0ea2f2c2dd2af2920de52ee25ba53529/diff:/var/lib/docker/overlay2/e736e69f6bb2b87efb5ff8d693c4fd37d887502a06a5b9fabff96ad8153c7f9c/diff:/var/lib/docker/overlay2/18a19eee18a38481e0db17be63f675b6edddba3c72f6ec3ea99b2446b44198c8/diff:/var/lib/docker/overlay2/1cab6ed396a099774fbf46013adbb04aae80e173af01b08bbaebd4330ee5417e/diff:/var/lib/docker/overlay2/0a990a330b637a03878dece926106670d67a6848220433163e8b614e26a4d5fe/diff:/var/lib/docker/overlay2/dcb2bdf25e93fc854e9f20db7af8a15d8121591d0fdc4adf6fd3897c6ad42794/diff:/var/lib/docker/overlay2/32ff4d2f742d16b700a2e71d3e6c4508a976046869a472e52fb7057e2bab2f6c/diff:/var/lib/docker/overlay2/09f6a5b7a03f34cd7ddd7fab9ba8fe9aa3ddf9e232fabf3c54fc8602d80a2f1f/diff&quot;, &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/683812c5b66d7ff4a6efc7479adf1d1dd69ef966d721104cb240fc810d023f7d/merged&quot;, &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/683812c5b66d7ff4a6efc7479adf1d1dd69ef966d721104cb240fc810d023f7d/diff&quot;, &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/683812c5b66d7ff4a6efc7479adf1d1dd69ef966d721104cb240fc810d023f7d/work&quot; }, &quot;Name&quot;: &quot;overlay2&quot; }, &quot;Mounts&quot;: [ { &quot;Type&quot;: &quot;volume&quot;, &quot;Name&quot;: &quot;506ba62d402f692daf45dad5a846cff4e553a710f541e78949466e0e92325ea9&quot;, &quot;Source&quot;: &quot;/var/lib/docker/volumes/506ba62d402f692daf45dad5a846cff4e553a710f541e78949466e0e92325ea9/_data&quot;, &quot;Destination&quot;: &quot;/sys/fs/cgroup&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Mode&quot;: &quot;&quot;, &quot;RW&quot;: true, &quot;Propagation&quot;: &quot;&quot; } ], &quot;Config&quot;: { &quot;Hostname&quot;: &quot;ffbdccd23b40&quot;, &quot;Domainname&quot;: &quot;&quot;, &quot;User&quot;: &quot;&quot;, &quot;AttachStdin&quot;: false, &quot;AttachStdout&quot;: false, &quot;AttachStderr&quot;: false, &quot;Tty&quot;: false, &quot;OpenStdin&quot;: false, &quot;StdinOnce&quot;: false, &quot;Env&quot;: [ &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;, &quot;container=docker&quot;, &quot;DEBIAN_FRONTEND=noninteractive&quot;, &quot;LANG=en_US.UTF-8&quot;, &quot;LANGUAGE=en_US:en&quot;, &quot;LC_ALL=en_US.UTF-8&quot; ], &quot;Cmd&quot;: [ &quot;python3&quot;, &quot;WindPlatform.py&quot; ], &quot;Image&quot;: &quot;fa7b17d27d4a&quot;, &quot;Volumes&quot;: { &quot;/sys/fs/cgroup&quot;: {} }, &quot;WorkingDir&quot;: &quot;/app&quot;, &quot;Entrypoint&quot;: null, &quot;OnBuild&quot;: null, &quot;Labels&quot;: {} }, &quot;NetworkSettings&quot;: { &quot;Bridge&quot;: &quot;&quot;, &quot;SandboxID&quot;: &quot;5f09b2026536f58852715967f0f1487828195533aa71896838e9074634e2a403&quot;, &quot;HairpinMode&quot;: false, &quot;LinkLocalIPv6Address&quot;: &quot;&quot;, &quot;LinkLocalIPv6PrefixLen&quot;: 0, &quot;Ports&quot;: {}, &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/5f09b2026536&quot;, &quot;SecondaryIPAddresses&quot;: null, &quot;SecondaryIPv6Addresses&quot;: null, &quot;EndpointID&quot;: &quot;d88f24d5ea6a94c7a9ee0359d7bd829cf66e4dc70ebe7d827b709a8c0a836dd2&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;IPAddress&quot;: &quot;172.17.0.2&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;, &quot;Networks&quot;: { &quot;bridge&quot;: { &quot;IPAMConfig&quot;: null, &quot;Links&quot;: null, &quot;Aliases&quot;: null, &quot;NetworkID&quot;: &quot;8f3b1769f0151de1a0edac3bf15a02e0828f2ea16919098ec4cdfd43f0f90ad4&quot;, &quot;EndpointID&quot;: &quot;d88f24d5ea6a94c7a9ee0359d7bd829cf66e4dc70ebe7d827b709a8c0a836dd2&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot;, &quot;IPAddress&quot;: &quot;172.17.0.2&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;, &quot;DriverOpts&quot;: null } } } }]6.容器文件交互# 容器内文件拷贝到主机 docker cp 容器id:路径 宿主机路径# 示例zhengkan03@ubuntu:~/桌面$ docker cp ffbdccd23b40:/app/ /home/zhengkan03/Desktop/7.容器数据卷docker的理念： 将应用和环境打包为一个镜像！数据如果保存在容器中，那么容器被删除，数据就会丢失。所以，需要数据的持久化，并保存到本地。这样即便出现删库跑路的情况，数据库中的数据仍能保存到本地。# 方式一：直接使用-v数据挂载 # 功能是实现双向绑定:容器内部添加文件，可同步到主机;主机指定文件夹下添加文件可同步到容器内;docker run -it -v 宿主机目录:容器内路径# 匿名挂载docker run -d -P --name nginx01 -v /etc/nginx nginx-v 容器内路径 # 匿名挂载，不建议使用# 具名挂载-v 卷名:容器内路径 -v 宿主机路径:容器内路径 # 指定路径挂载# 通过 -v 容器内路径：ro rw 改变读写权限 ，设置后只能通过宿主机操作，不能容器内操作，默认可读可写ro readonly # 容器内部只读rw readwrite # 容器内部可读可写docker run -d -P --name nginx02 -v jumping-nginx:/etc/nginx:/etc/nginx:ro nginxdocker run -d -P --name nginx02 -v jumping-nginx:/etc/nginx:/etc/nginx:rw nginx# 启动后可以通过docker inspect 容器id 查看挂载-&amp;gt;Mount# 方式二： 通过dockerfile中的VOLUME挂载创建本地数据卷本地数据卷默认路径是在 /var/lib/docker/volumes/ 下# 创建本地数据卷docker volume create my-vol# 列出本地数据卷docker volume lsDRIVER VOLUME NAMElocal my-vol# 查看本地数据卷docker volume inspect my-vol[ { &quot;CreatedAt&quot;: &quot;2022-02-17T09:18:01+08:00&quot;, &quot;Driver&quot;: &quot;local&quot;, &quot;Labels&quot;: {}, &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;, &quot;Name&quot;: &quot;my-vol&quot;, &quot;Options&quot;: {}, &quot;Scope&quot;: &quot;local&quot; }]# 删除本地数据卷docker volume rm my-volDokcerfile中的VOLUMEFROM centosVOLUME [&quot;volume1&quot;,&quot;volume2&quot;] # 这个地方进行匿名挂载,多个数据卷必须使用双引号分割CMD echo &quot;--end--&quot;CMD /bin/bashzhengkan@station-ThinkStation-P340:~$ docker run -it 17e4 bashroot@70e127257ef8:/# lsbin dev home lib32 libx32 mnt proc run srv tmp var volume2boot etc lib lib64 media opt root sbin sys usr volume1 # 出现创建的两个数据卷volume1 和 volume2root@station-ThinkStation-P340:/var/lib/docker/volumes# ls19abfa4ee65418e8a78ee144bb582eccf026ca14c0c52cf3b88bec777cd58e6f backingFsBlockDev1c4bf795cb696fe0de894c5164adf8a93ae96b9ae1aa9bcd59599a19be88ff84 metadata.db# 进入/var/lib/docker/volumes,可见对应volume1和volume2的两个数据卷# 每个卷中有个_data 文件夹与volume1、volume2中的内容对应此时在容器内部会创建volume1和volume2两个卷（文件夹），同时在宿主机的/var/lib/docker/volumes/下会有随机生成的数据卷（文件夹）与volume1和volume2对应绑定；当修改任意一个数据卷中的内容时，其对应数据卷中的内容也会发生更改在创建项目时，通常需要用到具名挂载，方便宿主机的数据查找和应用，这个就需要用到docker-compose中的数据挂载了，详见docker-compose部分4.Docker网络1.docker0网卡Docker使用Linux桥接，在宿主机虚拟一个Docker网桥(docker0)，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP。同时Docker网桥是每个容器的默认网关，因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。root@station-ThinkStation-P340:~# ip addr1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: eno1: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether d8:bb:c1:7b:4f:3e brd ff:ff:ff:ff:ff:ff altname enp0s31f6 inet 192.168.31.65/24 brd 192.168.31.255 scope global dynamic noprefixroute eno1 valid_lft 33609sec preferred_lft 33609sec inet6 fe80::bc7:f2c9:9736:8be5/64 scope link noprefixroute valid_lft forever preferred_lft forever3: docker0: &amp;lt;NO-CARRIER,BROADCAST,MULTICAST,UP&amp;gt; mtu 1500 qdisc noqueue state DOWN group default link/ether 02:42:b2:72:14:f2 brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever inet6 fe80::42:b2ff:fe72:14f2/64 scope link valid_lft forever preferred_lft forever在每台装有docker的机器上，会有一张docker0的网卡，并且自动创建三个网络；docker内置的这三个网络可以在运行容器时，指定容器连接到那个网络；root@station-ThinkStation-P340:~# docker network lsNETWORK ID NAME DRIVER SCOPE88d2242caf7b bridge bridge localdb2e9c36669e host host local7016f0320535 none null local# 指定连接网络docker run --network=选项指定root@station-ThinkStation-P340:~# docker run -it --network=host ubuntu2.容器通讯Docker网桥是宿主机虚拟出来的，并不是真实存在的网络设备，外部网络是无法寻址到的，这也意味着外部网络无法通过直接Container-IP访问到容器。如果容器希望外部访问能够访问到，可以通过映射容器端口到宿主主机（端口映射），即docker run创建容器时候通过 -p 或 -P 参数来启用，访问容器的时候就通过[宿主机IP]:[容器端口]访问容器。3.网络模式 Docker 网络模式 配置 说明 Host – net = host 容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口 Container – net = container 创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围。 None – net = none 该模式关闭了容器的网络功能 Bridge – net= bridge 此模式会为每一个容器分配、设置IP等，并将容器连接到一个docker0虚拟网桥，通过docker0网桥以及Iptables nat表配置与宿主机通信 【默认是就是该模式】 Host模式如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。使用host模式的容器可以直接使用宿主机的IP地址与外界通信，容器内部的服务端口也可以使用宿主机的端口，不需要进行NAT，host最大的优势就是网络性能比较好。但是docker host上已经使用的端口就不能再用了，网络的隔离性不好。Container模式这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。None模式使用none模式，Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。也就是说，这个Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。这种网络模式下容器只有lo回环网络，没有其他网卡。none模式可以在容器创建时通过–network=none来指定。这种类型的网络没有办法联网，封闭的网络能很好的保证容器的安全性。Bridge模式当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。在主机上创建一对虚拟网卡veth pair设备，Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0（容器的网卡），另一端放在主机中，以vethxxx这样类似的名字命名，并将这个网络设备加入到docker0网桥中。可以通过brctl show命令查看。bridge模式是docker的默认网络模式，不写–net参数，就是bridge模式。使用docker run -p时，docker实际是在iptables做了DNAT(目的地址转换)规则，实现端口转发功能。可以使用iptables -t nat -vnL查看。docker network inspect bridge[ { &quot;Name&quot;: &quot;bridge&quot;, &quot;Id&quot;: &quot;88d2242caf7b6af84d1d0aa2415d730f01637c52ef5fb8ca4d3916e1374f0147&quot;, &quot;Created&quot;: &quot;2022-02-17T11:10:04.698146145+08:00&quot;, &quot;Scope&quot;: &quot;local&quot;, &quot;Driver&quot;: &quot;bridge&quot;, &quot;EnableIPv6&quot;: false, &quot;IPAM&quot;: { &quot;Driver&quot;: &quot;default&quot;, &quot;Options&quot;: null, &quot;Config&quot;: [ { &quot;Subnet&quot;: &quot;172.17.0.0/16&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot; } ] }, &quot;Internal&quot;: false, &quot;Attachable&quot;: false, &quot;Ingress&quot;: false, &quot;ConfigFrom&quot;: { &quot;Network&quot;: &quot;&quot; }, &quot;ConfigOnly&quot;: false, &quot;Containers&quot;: {}, &quot;Options&quot;: { &quot;com.docker.network.bridge.default_bridge&quot;: &quot;true&quot;, &quot;com.docker.network.bridge.enable_icc&quot;: &quot;true&quot;, &quot;com.docker.network.bridge.enable_ip_masquerade&quot;: &quot;true&quot;, &quot;com.docker.network.bridge.host_binding_ipv4&quot;: &quot;0.0.0.0&quot;, &quot;com.docker.network.bridge.name&quot;: &quot;docker0&quot;, &quot;com.docker.network.driver.mtu&quot;: &quot;1500&quot; }, &quot;Labels&quot;: {} }]本节只是介绍了docker容器的4种网络模式，这些都是在创建容器的时候指定的，即通过docker命令行来执行，为了容器的编排与管理，后面会讲解docker-compose的内容，涉及到在文件中指定网络模式，详情见docker-compose文档。5.docker可视化工具docker官方提供了管理工具pointainer，使用步骤如下# 1.拉取镜像docker pull portainer/portainer# 2. 创建挂载卷,docker volume create portainer_data# 3. 启动portainerdocker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce # 4.访问https://localhost:9000 即可访问和管理本机或者远端的docker参考链接 链接 docker多主机间容器通信 " }, { "title": "Nginx", "url": "/posts/Nginx/", "categories": "IT", "tags": "DevOps", "date": "2022-01-24 00:00:00 +0800", "snippet": "本文主要介绍Nginx内容，Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。它不仅是一个高性能的HTTP和反向代理服务器，同时也是一个IMAP/POP3/SMTP 代理服务器。1. 简单应用一般会在docker中拉取镜像，后运行nginx就能看到服务# 1. 拉取镜像docker pull nginx# 2. 运行nginxdocker run -d -p 80:80 nginx# 3.访问本地 https://localhost:802. 部署vue项目本小节介绍简单的部署，即能够运行页面即可1.打包移植# 在vue项目文件夹中，打包项目到dist文件夹npm run build # 将打包后的dist文件夹复制到nginx目录下，并创建Dockerfile，目录结构,nginx |--- dist |--- Dockerfile2.编写DockerfileDockerfileFROM nginx:latestMAINTAINER ZHENGCOPY dist/ /usr/share/nginx/html/3.构建镜像并运行# 在nginx的cmd下，构建镜像docker build -t test .# 生成容器docker run -p 3000:80 -d --name test mytest4.访问端口访问 https://localhost:3000，可以访问到/usr/share/nginx/html/下的静态网页。如果需要数据是动态与后端交互的，还要阅读下面的内容哦 ~3. 部署flask项目1. 配置guinicorngunicorn是一个unix上被广泛使用的高性能的Python WSGI UNIX HTTP Server。和大多数的web框架兼容，并具有实现简单，轻量级，高性能等特点。# 安装 gunicornpip install gunicorn# gunicorn配置详解# server socket# bind 监听地址和端口。bind = &#39;127.0.0.1:8000&#39; # backlog# 服务器中在pending状态的最大连接数，即client处于waiting的数目。超过这个数目， client连接会得到一个error。# 建议值64-2048。backlog = 512 #监听队列# workers# worker进程的数量。建议值2-4 x $(NUM_CORES)， 缺省为1。workers = 3# worker_class# worker进程的工作方式。 有 sync, eventlet, gevent, tornado, gthread, 缺省值sync。threads工作进程中线程的数量。建议值2-4 x $(NUM_CORES)， 缺省值1。此配置只适用于gthread 进程工作方式， 因为gevent这种使用的是协程工作方式。worker_connections客户端最大同时连接数。只适用于eventlet， gevent工作方式。# max_requests# worker重启之前处理的最大requests数， 缺省值为0表示自动重启disabled。主要是防止内存泄露。max_requests =1000max_requests_jitter抖动参数，防止worker全部同时重启。timeout通常设为30。graceful_timeout接收到restart信号后，worker可以在graceful_timeout时间内，继续处理完当前requests。keepaliveserver端保持连接时间securitylimit_request_linehttp request line最大字节数。值范围0-8190， 0表示无限制。limit_request_fieldhttp request中 header字段数的最大值。缺省为100，最大32768。limit_request_field_sizehttp request header字段最大字节数。0表示无限制。调试reload当代码有修改时，自动重启workers。适用于开发环境。reload_extra_files扩展reload配置，增加templates，configurations等文件修改监控。spew跟踪程序执行的每一行。check_config检查配置。server 机制sendfile系统底层拷贝数据方式，提供performance。chdir在app加载之前，进入到此目录。daemon应用是否以daemon方式运行。raw_envkey=value, 传递环境参数。pidfilepid存储文件路径。worker_tmp_dir临时工作目录。user指定worker进程的运行用户名。group指定worker进程运行用户所在组。umaskgunicorn创建文件的缺省权限。pythonpath附加到python path的目录列表。日志accesslog访问日志文件路径。access_log_format日志格式。 例如 %(h)s %(l)s %(u)s %(t)s &quot;%(r)s&quot; %(s)s %(b)s &quot;%(f)s&quot; &quot;%(a)s&quot; 。errorlog错误日志路径。loglever日志级别。debug, info, warning, error, critical.capture_output重定向stdout/stderr到error log file。logger_class日志实现类。缺省gunicorn.glogging.Logger 。logconfig日志配置文件。同python标准日志模块logging的配置。进程名proc_name设置进程名(setproctitle)，在ps，top等命令中会看到. 缺省值为default_proc_name配置。server钩子on_startingon_reloadwhen_readypre_forkpost_forkpost_worker_initworker_initworker_abortpre_execpre_requestpost_requestchild_exitworker-exitnworkers_changedon_exit作者：慢手暗夜链接：https://www.jianshu.com/p/69e75fc3e08e来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。文件目录app_pro |--- app_real.py |--- deploy.py |--- requirements.txt |--- Dockerfile基本配置一个deploy.pyguni.conf.pyimport osbind=&#39;0.0.0.0:5001&#39; #绑定监听ip和端口号workers=3 #同时执行的进程数，推荐为当前CPU个数*2+1threads=4 # 指定每个CPU的线程数#backlog=2048 #等待服务客户的数量，最大为2048，即最大挂起的连接数#worker_class=&quot;gevent&quot; #sync, gevent,meinheld #工作模式选择，默认为sync，这里设定为gevent异步worker_class = &#39;gevent&#39;#max_requests=1000 #默认的最大客户端并发数量daemon=True # 是否后台运行reload=True # 当代码有修改时，自动重启workers。适用于开发环境。loglevel = &#39;info&#39; # 设置日志记录水平2. 编写DockerfileDockerfileFROM python:3.8MAINTAINER ZHENGKANWORKDIR usr/src/flask_appCOPY requirements.txt .RUN pip install --upgrade pip -i https://pypi.doubanio.com/simple/RUN pip install --no-cache-dir -r requirements.txt -i https://pypi.doubanio.com/simple/COPY . .# 注意app_real为flask的入口主文件 后面的app是主文件内部的一个flask实例对象CMD gunicorn -c guni.conf.py app_real:app --preload3. 构建镜像并运行docker build -t test01 .docker run -d -p 8888:5001 --name flask_app test01 # 将内部5001端口映射到宿主机的8888端口4. 访问端口访问 https://localhost:88884.部署mysql项目1.拉取mysql镜像docker pull mysql:8.02.配置docker-compose文件对于mysql，由于配置项较多，这时候考虑使用docker-compose来部署配置文件结构app | --- docker-compose.yml | --- mysql | --- config | --- mysqld.cnf | --- datadocker-compose.ymlversion: &quot;3.7&quot;services: myisql: # container_name: mysql_app image: mysql:8.0 #从私有仓库拉镜像-stopp command: --authentication_policy=mysql_native_password #这行代码解决无法访问的问题 volumes: - ./mysql/data/:/var/lib/mysql/ #映射mysql的数据目录到宿主机，保存数据 - ./mysql/config/mysqld.cnf:/etc/mysql/mysql.conf.d/mysqld.cnf #把mysql的配置文件映射到容器的相应目录 restart: unless-stopped # docker的重启策略：在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器 ports: - &quot;3305:3306&quot; environment: - MYSQL_ROOT_PASSWORD=123 - MYSQL_USER=zheng - MYSQL_PASSWORD=123 - MYSQL_DATABASE=yourdbname - LANG=C.UTF-8 - TZ=Asia/Shanghai3.构建容器服务并访问docker-compose -d up # 此过程需要等待时间，mysql需要初始化配置4.Navicat访问一下其数据库挂载卷在./mysql/data/下5.综合部署BigScreen |--- docker-compose.yml |--- flask_app | |--- app_real.py | |--- guni.conf.py | |--- reqirements.txt | |--- Dockerfile | |--- ... |--- mysql | |--- config | | |--- mysqld.cnf(空文件夹，可配置) | |--- data（空文件夹，用来存储mysql数据） | |--- init | |--- init.sql |--- nginx |--- config | |---nginx.conf |--- dist (vue打包的文件) |--- Dockerfile docker-compose.ymlversion: &quot;3.7&quot;services: flask_app: build: context: flask_app dockerfile: Dockerfile image: flask_app:1.0 ports: - &quot;9000:9000&quot; restart: always depends_on: - &quot;mysql&quot; network_mode: host nginx: build: context: nginx dockerfile: Dockerfile image: vue ports: - &quot;80:80&quot; network_mode: host mysql: container_name: mysql image: mysql:8.0 #从私有仓库拉镜像 restart: always command: --default-authentication-plugin=mysql_native_password #这行代码解决无法访问的问题 volumes: - ./mysql/data/:/var/lib/mysql/ #映射mysql的数据目录到宿主机，保存数据 - ./mysql/config/mysqld.cnf:/etc/mysql/mysql.conf.d/mysqld.cnf #把mysql的配置文件映射到容器的相应目录 ports: - &quot;3305:3306&quot; environment: - MYSQL_USER=zheng - MYSQL_PASSWORD=123 - LANG=C.UTF-8 - TZ=Asia/Shanghai - MYSQL_ROOT_PASSWORD=123 - MYSQL_DATABASE=LabDatabase flask_app/DockerfileFROM python:3.8MAINTAINER ZHENGKANRUN /bin/cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;amp;&amp;amp; echo &#39;Asia/Shanghai&#39; &amp;gt;/etc/timezoneWORKDIR usr/src/flask_appCOPY requirements.txt .RUN pip install -r requirements.txt -i https://pypi.doubanio.com/simple/COPY . .# 注意app_real为flask的入口主文件 后面的app是主文件内部的一个flask实例对象CMD gunicorn -c guni.conf.py app_real:app --preloadmysql/init/init.sql# 这个文件可以创建初始的表格，写sql语句就行，暂时不配置# 具体的用户和库的配置在yml文件的environment中已经配置nginx/config/nginx.conf#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events { worker_connections 1024;}http { include mime.types; default_type application/octet-stream; #log_format main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39; # &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39; # &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server { listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / { root /usr/share/nginx/html; try_files $uri /index.html last; index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # location /api/ { # 就这一下，后面加个斜杠,配置后端接口; 上面/api/后面有斜杠，下面的代理地址也要加斜杠，细节！！ proxy_pass http://127.0.0.1:9000/; } # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # deny access to .htaccess files, if Apache&#39;s document root # concurs with nginx&#39;s one # #location ~ /\\.ht { # deny all; #} } # another virtual host using mix of IP-, name-, and port-based configuration # #server { # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / { # root html; # index index.html index.htm; # } #} # HTTPS server # #server { # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / { # root html; # index index.html index.htm; # } #}}nginx/DockerfileFROM nginx# 定义作者MAINTAINER ZHENGKAN# 将dist文件中的内容复制到 /usr/share/nginx/html/ 这个目录下面COPY dist/ /usr/share/nginx/html/COPY config/nginx.conf /etc/nginx/nginx.confEXPOSE 80RUN echo &#39;echo init ok!!&#39;6.nginx.conf配置详解conf/nginx.conf## 基本配置user # 设置nginx服务的系统使用用户,通常注释掉worker_processes 2 # 工作进程数，一般与cpu核心数保持一致error_log # nginx的错误日志，这个后面写目录，用于存放错误日志；日志级别 [debug | info | notice | warn | error | crit]， # 默认是error# error_log logs/error.log;# erroe_log logs/notice.log notice;# erroe_log logs/info.log info;pid logs/nginx.pid # nginx服务启动时候的pid,一般不用改## 配置工作模式和连接数events { worker_connections 1024 # 配置每个worker的最大连接数，nginx的总连接数就是 worker_processes * worker_connections = 2 *1024 = 2048 # worker_connections的上限是 65535 }## 配置http服务器，可以通过该部分配置进行反向代理、负载均衡http { include mime.types; # 在conf/mime.types文件中配置nginx支持的多媒体类型 default_type application/octet-stream; # 默认文件类型为流类型，可以理解为支持任意类型 # 配置日志格式，开启之后只要访问http，都会有记录，记录保存在logs/access.log文件中 #log_format main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39; # &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39; # &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;; #access_log logs/access.log main; #tcp_nopush on; # 防止网路阻塞 #keepalive_timeout 0; keepalive_timeout 65; # 长时间超时时间，单位为秒 #gzip on; # 配置虚拟主机server，http下可以配置多个server server { # server配置每个站点的信息 listen 80; # 开放80端口供外部访问 server_name localhost; # 配置外部访问nginx端口的域名，如 www.baidu.com #charset koi8-r; # 字符集 #access_log logs/host.access.log main; # 配置本虚拟主机的访问日志 location / { # 访问域名下 / 的信息 http://www.baidu.com 的信息，即根路径 root html; # root表示本地磁盘根路径，默认nginx安装的主目录为html文件夹 try_files $uri /index.html last; index index.html index.htm; } #error_page 404 /404.html; 配置404页面 # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; # 精准匹配，当有/50x.html的匹配时，直接到html文件夹下，配置50x错误页面 location = /50x.html { root html; } }1. 静态网站部署vue写的项目，直接打包为dist后，将dist文件夹中的内容复制到html下，配置主要部分如下就行（其他默认）nginx.confhttp { ... # 配置虚拟主机server，http下可以配置多个server server { # server配置每个站点的信息 listen 80; # 开放80端口供外部访问 server_name localhost; # 配置外部访问nginx端口的域名，如 www.baidu.com #charset koi8-r; # 字符集 #access_log logs/host.access.log main; # 配置本虚拟主机的访问日志 location / { # 访问域名下 / 的信息 http://www.baidu.com 的信息，即根路径 root html; # root表示本地磁盘根路径，默认nginx安装的主目录为html文件夹 try_files $uri /index.html last; index index.html index.htm; } }2. 负载均衡负载均衡有四种策略：轮询策略、权重策略、最少连接策略和ip_hash 策略nginx.confhttp{ ... upstream app_server { # 这个back_server命名随意，但是与下面的代理地址相同 # 轮询（默认）策略，这样服务器会被轮询访问，这个对硬件要求需要保持机器的性能一致，不然会导致请求堆积 server 192.168.31.21:8080 # 代理服务器地址 server 192.168.31.22:8080 # 权重策略，如果配置权重，可以写成如下 # server 192.168.31.21:8080 weight = 1; # 在代理服务器地址后面设置权重weight，权重越大，访问比例越大；用于机器性能不一致的情况 # server 192.168.31.22:8080 weight = 2; # 最少连接策略,哪个服务器连接数少，就给哪个服务器分配下一个请求任务 # less_conn; # server 192.168.31.21:8080 # 代理服务器地址 # server 192.168.31.22:8080 # ip_hash策略，对ip地址做hash运算取模，根据模的数据选择服务器，这个容易造成单一服务器过载宕机,优点是不会丢失session # ip_hash # server 192.168.31.21:8080 # server 192.168.31.22:8080 } server { listen 80; serer_name localhost; ... location /myweb { proxy_pass http://app_server; # http://后面的名字与upstream后面的名字保持一致 } ... }}备份服务器，备份服务器的存在是为了更新时候，服务不受影响一般更新代码步骤：1. 更新备份服务器代码 2. 关掉一般服务器，并更新代码 3. 关闭另一半服务器，更新代码；upstream back_server{ server 127.0.0.1:9100; # 设置备份服务器，其他所有非backup机器down的时候，才请求backup机器 server 127.0.0.1:9200 backup;}upstream back_server{ server 127.0.0.1:9100; # down表示当前server是down的状态，不参与负载均衡 server 127.0.0.1:9200 down;}3. 静态代理http{ upstream app_server { # 这个back_server命名随意，但是与下面的代理地址相同 server 192.168.31.21:8080 # 代理服务器地址 server 192.168.31.22:8080 } server { listen 80; serer_name localhost; ... location /myweb { proxy_pass http://app_server; # http://后面的名字与upstream后面的名字保持一致 } # ~ 表示正则匹配，也是后面的内容可以使用正则表达式匹配 # . 表示任意字符 # * 表示多个字符 # / 表示文件路径 # (css|js...)配合表示拦截到/css或/js路径 location ~ .*/(css|js|img|images|image){ root /opt/static; } ... }}4. 动静分离Nginx的负载均衡和静态代理进行结合，可以实现动静分离。upstream www.p2p.com{ server 192.168.115.128:8081 server 192.168.115.128:8082}upstream static.p2p.com{ server 192.168.115.128:81 server 192.168.115.128:82}server{ listen 80; server_name localhost; location / { root html; index index.html index.htm; } # 负载均衡 location /p2p{ proxy_pass http://www.p2p.com; } # 动静分离 location ~ .*/(css|js|img|images) { proxy_pass http://static.p2p.com; } }5.虚拟主机虚拟主机的情况下，访问同一地址，能够访问不同的主机。upstream beijing.myweb.com{ server 192.168.115.128:8081; # 实际情况是这个地址为北京的ip；这里写成本地ip，需要修改本地的hosts文件地址达到访问的目的}upstream tianjin.myweb.com{ server 192.168.115.128:8082;}upstream nanjing.myweb.com{ server 192.168.115.128:8083;}server{ listen 80; server_name beijing.myweb.com; #访问beijing.myweb.com,请求被反向代理到192.168.115.128:8081服务器 location / { proxy_pass http:beijing.myweb.com; }}server{ listen 80; server_name tianjin.myweb.com; location / { proxy_pass http:tianjin.myweb.com; }}server{ listen 80; server_name nanjing.myweb.com; location / { proxy_pass http:nanjing.myweb.com; }}参考链接：" }, { "title": "Github中的SSH", "url": "/posts/Github%E7%9A%84ssh/", "categories": "IT", "tags": "Github", "date": "2022-01-23 00:00:00 +0800", "snippet": "本文主要介绍配置多个ssh的案例同时配置github和gitee远程仓库，命令执行窗口为git；# windows用户使用右键文件夹，git bash herestep 1 设置全局用户名和用户邮箱，这个就是本地的用户信息命令如下git config --global user.name &quot;这里换上你的用户名&quot;git config --global user.email &quot;这里换上你的邮箱&quot;step 2 生成本地私钥和公钥# 单个文件生成，没必要配置文件名，使用这个ssh-keygen -t rsa -C &quot;这里换上你的邮箱&quot;# 本案例配置多个，所以要使用文件名ssh-keygen -t rsa -C &quot;这里换上你gitee注册的邮箱&quot; -f ~/.ssh/gitee_idssh-keygen -t rsa -C &quot;这里换上你github注册的邮箱&quot; -f ~/.ssh/github_id这个过程中会出现文件报错地址的选择和其他确定的选项，可以直接回车（输入yes的时候，尽量输入一下）这个过程结束，windows系统可以在C:\\Users\\Administrator\\.ssh下，Linux用户可以在~/.ssh/目录下看到总共4个文件，分别是gitee_idgitee_id.pubgithub_idgithub_id.pubstep 3 配置文件编写在这个文件下，添加名为 config的文件，文件内容如下# giteeHost gitee.comHostName gitee.comPreferredAuthentications publickeyIdentityFile ~/.ssh/gitee_id# githubHost github.comHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/github_id此时文件夹中就有5个文件了，分别是configgitee_idgitee_id.pubgithub_idgithub_id.pubstep 4 复制公钥到github/gitee在github右上角头像下的三角形图标，找到settings,打开，找到SSH and GPG keys点击 new key，# 第一行为名称填写，自己随便取名；# 第二行为公钥填写，将 github_id.pub 中的内容粘贴在此处，并保存在gitee上，同样右上角头像下的三角形图标，找到设置，进入，点击安全设置\\SSH设置# 将 gitee_id.pub 中的内容粘贴在此处，并保存# 粘贴后，名字会自己生成，且为自己的邮箱step 5 验证验证github，在git中输入$ ssh -T git@github.comHi CarmanZheng! You&#39;ve successfully authenticated, but GitHub does not provhell access.验证gitee，在git中输入# 特别注意，其中有个yes的输入，不要直接敲回车；需要手动输入yes后回车 （坑的很）$ ssh -T git@gitee.comThe authenticity of host &#39;gitee.com (180.97.125.228)&#39; can&#39;t be established.ECDSA key fingerprint is SHA256:FQGC9Kn/eye1W8icdBgrQp+KkGYoFgbVr17bmjey0WcAre you sure you want to continue connecting (yes/no/[fingerprint])? yesWarning: Permanently added &#39;gitee.com,180.97.125.228&#39; (ECDSA) to the list own hosts.Hi CarmanZheng! You&#39;ve successfully authenticated, but GITEE.COM does not pe shell access.所有工作完成后，会在C:\\Users\\Administrator\\.ssh 或者 ~/.ssh/目录下生成一个known_host的文件，里面记录了主机地址和秘钥文件夹中文件为6个，分别为configgitee_idgitee_id.pubgithub_idgithub_id.pubknown_hosts打完收工!" }, { "title": "Pyside6概述与安装", "url": "/posts/Pyside6%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%AE%89%E8%A3%85/", "categories": "Python", "tags": "客户端开发", "date": "2022-01-01 00:00:00 +0800", "snippet": "参考链接：https://doc.qt.io/qtforpython/index.html1.概述Qt for Python offers the official Python bindings for Qt, and has two main components: PySide6, so that you can use Qt6 APIs in your Python applications, and Shiboken6, a binding generator tool, which can be used to expose C++ projects to Python, and a Python module with some utility functions.没说的，就是他了！2.安装Before you can install Qt for Python, first you must install the following software:1.版本 Python 3.6+,2.推荐使用虚拟环境 We recommend using a virtual environment, such as venv or virtualenvpip install pyside6# 安装完检测版本import PySide6.QtCore# Prints PySide6 versionprint(PySide6.__version__)# Prints the Qt version used to compile PySide6print(PySide6.QtCore.__version__)如果出现报错，这表明插件位置有问题，在运行加入以下代码，指定插件位置pyqt6_dirname = os.path.dirname(PySide6.__file__)plugin_path = os.path.join(pyqt6_dirname, &#39;plugins&#39;, &#39;platforms&#39;)os.environ[&#39;QT_QPA_PLATFORM_PLUGIN_PATH&#39;] = plugin_path" }, { "title": "Ubuntu装机", "url": "/posts/Linux-Ubuntu%E8%A3%85%E6%9C%BA/", "categories": "Linux", "tags": "Linux基础", "date": "2021-08-21 00:00:00 +0800", "snippet": "本文主要介绍ubuntu版本下的系统常用软件的装机，所有代码均写为sh命令，方便一键解决1. 镜像源修改alisource.list# ubuntu 20.04(focal) deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiversemod_source.sh#!bin/bashsourceFileBak = &quot;/etc/apt/sources.list.bak&quot;if [ ! -f &quot;$sourceFileBak&quot;]; thensudo cp /etc/apt/sources.list /etc/apt/sources.list.bakfisudo cp ./alisource.list /etc/apt/sources.listsudo apt-get -y updatesudo apt-get -y upgrade将上述两个文件放在同一文件夹下，执行mod_source.sh即可将ubuntu 20.04(focal) 系统源更换为阿里源2. docker 安装https://developer.aliyun.com/mirror/?spm=a2c6h.13651102.0.0.77cd1b11h9CKdC&amp;amp;serviceType=mirrordaemon.json{ &quot;registry-mirrors&quot; : [ &quot;https://registry.docker-cn.com&quot;, &quot;https://docker.mirrors.ustc.edu.cn&quot;, &quot;http://hub-mirror.c.163.com&quot;, &quot;https://cr.console.aliyun.com/&quot; ]}docker_install.sh#!bin/bash# uninstall older versionssudo apt-get remove docker docker-engine docker.io containerd runcsudo apt-get update# step 1: 安装必要的一些系统工具sudo apt-get updatesudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common# step 2: 安装GPG证书curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -# Step 3: 写入软件源信息sudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;# Step 4: 更新并安装Docker-CEsudo apt-get -y updatesudo apt-get -y install docker-ce# Step 5: 更改镜像源为阿里源sudo cp ./daemon.json /etc/docker/daemon.json# 安装指定版本的Docker-CE:# Step 1: 查找Docker-CE的版本:# apt-cache madison docker-ce# docker-ce | 17.03.1~ce-0~ubuntu-xenial | https://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages# docker-ce | 17.03.0~ce-0~ubuntu-xenial | https://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages# Step 2: 安装指定版本的Docker-CE: (VERSION例如上面的17.03.1~ce-0~ubuntu-xenial)# sudo apt-get -y install docker-ce=[VERSION]3. docker-compose#!bin/bash# 需要切换到root状态下curl -L https://get.daocloud.io/docker/compose/releases/download/1.24.0/docker-compose-`uname -s`-`uname -m` &amp;gt; /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-composedocker-compose --verison 4. kubernetes安装k8s_install.sh#!bin/bash# 需要切换到root状态下apt-get update &amp;amp;&amp;amp; apt-get install -y apt-transport-httpscurl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add - cat &amp;lt;&amp;lt;EOF &amp;gt;/etc/apt/sources.list.d/kubernetes.listdeb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial mainEOFapt-get updateapt-get install -y kubelet kubeadm kubectl5. pythonpip.conf[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host=mirrors.aliyun.compython_source.sh#!bin/bash# 需要切换到root状态下mkdir ~/.pip/cp pip.conf ~/.pip/pip.conf# 附录清华：https://pypi.tuna.tsinghua.edu.cn/simple阿里云：http://mirrors.aliyun.com/pypi/simple/中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/华中科技大学：http://pypi.hustunique.com/山东理工大学：http://pypi.sdutlinux.org/ 豆瓣：http://pypi.douban.com/simple/note：新版ubuntu要求使用https源，要注意。例如：pip3 install -i https://pypi.doubanio.com/simple/ 包名未完待补充…" }, { "title": "Linux-Shell", "url": "/posts/Linux-Shell/", "categories": "Linux", "tags": "Linux基础", "date": "2021-08-11 00:00:00 +0800", "snippet": "1.shell简介1.简介Linux系统可以划分为四个部分： 应用软件 窗口管理软件 GNU系统工具链 Linux内核Linux shell 是一种特殊的交互式工具，它提供了文件管理、运行进程的的途径。Shell的核心是命令提示符，允许用户输入命令，然后解释命令，并在内核中执行。用户可以编写脚本文件，将多个shell命令以某种形式组织起来，作为程序一起执行2.常见的shell shell有很多种，不同的shell有不同的特性 shell 描述 bsh 一种最早出现在Unix系统上的标准shell，全程叫Bourne shell bash 一种对bsh在功能上进行扩展的shell，几乎可以涵盖shell所需要的所有功能 ksh 一种与bsh兼容的编程shell，增加了很多特性，常见于Unix操作系统 tcsh 一种具有C语言风格语法结构的shell，常见于嵌入式开发 zsh 一种结合了bash、ksh和tsh的特点，同时提供了高级编程特性的高级shell sh 绝大部分Linux发行版中，作为软链接指向其他shell（默认是bash） 几乎所有的Linux发行版默认shell是bash shell 有些发行版默认系统shell和默认交互shell并不相同 查看系统支持的shell类型 root@luckydog:~# cat /etc/shells# /etc/shells: valid login shells/bin/sh/bin/bash/usr/bin/bash/bin/rbash/usr/bin/rbash/bin/dash/usr/bin/dashroot@luckydog:~# cat /etc/shells |xargs ls -alls: cannot access &#39;#&#39;: No such file or directoryls: cannot access &#39;/etc/shells:&#39;: No such file or directoryls: cannot access &#39;valid&#39;: No such file or directoryls: cannot access &#39;login&#39;: No such file or directoryls: cannot access &#39;shells&#39;: No such file or directory-rwxr-xr-x 1 root root 1183448 Jun 18 2020 /bin/bash-rwxr-xr-x 1 root root 129816 Jul 19 2019 /bin/dashlrwxrwxrwx 1 root root 4 Jun 18 2020 /bin/rbash -&amp;gt; bashlrwxrwxrwx 1 root root 4 Jun 23 11:28 /bin/sh -&amp;gt; dash-rwxr-xr-x 1 root root 1183448 Jun 18 2020 /usr/bin/bash-rwxr-xr-x 1 root root 129816 Jul 19 2019 /usr/bin/dashlrwxrwxrwx 1 root root 4 Jun 18 2020 /usr/bin/rbash -&amp;gt; bash# 查看当前交互shell类型是 bashroot@luckydog:~# echo $SHELL/bin/bash2.shell常用命令1.常见命令 管理文件和目录： cd pwd ls touch cp mv rm mkdir rmdir file cat more less tail head 管理系统进程 ps top kill killall 管理磁盘空间 mount umount df du 处理数据文件 sort grep gzip tar shell命令帮助手册： man [command]2.外部命令 外部命令也成为文件系统命令，通常位于/bin、/sbin、/usr/bin、/usr/sbin等目录中 # 查看命令位置root@luckydog:~# which ls/usr/bin/ls fork：外部命令执行时，会创建一个子进程。 root@luckydog:~# ps -fUID PID PPID C STIME TTY TIME CMDroot 74229 74187 0 15:32 pts/0 00:00:00 -bashroot 74259 74229 0 15:33 pts/0 00:00:00 /bin/shroot 74260 74259 0 15:33 pts/0 00:00:00 /bin/bashroot 74269 74260 0 15:34 pts/0 00:00:00 /bin/bashroot 74306 74269 0 15:53 pts/0 00:00:00 ps -f 可以看到，执行ps -f命令时，会在父进程（74269）下创建一个子进程（74306） 3.内建命令 作为shell工具的组成部分，内建命令不需要使用子进程来执行 对于有些命令，有多种实现，既有外部命令，也有内建命令。 了解某个命令的类型 type -a pwd # pwd既是外部命令，也是内建命令root@luckydog:~# type -a pwdpwd is a shell builtinpwd is /usr/bin/pwdpwd is /bin/pwd 了解所有内建命令 man builtin 3.shell脚本基础1.编写 脚本创建、执行与退出状态码 第一行需要指定shell类型shebang script.sh: #!/bin/bashdatewho 执行脚本 增加脚本可执行权限 （chmod） 使用绝对/相对路径执行shell脚本 chmod +x script.sh./script.sh 脚本的退出状态码 # 通过 $?查看脚本执行状态# 查看状态： 0 - 执行成功；其他数字 - 执行失败$? 2.变量定义与使用 Linux系统的环境变量 通过set查看： 局部环境变量 通常是小写字母，只在其定义的进程中可见 全局环境变量 通常为大写字母，全局可见 用户自定义变量 用户可以自定义由字母、数字和下划线组成，长度不超过20个字符，区分大小写 变量的定义和赋值 等号两边不能有空格 使用美元符$对变量进行引用 建议使用${variable_name} 命令替换：将命令的输出赋值给变量 反引号command 推荐使用 $(command) #!/bin/bashdateecho &quot;current user is ${USER}&quot;echo &quot;current user UID is ${UID}&quot;echo &quot;current user HOME path is ${HOME}&quot;root@luckydog:~# chmod +x scriptroot@luckydog:~# ./scriptSun 22 Aug 2021 04:19:48 PM CSTcurrent user is rootcurrent user UID is 0current user HOME path is /rootTIP: echo语句或解释语句内容（不包括通配符），所以 如果语句不包含对通配符的解释，一律用双引号括起来。3.数学运算略4.shell脚本条件控制1. if-then语句if commandthen commandsfi--------------------------if command; then commandsfi2.if-elif-thenif commandthen commandselif commandthen commandselse commandsfi3.条件测试test命令if test conditionthen commandsfi---------------------# 方括号两边必须加上空格if [ condition ]then commandsfi1.数值比较 -eq -ne -gt -ge -lt -le 等于（equal） 不等于（not equal） 大于（great than） 大于等于（great equal） 小于（less than) 小于等于(less equal) num1=100num2=100if test $[num1] -eq $[num2]then echo &#39;两个数相等！&#39;else echo &#39;两个数不相等！&#39;fi2.字符串比较 = ！= -z 字符串 -n 字符串 等于 不等于 字符串长度为0 字符串长度不为0 num1=&quot;ru1noob&quot;num2=&quot;runoob&quot;if test $num1 = $num2then echo &#39;两个字符串相等!&#39;else echo &#39;两个字符串不相等!&#39;fi3.文件比较 参数 说明 -e 文件名 如果文件存在则为真 -r 文件名 如果文件存在且可读则为真 -w 文件名 如果文件存在且可写则为真 -x 文件名 如果文件存在且可执行则为真 -s 文件名 如果文件存在且至少有一个字符则为真 -d 文件名 如果文件存在且为目录则为真 -f 文件名 如果文件存在且为普通文件则为真 -c 文件名 如果文件存在且为字符型特殊文件则为真 -b 文件名 如果文件存在且为块特殊文件则为真 -a 与运算 -o 或运算 ！ 非运算 cd /binif test -e ./bashthen echo &#39;文件已存在!&#39;else echo &#39;文件不存在!&#39;fi另外，Shell 还提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为： ! 最高， -a 次之， -o 最低。例如：cd /binif test -e ./notFile -o -e ./bashthen echo &#39;至少有一个文件存在!&#39;else echo &#39;两个文件都不存在&#39;fi4.if-then高级特性-双括号 支持高级数据表达式计算 命令格式：((expression)) expression可以是数据赋值或者比较表达式script01.sh# 赋值等号没有空格，必须连着写#!/bin/bashvalue=10if (( ${value} ** 2 &amp;gt;90))then ((answer = ${value} ** 2)) echo &quot;the answer of ${value} ** 2 is ${answer}.&quot;firoot@luckydog:~# ./script01.shthe answer of 10 ** 2 is 100.5.if-then高级特性-双方括号 支持针对字符串比较的高级特性 命令格式 [[ expression ]] 除了标准的字符串比较，还支持模式匹配script02.sh#!/bin/bashvalue=10if [[ ${USER} == r* ]]then echo &quot;the USER name is ${USER}.&quot;firoot@luckydog:~# ./script02.shthe USER name is root.6.case语句case expression in pattern1) commands;; pattern2) commands;; pattern3) commands;; *) default commands;; esacscript03.shcase ${USER} in mysql) echo &quot;current user is mysql&quot;;; root) echo &quot;current user is root&quot;;; *) echo &quot;unknown user.&quot;;;esac root@luckydog:~# ./script03.shcurrent user is root5.shell脚本循环控制1.for语句 用于遍历一个制定的列表，每次迭代使用列表中的一个元素，执行好定义好的一组命令。 for语句格式for var in listdo commandsdone--------------------for var in list; do commandsdone for 命令的使用script04.sh#!/bin/bashfor fruit in apple lemon orangedo echo ${fruit}doneroot@luckydog:~# ./script04.shapplelemonorange 从命令中读取数据列表 将变量写入文本文件fruitlist.txt中 echo -e &quot;apple\\nlemon\\norange\\n&quot; &amp;gt; fruitlist.txtscript05.sh#!/bin/bashfile=&#39;fruitlist.txt&#39;for fruit in $(cat ${file})do echo &quot;this is $fruit&quot;doneroot@luckydog:~# ./script05.shthis is applethis is lemonthis is orange 更改字段分隔符 $IFSscript06.sh#!/bin/bashfruitlist=&#39;apple:lemon:orange&#39;IFS=:for fruit in $fruitlistdo echo &quot;this is $fruit&quot;doneroot@luckydog:~# ./script06.shthis is applethis is lemonthis is orange 通配符遍历script07.sh#!/bin/bashfor file in ./*do if [[ ${file##*.} = sh ]] then echo &quot;sh文件:$file&quot; elif [[ ${file##*.} = txt ]] then echo &quot;txt文件:$file&quot; fidoneroot@luckydog:~# ./script07.shtxt文件:./fruitlist.txtsh文件:./get-docker.shsh文件:./script01.shsh文件:./script02.shsh文件:./script03.shsh文件:./script04.shsh文件:./script05.shsh文件:./script06.shsh文件:./script07.sh2.while语句while [ command ]do commandsdonescript08.sh#!/bin/bashi=1while [ $i -le 10 ]do echo &quot;the number is $i&quot; ((i = i + 1))doneroot@luckydog:~# ./script08.shthe number is 1the number is 2the number is 3the number is 4the number is 5the number is 6the number is 7the number is 8the number is 9the number is 103.循环控制breakbreak可以跳出任意类型的循环 跳出内部循环, 使用break 跳出外层循环，使用break n，其中n为整数script09.sh [九九乘法表]#!/bin/bashfor i in $(seq 1 9)do for j in $(seq 1 9) do echo &quot;$i * $j = $(($i*$j))&quot; donedoneroot@luckydog:~# ./script09.sh1 * 1 = 11 * 2 = 21 * 3 = 31 * 4 = 41 * 5 = 51 * 6 = 61 * 7 = 71 * 8 = 81 * 9 = 92 * 1 = 22 * 2 = 42 * 3 = 62 * 4 = 82 * 5 = 102 * 6 = 122 * 7 = 142 * 8 = 162 * 9 = 183 * 1 = 33 * 2 = 63 * 3 = 93 * 4 = 123 * 5 = 153 * 6 = 183 * 7 = 213 * 8 = 243 * 9 = 274 * 1 = 44 * 2 = 84 * 3 = 124 * 4 = 164 * 5 = 204 * 6 = 244 * 7 = 284 * 8 = 324 * 9 = 365 * 1 = 55 * 2 = 105 * 3 = 155 * 4 = 205 * 5 = 255 * 6 = 305 * 7 = 355 * 8 = 405 * 9 = 456 * 1 = 66 * 2 = 126 * 3 = 186 * 4 = 246 * 5 = 306 * 6 = 366 * 7 = 426 * 8 = 486 * 9 = 547 * 1 = 77 * 2 = 147 * 3 = 217 * 4 = 287 * 5 = 357 * 6 = 427 * 7 = 497 * 8 = 567 * 9 = 638 * 1 = 88 * 2 = 168 * 3 = 248 * 4 = 328 * 5 = 408 * 6 = 488 * 7 = 568 * 8 = 648 * 9 = 729 * 1 = 99 * 2 = 189 * 3 = 279 * 4 = 369 * 5 = 459 * 6 = 549 * 7 = 639 * 8 = 729 * 9 = 81在其中加入break，跳出当前循环#!/bin/bashfor i in $(seq 1 9)do for j in $(seq 1 9) do if [ $j -gt 3 ] then break else echo &quot;$i * $j = $(($i*$j))&quot; fi donedoneroot@luckydog:~# ./script10.sh1 * 1 = 11 * 2 = 21 * 3 = 32 * 1 = 22 * 2 = 42 * 3 = 63 * 1 = 33 * 2 = 63 * 3 = 94 * 1 = 44 * 2 = 84 * 3 = 125 * 1 = 55 * 2 = 105 * 3 = 156 * 1 = 66 * 2 = 126 * 3 = 187 * 1 = 77 * 2 = 147 * 3 = 218 * 1 = 88 * 2 = 168 * 3 = 249 * 1 = 99 * 2 = 189 * 3 = 27写入break 2 ，跳出两层循环#!/bin/bashfor i in $(seq 1 9)do for j in $(seq 1 9) do if [ $j -gt 3 ] then break 2 else echo &quot;$i * $j = $(($i*$j))&quot; fi donedoneroot@luckydog:~# ./script10.sh1 * 1 = 11 * 2 = 21 * 3 = 34.循环控制continue continue可以跳过执行当前循环的命令，但不会终止整个循环 可指定跳过的循环层数 continue ncontinue的本质就是跳出本次循环，继续执行下一个循环6.shell处理用户输入1.命令行输入 命令行参数输入是向shell脚本传递数据的最基本方法 位置参数：$0 是脚本名； $1到$9表示第一到第九个参数，第十个参数可以用${10}表示 若参数中存在空格，需要用双引号引用script11.sh#!/bin/bashecho &quot;hello $1&quot;echo &quot;hello $2&quot;root@luckydog:~# ./script11.shhellohelloroot@luckydog:~# ./script11.sh alice tedhello alicehello tedroot@luckydog:~# ./script11.sh alice &quot;Li Ming&quot;hello alicehello Li Ming2.特殊参数变量 $#$#存储了脚本运行时携带的命令行参数的个数使用变量可以判断传入参数的个数3.shift命令 shift命令可以将每个参数的变量向左移动一个位置， 如使用一次shift，$1的值被删除，此时$1的值为$2以前的值、$2的值为$3以前的值；$0始终不变，为脚本名 一次移动多个位置，使用shift N 4.交互式处理-read命令script12.sh#!/bin/bash# -p表示输入参数read -p &quot;enter your name: &quot; first lastecho &quot;your first name is $first&quot;echo &quot;your last name is $last&quot;root@luckydog:~# ./script12.shenter your name: Li Mingyour first name is Liyour last name is Mingscript13.sh#!/bin/bash# -n1 表示输入一个字符，存入到后面的ans中read -n1 -p &quot;Do you want to continue [Y/n]&quot; ansecho case $ans in Y | y) echo &quot;YES&quot;;; N | n) echo &quot;Bye&quot;;;esacroot@luckydog:~# ./script13.shDo you want to continue [Y/n]yYESroot@luckydog:~# ./script13.shDo you want to continue [Y/n]nByescript14.sh#!/bin/bash# -p表示输入参数,-t 5 表示5秒不输入则返回非0状态码，并退出if read -t 5 -p &quot;enter your num: &quot; numthen echo &quot;your num is $num&quot;else echo &quot;Sorry timeout!&quot;fiscript15.sh读取文件中的参数#!/bin/bashfilename=&#39;data.txt&#39;if [ -f ${filename} ];then count=1 cat data.txt |while read line do echo &quot;line ${count} :${line}&quot; count=$[ $count + 1 ] done echo &quot;Finished reading the file&quot;else echo &quot;${filename} is not exist!&quot;firoot@luckydog:~# ./script15.shdata.text is not exist!root@luckydog:~# ./script15.shline 1 :this is the test fileline 2 :there are two lines!Finished reading the file7.脚本重定向1.标准文件描述符Linux通过标准文件描述符来标识每个文件对象 文件描述符 缩写 描述 0 STDIN 标准输入 1 STDOUT 标准输入 2 STDERR 标准错误 2.重定向普通和错误信息 只重定向错误输出 ls -al badfile 2 &amp;gt; error.log 重定向错误和普通输出 ls -al badfile testfile 2 &amp;gt; error.log 1 &amp;gt; output.log 重定向到同一个文件 ls -al badfile testfile &amp;amp;&amp;gt; output.log 在脚本中重定向输出 临时重定向： 重定向到文件描述符时，必须在文件描述符数字前加一个&amp;amp; echo &quot;this is a error message&quot; &amp;gt;&amp;amp;2 script16.sh #!/bin/bash echo &quot;this is a error message&quot; &amp;gt;&amp;amp;2echo &quot;this is a normal message&quot; root@luckydog:~# ./script16.shthis is a error messagethis is a normal message root@luckydog:~# ./script16.sh 2&amp;gt;error.logthis is a normal messageroot@luckydog:~# cat error.logthis is a error message 永久重定向 使用exec命令在脚本执行期间重定向某个特定的文件描述符 exec命令会启动一个shell来进行数据重定向 script17.sh #!/bin/bash # 将普通输出定位到output.log文件中exec 1&amp;gt; output.logecho &quot;this is a normal message&quot; root@luckydog:~# ./script17.shroot@luckydog:~# cat output.logthis is a normal message 创建自己的重定向 除了上面的0、1、2三个描述符之外，其余4、5、6、7、8、9都可以作为自定义文件描述符 创建文件描述符 exec 3&amp;gt;output_file # 输出文件描述符 exec 0&amp;lt;input_file # 输入文件描述符 exec 6 &amp;lt;&amp;gt;test_file # 读写文件描述符 关闭文件描述符 exec 6&amp;gt;&amp;amp;-exec 6&amp;lt;&amp;amp;- 实现一个简单的线程池 # 脚本需要并发的执行任务# 令牌桶模型控制并发数 script18.sh #!/bin/bash n_thread=3tmp_fifofile=&#39;file.fifo&#39;rm -f ${tmp_fifofile} mkfifo ${tmp_fifofile}exec 6&amp;lt;&amp;gt; ${tmp_fifofile} for (( i=1; i &amp;lt;=${n_thread}; i++));do echo &amp;gt;&amp;amp;6done for i in $(seq 100 200);do read -u6 { echo &quot;thread handling number : ${i}&quot; sleep 3 echo &amp;gt;&amp;amp;6 }&amp;amp;done wait rm ${tmp_fifofile}exec 6&amp;gt;&amp;amp;-exec 6&amp;lt;&amp;amp;- 8.shell脚本函数1.基本的脚本函数 创建函数 # 第一种方法function func_name{...} # 第二种方法func_name(){...} 使用函数 func_name 2.在函数中使用变量​ 1.向函数传递参数​ 位置参数变量​ 2.在函数中处理变量 * 全局变量 * 局部变量3.函数的返回值 默认的退出状态码 $? 使用return命令 只能获取 整数 0-255，否则使用下面第三种方法 使用命令执行获取函数的输出 ans = $(func) 9.shell脚本实例目标： 获取指定目录中占用空间大小前十的子目录，并生成每日报告核心命令：du -s [directionary] sort -rn核心功能：准备需要检测的目录，得到目录统计数据，将结果生成每日报告完善脚本: 执行验证，设置计划任务1.后台开启python服务，并开机自运行 准备shell文件和python文件 test—- —- start.sh ​ —-back_run.py start.sh #!/bin/bash cd /test python -u back_run.py &amp;gt; out.log 2&amp;gt;&amp;amp;1 &amp;amp; back_run.py import os,datetime,time while True: print(&#39;{}&#39;.format(datetime.datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S&#39;))+&#39; running...&#39;) time.sleep(1) 编写服务文件 vim /etc/systemd/system/python_test.service 1 [Unit] 2 Description=python-test 3 After=network.target 4 StartLimitIntervalSec=0 5 [Service] 6 Type=simple 7 Restart=always 8 RestartSec=1 9 User=root 10 ExecStart=/usr/bin/bash /test/start.sh // 必须为绝对路径 11 12 [Install] 13 WantedBy=multi-user.target # 修改权限chmod 755 /etc/systemd/system/python_test.service# 重载守护systemctl daemon-reload# 开启开机启动服务systemctl enable python_test.service 重启服务： sudo reboot 附录–一些关于systemctl的命令 # 查看所有服务的状态systemctl status # 查看单个任务systemctl status python_test.service # 停止服务systemctl stop python_test # 手工启动服务systemctl start python_test # 禁用开机启动systemctl disable python_test.service 参考链接" }, { "title": "Linux基础", "url": "/posts/Linux%E5%9F%BA%E7%A1%80/", "categories": "Linux", "tags": "Linux基础", "date": "2021-08-10 00:00:00 +0800", "snippet": "第一部分 用户账号用户账号的管理工作主要涉及到用户账号的添加、修改和删除。添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。1.添加账户# 此命令创建了一个用户kuangshen，其中 -m 选项用来为登录名kuangshen产生一个主目录 /home/kuangshen# -m　使用者目录如不存在则自动建立root@ubuntu:~# useradd -m kuangshenroot@ubuntu:/home# lskuangshen zhengroot@ubuntu:/home# cat /etc/shadow | grep kuangshenkuangshen:!:19015:0:99999:7:::root@ubuntu:/home# cat /etc/passwd | grep kuangshenkuangshen:x:1002:1002::/home/kuangshen:/bin/shroot@ubuntu:/home# cat /etc/group | grep kuangshenkuangshen:x:1002:增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。2.删除账户# 常用的选项是 -r，它的作用是把用户的主目录一起删除[root@kuangshen home] userdel -r kuangshen此命令删除用户kuangshen在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。3.修改用户修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。# 添加组# 修改组# 删除组# 这几项放在第二部分用户组管理中问题： 如果按照前面的useradd -m 后直接切换用户，会出现界面只有$ ,没有主机名的情况，原因： 查看/etc/passwd文件后发现，新建的用户未指定shell。我们只需将其指定为/bin/bash即可解决：root@ubuntu:~# usermod -s /bin/bash kuangshen问题： 此时切换为kuangshen用户后，再切换为root用户，会出现 kuangshen@ubuntu:/root$ sudo -i [sudo] kuangshen 的密码： kuangshen 不在 sudoers 文件中。此事将被报告。原因： 这是由于狂神用户不在sudoers用户组中，不能使用内部命令解决：root@ubuntu:~# gpasswd -a kuangshen sudo#--------------------------------------------# 下面为操作后的效果，能够实现自由切换# root@ubuntu:~# gpasswd -a kuangshen sudoers# gpasswd：sudoers 组不存在于 /etc/group 中# root@ubuntu:~# gpasswd -a kuangshen sudo# 正在将用户“kuangshen”加入到“sudo”组中# root@ubuntu:~# newgrp # root@ubuntu:~# groups kuangshen# kuangshen : kuangshen sudo# root@ubuntu:~# su kuangshen# To run a command as administrator (user &quot;root&quot;), use &quot;sudo &amp;lt;command&amp;gt;&quot;.# See &quot;man sudo_root&quot; for details.# # kuangshen@ubuntu:/root$ sudo -i# [sudo] kuangshen 的密码： # root@ubuntu:~# #--------------------------------------------# 修改密码（登录口令）# 用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。# 指定和修改用户口令的Shell命令是passwd。# 超级用户（root）可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为：passwd 选项 用户名-l 锁定口令，即禁用账号。在超级用户下锁定普通用户，以后该普通用户无法登录；登录界面没有显示该账户，shell也没有-u 口令解锁，即激活已有账号-d 使账号无口令，清除账号的口令，下次直接登录-f 强迫用户下次登录时修改口令。root@ubuntu:~# passwd kuangshen 4.查询用户# 查询用户加入的组root@ubuntu:/home# groups kuangshenkuangshen : kuangshen sudo第二部分 用户组管理每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。1.添加用户组# 用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。# 增加一个新的用户组使用groupadd命令root@ubuntu:~# groupadd ex1# 指定组号为10002，即GID 为10002root@ubuntu:~# groupadd -g 10002 group22.删除用户组root@ubuntu:~# groupdel ex13.修改用户组# 修改用户组的ID和用户组的名称# 修改用户组ID,即修改GID，使用 -groot@ubuntu:~# groupmod group2 -g 10003root@ubuntu:~# cat /etc/group...group2:x:10003:# 修改用户组名称root@ubuntu:~# groupmod group2 -n group3root@ubuntu:~# cat /etc/group...group3:x:10003:4.查询用户组# 查询刚刚建立的10002组root@ubuntu:~# cat /etc/group...group3:x:10003:5.加入用户组在linux系统中，/etc/passwd文件是用户管理工作涉及的最重要的一个文件，虽然usermod命令也可以加入用户组，但是个人推荐使用gpasswd命令来实现用户组的用户添加# 添加用户到用户组gpasswd -a userA groupB# 删除用户组中的用户gpasswd -d userA groupB# 指定用户组的管理员,很少使用,比较鸡肋gpasswd -A userA groupA6.用户组文件在用户组的管理中，/etc/passwd、/etc/shadow和/etc/group是三个非常重要的文件，下面单独讲解一下。# /etc/passwd 文件root@ubuntu:~# cat /etc/passwdroot:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin...kuangshen:x:1002:1002::/home/kuangshen:/bin/bash# 文件说明用户名:密码:UID:GID:注释性描述:主目录:登录Shell# 解释1. &quot;用户名&quot;: 通常长度不超过8个字符，并且由大小写字母和/或数字组成。2. &quot;密码&quot; : 在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如 x 或者 *3. &quot;UID&quot; : 通常用户标识号的取值范围是0～65535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是5004. &quot;GID&quot; : 对应着/etc/group文件中的一条记录5. &quot;注释性描述&quot;: 这个字段并没有什么实际的用途6. &quot;主目录&quot; : 用户的起始工作目录7. &quot;登录Shell&quot;:用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。# /etc/shadowroot@ubuntu:~# cat /etc/shadowroot:!:18941:0:99999:7:::daemon:*:18375:0:99999:7:::bin:*:18375:0:99999:7:::...kuangshen:$6$2hl6Un.r8ndHRhrQ$./qVR5dJXMROgcEY.m8PpUTUSNLs.4GkPL5a0eA4ZOSKtWF/kc74J/3qm.svSNHanvKddtaazvhV46JYRQpRb/:19015:0:99999:7:::# 文件说明登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志# 解释1. &quot;登录名&quot; : 与/etc/passwd文件中的登录名相一致的用户账号2. &quot;口令&quot;: 字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。 # ! 表示没有设定密码; * 星号代表帐号被锁定; !! 表示密码过期; $6$ 表明是用SHA-512加密; $1$ 表明是用MD5加密; $2$ 是用Blowfish加密的; $5$是用 SHA-256加密的;3. &quot;最后一次修改时间&quot; : 表示的是从某个时刻起(1970年1月1日)，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。4. &quot;最小时间间隔&quot; : 指的是两次修改口令之间所需的最小天数。5. &quot;最大时间间隔&quot; : 指的是口令保持有效的最大天数。如果是99999则永远不用改。如果是其其他数字比如12345，那么必须在距离1970-1-1的12345天内修改密码，否则密码失效。6. &quot;距离密码修改提前警告天数&quot; : 字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。比如你在第五条规定今年6月20号规定密码必须被修改，系统会从距离6-20号的N天前向对应的用户发出警告。7. &quot;不修改密码宽限天数&quot; : 表示的是用户没有登录活动但账号仍能保持有效的最大天数。假设这个数字被设定为M，那么帐号过期的M天内修改密码是可以修改的，改了之后账户可以继续使用8. &quot;失效时间&quot; : 天数X,X表示的日期依然是1970-1-1相距的天数，过了X之后，帐号失效9. &quot;标志&quot; : 被保留项，暂时还没有被用上。# /etc/grouproot@ubuntu:~# cat /etc/grouproot:x:0:daemon:x:1:...sudo:x:27:zheng,kuangshendocker:x:134:kuangshen:x:1002:group3:x:10003:# 文件说明组名:口令:组标识号:组内用户列表# 解释1. &quot;组名&quot; : 用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。2. &quot;口令&quot; : 字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空、*、x。3. &quot;组标识号(GID)&quot; : 与用户标识号类似，也是一个整数，被系统内部用来标识组。4. &quot;组内用户列表&quot; : 属于这个组的所有用户的列表，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。第三部分 vim基操Vim 是从 vi 发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。1.三种模式VIM 的三种模式1. 命令模式（Command mode）2. 输入模式（Insert mode）3. 底线命令模式（Last line mode）# 1. 命令模式i 切换到输入模式，以输入字符。x 删除当前光标所在处的字符。: 切换到底线命令模式，以在最底一行输入命令。--------------------------------------------------------------------N 向上/向下翻页n 向上/向下翻页?被搜索的词 向上搜索关键词/被搜索的词 向下搜索关键词--------------------------------------------------------------------dd 删除当前行ndd 删除u 重复上一个动作--------------------------------------------------------------------yy 复制当前行yG 复制游标所在行到最后一行的所有数据y0 复制光标所在的那个字符到该行行首的所有数据# 2. 输入模式# 若想要编辑文本：启动Vim -&amp;gt; 命令模式-&amp;gt; 按下i切换到输入模式Enter 换行BACK SPACE 删除前一个字符DEL 删除后一个字符方向键 移动光标，上下左右HOME/END 行首/行尾Page Up/Page Down 上/下翻页Insert 切换光标为输入/替换模式，光标将变成竖线/下划线ESC 退出输入模式，切换到命令模式# 3. 底线命令模式（Last line mode）# 若要进入底线命令模式 ：命令模式 -&amp;gt; 按下:(英文冒号)切换到底线命令模式# 在底线命令模式中，:q # 退出程序:w # 保存文件:set nu # 设置行号2.常用操作创建文件# 创建文件vim runoob.txt以下操作均为命令模式全选复制剪切# 全选# gg - 光标移动到首行 v - 选择 G - 光标移动到尾行ggvG# 复制所在行yy# 全选复制 按Esc进入底部命令格式，输入ggyG# y - 复制ggyG# 删除【剪切】所在行dd# 删除【剪切】光标以下所有行dG# 删除【剪切】光标以上所有行dgg# 粘贴剪切板内容# p - 在光标后面粘贴剪切板内容 p光标移动操作# 光标站位# ← ↓ ↑ → h j k l# 移动光标到首行 H# 移动光标到尾行 L# 移动光标到中间位置 M插入操作# 在光标后插入a# 在当前行最后插入A# 在当前行下面新建一行,小写oo# 在当前行上面新建一行，大写OO# 在当前行插入另一个文件内容:r filename# 删除右边字符，小x; 删除左边多个字符为 nxx# 删除坐标字符，大X; 删除右边多个字符为 nXX# 全局格式# 1. 在Home文件下创建 ~/.vimrc文件vim ~/.vimrc# 写入set number # 设置行标syntax onset tabstop=4 # 设置缩进第四部分 网络配置​ 这一部分对于Linux网络配置进行介绍，Linux发行版有很多，每个发行版又有不同的版本，此处首先记录Ubuntu 20.04的网络配置。ubuntu 20.04的网络配置管理与前几个版本不同，其通过netplan进行网络配置管理。1.静态IP配置zheng@ubuntu:~/Desktop$ cd /etc/netplan/zheng@ubuntu:/etc/netplan$ ls01-network-manager-all.yaml 修改01-network-manager-all.yaml文件的内容# This is the network config written by &#39;subiquity&#39;network: # renderer: NetworkManager ethernets: ens33: dhcp4: no addresses: [192.168.135.129/24] optional: true gateway4: 192.168.135.0 nameservers: addresses: [114.114.114.114] 应用zheng@ubuntu:/etc/netplan$ sudo vim 01-network-manager-all.yaml zheng@ubuntu:/etc/netplan$ sudo netplan applyzheng@ubuntu:/etc/netplan$ ifconfigdocker0: flags=4099&amp;lt;UP,BROADCAST,MULTICAST&amp;gt; mtu 1500 inet 172.17.0.1 netmask 255.255.0.0 broadcast 172.17.255.255 ether 02:42:19:5e:ac:a3 txqueuelen 0 (以太网) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0ens33: flags=4163&amp;lt;UP,BROADCAST,RUNNING,MULTICAST&amp;gt; mtu 1500 inet 192.168.135.129 netmask 255.255.255.0 broadcast 192.168.135.255 inet6 fe80::20c:29ff:fef0:387f prefixlen 64 scopeid 0x20&amp;lt;link&amp;gt; ether 00:0c:29:f0:38:7f txqueuelen 1000 (以太网) RX packets 833 bytes 130736 (130.7 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 752 bytes 216300 (216.3 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&amp;lt;UP,LOOPBACK,RUNNING&amp;gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&amp;lt;host&amp;gt; loop txqueuelen 1000 (本地环回) RX packets 3382 bytes 258131 (258.1 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 3382 bytes 258131 (258.1 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 02.动态IP配置 修改01-network-manager-all.yaml文件的内容# This is the network config written by &#39;subiquity&#39;network: # renderer: NetworkManager ethernets: enp4s0: dhcp4: yes 应用sudo netplan apply3.Debian系统静态IP# 编辑INTERFACESvim /etc/network/interfacesauto eth0 # 开机自动连接网络,eth0为网卡号iface eth0 inet static #static表示使用固定ip，dhcp表述使用动态ipaddress 10.10.10.155 #设置ip地址netmask 255.255.255.0 #设置子网掩码gateway 10.10.10.2 #设置网关# 配置DNSvim /etc/resolv.conf nameserver 114.114.114.114service networking restart4.Debian系统动态IP# 编辑INTERFACESvim /etc/network/interfacesauto eth0 # 开机自动连接网络,eth0为网卡iface eth0 inet dhcp #static表示使用固定ip，dhcp表述使用动态ip第五部分 定时任务1.简介​ linux 系统则是由 cron (crond) 这个系统服务来控制的。Linux 系统上面原本就有非常多的计划性工作，因此这个系统服务是默认启动的。另 外, 由于使用者自己也可以设置计划任务，所以， Linux 系统也提供了使用者控制计划任务的命令 :crontab 命令。​ crond 是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程，与windows下的计划任务类似，当安装完成操作系统后，默认会安装此服务 工具，并且会自动启动crond进程，crond进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。启动：service cron start重启：service cron restart停止：service cron stop重新载入配置： service cron reload crontab -l #列出某个用户cron服务的详细内容crontab -r #删除某个用户的cron服务crontab file [-u user] #用指定的文件替代目前的crontab -e #编辑某个用户的cron服务crontab-c dir #指定crontab的目录ununtu 通过调用 run-parts 命令，定时运行四个目录下的所有脚本。1）/etc/cron.hourly，目录下的脚本会每个小时让执行一次，在每小时的2分钟时运行；2）/etc/cron.daily，目录下的脚本会每天让执行一次，在每天0点17分时运行；3）/etc/cron.weekly，目录下的脚本会每周让执行一次，在每周第七天的3点56分时运行；4）/etc/cron.mouthly，目录下的脚本会每月让执行一次，在每月19号的5点32分时运行；当然，以上的时间均是系统默认时间，可以根据自己的需求进行修改2.任务调度Linux下的任务调度分为两类，系统任务调度和用户任务调度。1.系统任务调度系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在/etc目录下有一个crontab文件，这个就是系统任务调度的配置文件。/etc/crontab文件包括下面几行：cat /etc/crontab# /etc/crontab: system-wide crontab# Unlike any other crontab you don&#39;t have to run the `crontab&#39;# command to install the new version when you edit this file# and files in /etc/cron.d. These files also have username fields,# that none of the other crontabs do.SHELL=/bin/shPATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed17 * * * * root cd / &amp;amp;&amp;amp; run-parts --report /etc/cron.hourly25 6 * * * root test -x /usr/sbin/anacron || ( cd / &amp;amp;&amp;amp; run-parts --report /etc/cron.daily )47 6 * * 7 root test -x /usr/sbin/anacron || ( cd / &amp;amp;&amp;amp; run-parts --report /etc/cron.weekly )52 6 1 * * root test -x /usr/sbin/anacron || ( cd / &amp;amp;&amp;amp; run-parts --report /etc/cron.monthly )#第一行指定shell，这里制定的是sh；第二行指定运行路径；第二行后面这里可能会有 MALITO内容，指定了crond的任务执行信息将通过电子邮件发送给root用户；如果没有或者为空，即不发送邮件；后面一段为执行定时任务的格式和任务； 这里也可以写run-part任务，后面详细讲述；2.用户任务调度用户任务调度：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的crontab 文件都被保存在 /var/spool/cron/crontabs 目录中。其文件名与用户名一致。 cat /var/spool/cron/crontabs/pi# DO NOT EDIT THIS FILE - edit the master and reinstall.# (/tmp/crontab.bXxQlk/crontab installed on Wed Oct 6 12:01:07 2021)# (Cron version -- $Id: crontab.c,v 2.13 1994/01/17 03:20:37 vixie Exp $)# Edit this file to introduce tasks to be run by cron.## Each task to run has to be defined through a single line# indicating with different fields when the task will be run# and what command to run for the task## To define the time you can provide concrete values for# minute (m), hour (h), day of month (dom), month (mon),# and day of week (dow) or use &#39;*&#39; in these fields (for &#39;any&#39;).## Notice that tasks will be started based on the cron&#39;s system# daemon&#39;s notion of time and timezones.## Output of the crontab jobs (including errors) is sent through# email to the user the crontab file belongs to (unless redirected).## For example, you can run a backup of all your user accounts# at 5 a.m every week with:# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/## For more information see the manual pages of crontab(5) and cron(8)## m h dom mon dow command*/1 * * * * date &amp;gt;&amp;gt; /tmp/test_cron.txt#*/1 * * * * python3 /home/pi/auto_mail/auto_mail.py在以上各个字段中，还可以使用以下特殊字符：星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。3.开机自启动# 查询systemctl list-unit-files |grep enabled# 设置某服务开机自启,一定要设置systemctl enable cron.service# 关闭某服务开机自启systemctl disable cron.service3.编写crontab文件# 执行该命令，会出现编辑工具选择，并开始编辑crontab文件# 普通用户编辑下，文件存放在 /var/spool/cron/crontabs/ 目录下，以用户名命名的文件crontab -e1.常用的实例# 实例1：每1分钟执行一次command*/1 * * * * command# 实例2：每小时的第3和第15分钟执行3,15 * * * * command# 实例3：在上午8点到11点的第3和第15分钟执行3,15 8-11 * * * command# 实例4：每隔两天的上午8点到11点的第3和第15分钟执行3,15 8-11 */2 * * command# 实例5：每个星期一的上午8点到11点的第3和第15分钟执行3,15 8-11 * * 1 command# 实例6：每晚的21:30重启smb 30 21 * * * /etc/init.d/smb restart# 实例7：每月1、10、22日的4 : 45重启smb 45 4 1,10,22 * * /etc/init.d/smb restart# 实例8：每周六、周日的1 : 10重启smb10 1 * * 6,0 /etc/init.d/smb restart# 实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb 0,30 18-23 * * * /etc/init.d/smb restart# 实例10：每星期六的晚上11 : 00 pm重启smb 0 23 * * 6 /etc/init.d/smb restart# 实例11：每一小时重启smb * */1 * * * /etc/init.d/smb restart# 实例12：晚上11点到早上7点之间，每隔一小时重启smb * 23-7/1 * * * /etc/init.d/smb restart# 实例13：每月的4号与每周一到周三的11点重启smb 0 11 4 * mon-wed /etc/init.d/smb restart# 实例14：一月一号的4点重启smb 0 4 1 jan * /etc/init.d/smb restart2.批量的实例# 实例15： 以root用户的身份，每小时执行/etc/cron.hourly目录内的脚本# 此时/etc/cron.hourly目录下的所有脚本都会被执行01 * * * * root run-parts /etc/cron.hourly说明：run-parts这个参数了，如果去掉这个参数的话，后面就可以写要运行的某个脚本名，而不是目录名了参考文档1.Ubuntu 20.04版本静态ip配置、动态ip配置、双网卡配置" }, { "title": "MySQL存储引擎", "url": "/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/", "categories": "数据库", "tags": "MySQL", "date": "2021-07-06 00:00:00 +0800", "snippet": "1.为什么使用索引假如给数据使用 二叉树 这样的数据结构进行存储，如下图所示2. 索引及其优缺点2.1 索引概述MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。索引的本质：索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。 这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 高级查找算法 。2.2 优点（1）类似大学图书馆建书目索引，提高数据检索的效率，降低 数据库的IO成本 ，这也是创建索引最主 要的原因。（2）通过创建唯一索引，可以保证数据库表中每一行 数据的唯一性 。（3）在实现数据的 参考完整性方面，可以 加速表和表之间的连接 。换句话说，对于有依赖关系的子表和父表联合查询时， 可以提高查询速度。（4）在使用分组和排序子句进行数据查询时，可以显著 减少查询中分组和排序的时 间 ，降低了CPU的消耗。2.3 缺点增加索引也有许多不利的方面，主要表现在如下几个方面：（1）创建索引和维护索引要 耗费时间 ，并 且随着数据量的增加，所耗费的时间也会增加。（2）索引需要占 磁盘空间 ，除了数据表占数据空间之 外，每一个索引还要占一定的物理空间， 存储在磁盘上 ，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。（3）虽然索引大大提高了查询速度，同时却会 降低更新表的速度 。当对表 中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。因此，选择使用索引时，需要综合考虑索引的优点和缺点。3. InnoDB中索引的推演3.1 索引之前的查找先来看一个精确匹配的例子：SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;1. 在一个页中的查找2. 在很多页中查找在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录 所在的页，所以只能 从第一个页 沿着 双向链表 一直往下找，在每一个页中根据我们上面的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是 超级耗时 的。如果一个表有一亿条记录呢？此时 索引 应运而生。3.2 设计索引建一个表：mysql&amp;gt; CREATE TABLE index_demo( c1 INT, c2 INT, c3 CHAR(1), PRIMARY KEY(c1)) ROW_FORMAT = Compact;这个新建的 index_demo 表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键， 这个表使用 Compact 行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图：我们只在示意图里展示记录的这几个部分： record_type ：记录头信息的一项属性，表示记录的类型， 0 表示普通记录、 2 表示最小记录、 3 表示最大记录、 1 暂时还没用过，下面讲。 next_record ：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用 箭头来表明下一条记录是谁。 各个列的值 ：这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2 和 c3 。 其他信息 ：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样：把一些记录放到页里的示意图就是：1. 一个简单的索引设计方案我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。如果 我们想快速的定位到需要查找的记录在哪些数据页 中该咋办？我们可以为快速定位记录所在的数据页而 建立一个目录 ，建这个目录必须完成下边这些事： 下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值 给所有的页建立一个目录项所以我们为上边几个页做好的目录就像这样子：以 页28 为例，它对应 目录项2 ，这个目录项中包含着该页的页号 28 以及该页中用户记录的最小主键值 5 。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键 值快速查找某条记录的功能了。比如：查找主键值为 20 的记录，具体查找过程分两步：1. 先从目录项中根据 二分法 快速确定出主键值为 `20 `的记录在 目录项3 中（因为 12 &amp;lt; 20 &amp;lt; 209 ），它对应的页是 页9 。 2. 再根据前边说的在页中查找记录的方式去 页9 中定位具体的记录。 至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为 索引 。2. InnoDB中的索引方案① 迭代1次：目录项纪录的页我们把前边使用到的目录项放到数据页中的样子就是这样：从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调 目录项记录 和普通的 用户记录 的不同点： 目录项记录 的 record_type 值是1，而 普通用户记录 的 record_type 值是0。 目录项记录只有 主键值和页的编号 两个列，而普通的用户记录的列是用户自己定义的，可能包含很 多列 ，另外还有InnoDB自己添加的隐藏列。 了解：记录头信息里还有一个叫 min_rec_mask 的属性，只有在存储 目录项记录 的页中的主键值最小的 目录项记录 的 min_rec_mask 值为 1 ，其他别的记录的 min_rec_mask 值都是 0 。相同点：两者用的是一样的数据页，都会为主键值生成 Page Directory （页目录），从而在按照主键值进行查找时可以使用 二分法 来加快查询速度。 现在以查找主键为 20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步： 先到存储 目录项记录 的页，也就是页30中通过 二分法 快速定位到对应目录项，因为 12 &amp;lt; 20 &amp;lt; 209 ，所以定位到对应的记录所在的页就是页9。 再到存储用户记录的页9中根据 二分法 快速定位到主键值为 20 的用户记录。② 迭代2次：多个目录项纪录的页从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页： 为存储该用户记录而新生成了 页31 。 因为原先存储目录项记录的 页30的容量已满 （我们前边假设只能存储4条目录项记录），所以不得 不需要一个新的 页32 来存放 页31 对应的目录项。现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步 骤，以查找主键值为 20 的记录为例：1.确定 目录项记录页 我们现在的存储目录项记录的页有两个，即 页30 和 页32 ，又因为页30表示的目录项的主键值的 范围是 [1, 320) ，页32表示的目录项的主键值不小于 320 ，所以主键值为 20 的记录对应的目 录项记录在 页30 中。2.通过目录项记录页 确定用户记录真实所在的页 。 在一个存储 目录项记录 的页中通过主键值定位一条目录项记录的方式说过了。3.在真实存储用户记录的页中定位到具体的记录③ 迭代3次：目录项记录页的目录页如图，我们生成了一个存储更高级目录项的 页33 ，这个页中的两条记录分别代表页30和页32，如果用 户记录的主键值在 [1, 320) 之间，则到页30中查找更详细的目录项记录，如果主键值 不小于320 的 话，就到页32中查找更详细的目录项记录。我们可以用下边这个图来描述它：这个数据结构，它的名称是 B+树 。④ B+Tree一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 0层， 之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页 最多存放3条记录 ，存放目录项 记录的页 最多存放4条记录 。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录 的叶子节点代表的数据页可以存放 100条用户记录 ，所有存放目录项记录的内节点代表的数据页可以存 放 1000条目录项记录 ，那么： 如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录 如果B+树有2层，最多能存放 1000×100=10,0000 条记录。 如果B+树有3层，最多能存放 1000×1000×100=1,0000,0000 条记录。 如果B+树有4层，最多能存放 1000×1000×1000×100=1000,0000,0000 条记录。相当多的记录！！！你的表里能存放 100000000000条记录吗？所以一般情况下，我们用到的B+树都不会超过4层 ，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又 因为在每个页面内有所谓的 Page Directory （页目录），所以在页面内也可以通过 二分法 实现快速 定位记录。3.3 常见索引概念索引按照物理实现方式，索引可以分为 2 种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集 索引称为二级索引或者辅助索引。1. 聚簇索引特点：1.使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义： 页内的记录是按照主键的大小顺序排成一个 单向链表 。 各个存放 用户记录的页 也是根据页中用户记录的主键大小顺序排成一个 双向链表 。 存放 目录项记录的页 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键 大小顺序排成一个 双向链表 。2.B+树的 叶子节点 存储的是完整的用户记录。 所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。优点： 数据访问更快 ，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快 聚簇索引对于主键的 排序查找 和 范围查找 速度非常快 按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多 个数据块中提取数据，所以 节省了大量的io操作 。缺点： 插入速度严重依赖于插入顺序 ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键 更新主键的代价很高 ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为 不可更新 二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据2. 二级索引（辅助索引、非聚簇索引）概念：回表 我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根 据c2列的值查找到完整的用户记录的话，仍然需要到 聚簇索引 中再查一遍，这个过程称为 回表 。也就 是根据c2列的值查询一条完整的用户记录需要使用到 2 棵B+树！问题：为什么我们还需要一次 回表 操作呢？直接把完整的用户记录放到叶子节点不OK吗？3. 联合索引我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照 c2和c3列 的大小进行排序，这个包含两层含义： 先把各个记录和页按照c2列进行排序。 在记录的c2列相同的情况下，采用c3列进行排序注意一点，以c2和c3列的大小为排序规则建立的B+树称为 联合索引 ，本质上也是一个二级索引。它的意 思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下： 建立 联合索引 只会建立如上图一样的1棵B+树。 为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。3.4 InnoDB的B+树索引的注意事项1. 根页面位置万年不动2. 内节点中目录项记录的唯一性3. 一个页面最少存储2条记录4. MyISAM中的索引方案B树索引适用存储引擎如表所示： 索引 / 存储引擎 MyISAM InnoDB Memory B-Tree索引 支持 支持 支持 即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索 引是Btree索引；而Memory默认的索引是Hash索引。MyISAM引擎使用 B+Tree 作为索引结构，叶子节点的data域存放的是 数据记录的地址 。4.1 MyISAM索引的原理下图是MyISAM索引的原理图。如果我们在Col2上建立一个二级索引，则此索引的结构如下图所示：4.2 MyISAM 与 InnoDB对比MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。小结两种引擎中索引的区别：① 在InnoDB存储引擎中，我们只需要根据主键值对 聚簇索引 进行一次查找就能找到对应的记录，而在 MyISAM 中却需要进行一次 回表 操作，意味着MyISAM中建立的索引相当于全部都是 二级索引 。② InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是 分离的 ，索引文件仅保存数据记录的地址。③ InnoDB的非聚簇索引data域存储相应记录 主键的值 ，而MyISAM索引记录的是地址 。换句话说， InnoDB的所有非聚簇索引都引用主键作为data域。④ MyISAM的回表操作是十分 快速 的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通 过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。⑤ InnoDB要求表 必须有主键 （ MyISAM可以没有 ）。如果没有显式指定，则MySQL系统会自动选择一个 可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐 含字段作为主键，这个字段长度为6个字节，类型为长整型。5. 索引的代价索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：空间上的代价 每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会 占用 16KB 的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。时间上的代价每次对表中的数据进行 增、删、改 操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每 层节点都是按照索引列的值 从小到大的顺序排序 而组成了 双向链表 。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序 而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需 要额外的时间进行一些 记录移位 ， 页面分裂 、 页面回收 等操作来维护好节点和记录的排序。如果 我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。6. MySQL数据结构选择的合理性​ 从MySQL的角度讲，不得不考虑一个现实的问题，就是磁盘IO。如果我们能让索引的数据结构尽量减少磁盘的IO操作，所消耗的时间也就越小。可以说，磁盘的IO操作此数据对索引的使用效率至关重要。​ 查找都是索引操作，一般来说，索引非常大，尤其是关系型数据库，当数据量比较大的时候，索引的大小有可能几个G甚至更多，为了减少索引在内存中的占用，数据库索引是存储在外部磁盘上的。当我们利用索引查询的时候，不可能把整个索引全部加载到内存，只能逐一加载，那么MySQL衡量查询效率的标准就是IO次数6.1 全表遍历这里都懒得说了。6.2 Hash结构上图中哈希函数h有可能将两个不同的关键字映射到相同的位置，这叫做 碰撞 ，在数据库中一般采用 链 接法 来解决。在链接法中，将散列到同一槽位的元素放在一个链表中，如下图所示实验：体会数组和hash表的查找方面的效率区别// 算法复杂度为 O(n)@Testpublic void test1(){ int[] arr = new int[100000]; for(int i = 0;i &amp;lt; arr.length;i++){ arr[i] = i + 1; } long start = System.currentTimeMillis(); for(int j = 1; j&amp;lt;=100000;j++){ int temp = j; for(int i = 0;i &amp;lt; arr.length;i++){ if(temp == arr[i]){ break; } } } long end = System.currentTimeMillis(); System.out.println(&quot;time： &quot; + (end - start)); //time： 823}//算法复杂度为 O(1)@Testpublic void test2(){ HashSet&amp;lt;Integer&amp;gt; set = new HashSet&amp;lt;&amp;gt;(100000); for(int i = 0;i &amp;lt; 100000;i++){ set.add(i + 1); } long start = System.currentTimeMillis(); for(int j = 1; j&amp;lt;=100000;j++) { int temp = j; boolean contains = set.contains(temp); } long end = System.currentTimeMillis(); System.out.println(&quot;time： &quot; + (end - start)); //time： 5}Hash结构效率高，那为什么索引结构要设计成树型呢？原因1： Hash索引仅能满足=和IN查询。如果进行范围查询，哈希索引的时间复杂度退化为O(n)；而树形的有序特性，依然能够保持O(log2N)的高效率。原因2：Hash索引还有一个缺陷，数据存储是没有顺序的，在ORDER BY的情况下，使用Hash索引还需要对数据重新排序。原因3：对于联合索引的情况，Hash值是将联合索引键合并后一起来计算的，无法对单独的一个键或者几个索引键进行查询。原因4：对于等值查询来说，通常Hash索引的效率更高，不过也存在一种情况，就是索引列的重复值如果很多，效率就会降低。这是因为遇到Hash冲突时，需要遍历桶中的行指针来进行比较，找到查询的关键字，非常耗时。所以，Hash索引通常不会用到重复值多的列上，比如列为性别、年龄的情况等。Hash索引适用存储引擎如表所示： 索引 / 存储引擎 MyISAM InnoDB Memory HASH索引 不支持 不支持 支持 Hash索引的适用性：​ Hash所以存在着很多限制，相比之下在数据库中B+树索引的使用面会更广，不过也有一些场景才有Hash索引效率更高，比如在键值（key-value）类型的数据库中，Redis存储的核心就是Hash表​ MySQL中的Memory存储引擎支持Hash存储，如果我们需要用到查询的临时表时，就可以选择memory存储引擎，把某个字段设置为Hash索引，比如字符串类型的字段，进行Hash计算之后长度可以缩短到几个字节。当字段的重复度低，而且经常需要进行等值查询的时候，采用Hash索引是个不错的选择。​ 另外，InnoDB本身不支持Hash索引，但是提供了自适应Hash索引(Adaptive Hash Index)。什么情况下才会使用自适应Hash索引呢？如果某个数据经常被访问，当满足一定条件的时候，就会将这个数据也的地址存放到Hash表中。这样下次查询的时候，就可以直接找到这个页面的所在位置。这样让B+树叶具备了Hash索引的优点。采用自适应 Hash 索引目的是方便根据 SQL 的查询条件加速定位到叶子节点，特别是当 B+ 树比较深的时 候，通过自适应 Hash 索引可以明显提高数据的检索效率。我们可以通过 innodb_adaptive_hash_index 变量来查看是否开启了自适应 Hash，比如：mysql&amp;gt; show variables like &#39;%adaptive_hash_index&#39;;6.3 二叉搜索树如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。1. 二叉搜索树的特点2. 查找规则创造出来的二分搜索树如下图所示：为了提高查询效率，就需要 减少磁盘IO数 。为了减少磁盘IO的次数，就需要尽量 降低树的高度 ，需要把 原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好6.4 AVL树平衡二叉树是基于二分法的策略提高数据的查找速度的二叉树的数据结构。平衡二叉树是采用二分法思维把数据按规则组装成一个树形结构的数据，用这个树形结构的数据减少无关数据的检索，大大的提升了数据检索的速度；平衡二叉树的数据结构组装过程有以下规则：（1）非叶子节点只能允许最多两个子节点存在。（2）每一个非叶子节点数据分布规则为左边的子节点小当前节点的值，右边的子节点大于当前节点的值(这里值是基于自己的算法规则而定的，比如hash值)；【左边放小数，右边放大数】针对同样的数据，如果我们把二叉树改成 M 叉树 （M&amp;gt;2）呢？当 M=3 时，同样的 31 个节点可以由下面 的三叉树来进行存储：6.5 B-TreeB树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个）B 树的结构如下图所示：一个 M 阶的 B 树（M&amp;gt;2）有以下的特性：1.根节点的儿子数的范围是 [2,M]。2.每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 = 关键字的数量 +1，k 的取值范围为 [ceil(M/2), M]。3.叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M/2), M]。4.假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i]&amp;lt;Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …, P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k] 指向关键字大于 Key[k-1] 的子树。 5. 所有叶子节点位于同一层。5.所有叶子节点位于同一层。上面那张图所表示的 B 树就是一棵 3 阶的 B 树。我们可以看下磁盘块 2，里面的关键字为（8，12），它 有 3 个孩子 (3，5)，(9，10) 和 (13，15)，你能看到 (3，5) 小于 8，(9，10) 在 8 和 12 之间，而 (13，15) 大于 12，刚好符合刚才我们给出的特征。然后我们来看下如何用 B 树进行查找。假设我们想要 查找的关键字是 9 ，那么步骤可以分为以下几步：1.我们与根节点的关键字 (17，35）进行比较，9 小于 17 那么得到指针 P1；2.按照指针 P1 找到磁盘块 2，关键字为（8，12），因为 9 在 8 和 12 之间，所以我们得到指针 P2；3.按照指针 P2 找到磁盘块 6，关键字为（9，10），然后我们找到了关键字 9。你能看出来在 B 树的搜索过程中，我们比较的次数并不少，但如果把数据读取出来然后在内存中进行比 较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行 I/O 操作，消耗的时间比在内存中进行 比较所需要的时间要多，是数据查找用时的重要因素。 B 树相比于平衡二叉树来说磁盘 I/O 操作要少 ， 在数据查询中比平衡二叉树效率要高。所以 只要树的高度足够低，IO次数足够少，就可以提高查询性能。再举例1：节点插入定义一个5阶树（平衡5路查找树;），现在我们要把3、8、31、11、23、29、50、28 这些数字构建出一个5阶树出来;遵循规则：（1）节点拆分规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须&amp;lt;=5-1（这里关键字数&amp;gt;4就要进行节点拆分）；（2）排序规则：满足节点本身比左边节点大，比右边节点小的排序规则;先插入 3、8、31、11再插入23、29再插入50、28节点删除1）节点合并规则：当前是要组成一个5路查找树，那么此时m=5,关键字数必须大于等于ceil（5/2）（这里关键字数&amp;lt;2就要进行节点合并）；（2）满足节点本身比左边节点大，比右边节点小的排序规则;（3）关键字数小于二时先从子节点取，子节点没有符合条件时就向向父节点取，取中间值往父节点放；B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度;6.6 B+TreeMySQL官网说明：B+ 树和 B 树的差异：1.有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 = 关键字数，而 B 树中，孩子数量 = 关键字数 +1。2.非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最 小）。3.非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中， 非 叶子节点既保存索引，也保存数据记录 。4.所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大 小从小到大顺序链接。B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。 但B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然。1.概念B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。为什么说B+树查找的效率要比B树更高、更稳定；我们先看看两者的区别2.规则（1）B+跟B树不同，B+树的非叶子节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个非叶子节点所能保存的关键字大大增加；（2）B+树叶子节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；（3）B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。（4）非叶子节点的子节点数=关键字数（来源百度百科）（根据各种资料 这里有两种算法的实现方式，另一种为非叶节点的关键字数=子节点数-1（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的Mysql 的B+树是用第一种方式实现）;3.特点1、B+树的层级更少：相较于B树，B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；2、B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;3、B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。4、B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。B树相对于B+树的优点是，如果经常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字和其数据的地址，所以这种数据检索的时候会要比B+树快。6.7 R树R-Tree在MySQL很少使用，仅支持 geometry数据类型 ，支持该类型的存储引擎只有myisam、bdb、 innodb、ndb、archive几种。举个R树在现实领域中能够解决的例子：查找20英里以内所有的餐厅。如果 没有R树你会怎么解决？一般情况下我们会把餐厅的坐标(x,y)分为两个字段存放在数据库中，一个字段记 录经度，另一个字段记录纬度。这样的话我们就需要遍历所有的餐厅获取其位置信息，然后计算是否满 足要求。如果一个地区有100家餐厅的话，我们就要进行100次位置计算操作了，如果应用到谷歌、百度 地图这种超大数据库中，这种方法便必定不可行了。R树就很好的 解决了这种高维空间搜索问题 。它把B 树的思想很好的扩展到了多维空间，采用了B树分割空间的思想，并在添加、删除操作时采用合并、分解 结点的方法，保证树的平衡性。因此，R树就是一棵用来 存储高维数据的平衡树 。相对于B-Tree，R-Tree 的优势在于范围查找。 索引 / 存储引擎 MyISAM InnoDB Memory R-Tree索引 支持 支持 不支持 附录：算法的时间复杂度同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在 于选择合适算法和改进算法" }, { "title": "MySQL存储引擎", "url": "/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/", "categories": "数据库", "tags": "MySQL", "date": "2021-07-05 00:00:00 +0800", "snippet": "1. 查看存储引擎查看mysql提供什么存储引擎：mysql&amp;gt; show engines;+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| Engine | Support | Comment | Transactions | XA | Savepoints |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| ARCHIVE | YES | Archive storage engine | NO | NO | NO || BLACKHOLE | YES | /dev/null storage engine (anything you write to it disappears) | NO | NO | NO || MRG_MYISAM | YES | Collection of identical MyISAM tables | NO | NO | NO || FEDERATED | NO | Federated MySQL storage engine | NULL | NULL | NULL || MyISAM | YES | MyISAM storage engine | NO | NO | NO || PERFORMANCE_SCHEMA | YES | Performance Schema | NO | NO | NO || InnoDB | DEFAULT | Supports transactions, row-level locking, and foreign keys | YES | YES | YES || MEMORY | YES | Hash based, stored in memory, useful for temporary tables | NO | NO | NO || CSV | YES | CSV storage engine | NO | NO | NO |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+9 rows in set (0.00 sec)2. 设置系统默认的存储引擎# 查询SELECT @@default_storage_engine;+--------------------------+| @@default_storage_engine |+--------------------------+| InnoDB |+--------------------------+1 row in set (0.00 sec)修改默认的存储引擎如果在创建表的语句中没有显式指定表的存储引擎的话，那就会默认使用 InnoDB 作为表的存储引擎。 如果我们想改变表的默认存储引擎的话，可以这样写启动服务器的命令行：SET DEFAULT_STORAGE_ENGINE=MyISAM;或者修改 my.cnf 文件：default-storage-engine=MyISAM# 重启服务systemctl restart mysqld.service3. 设置表的存储引擎​ 存储引擎是负责对表中的数据进行提取和写入工作的，我们可以为 不同的表设置不同的存储引擎 ，也就是 说不同的表可以有不同的物理存储结构，不同的提取和写入方式。3.1 创建表时指定存储引擎我们之前创建表的语句都没有指定表的存储引擎，那就会使用默认的存储引擎 InnoDB 。如果我们想显 式的指定一下表的存储引擎，那可以这么写：CREATE TABLE 表名(建表语句;) ENGINE = 存储引擎名称;3.2 修改表的存储引擎如果表已经建好了，我们也可以使用下边这个语句来修改表的存储引擎：ALTER TABLE 表名 ENGINE = 存储引擎名称;比如我们修改一下 engine_demo_table 表的存储引擎：mysql&amp;gt; ALTER TABLE engine_demo_table ENGINE = InnoDB;Query OK, 0 rows affected (0.05 sec)Records: 0 Duplicates: 0 Warnings: 0这时我们再查看一下 engine_demo_table 的表结构：mysql&amp;gt; SHOW CREATE TABLE engine_demo_table\\G*************************** 1. row ***************************Table: engine_demo_tableCreate Table: CREATE TABLE `engine_demo_table` (`i` int(11) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf81 row in set (0.01 sec)4. 引擎介绍4.1 InnoDB 引擎：具备外键支持功能的事务存储引擎 MySQL从3.23.34a开始就包含InnoDB存储引擎。 大于等于5.5之后，默认采用InnoDB引擎 。 InnoDB是MySQL的 默认事务型引擎 ，它被设计用来处理大量的短期(short-lived)事务。可以确保事务 的完整提交(Commit)和回滚(Rollback)。 除了增加和查询外，还需要更新、删除操作，那么，应优先选择InnoDB存储引擎。 除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。 数据文件结构：（在《第02章_MySQL数据目录》章节已讲） 表名.frm 存储表结构（MySQL8.0时，合并在表名.ibd中） 表名.ibd 存储数据和索引 InnoDB是 为处理巨大数据量的最大性能设计 。 在以前的版本中，字典数据以元数据文件、非事务表等来存储。现在这些元数据文件被删除 了。比如： .frm ， .par ， .trn ， .isl ， .db.opt 等都在MySQL8.0中不存在了。 对比MyISAM的存储引擎， InnoDB写的处理效率差一些 ，并且会占用更多的磁盘空间以保存数据和 索引。 MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据， 对内存要求较高 ，而且内存大小对性能有决定性的影响。4.2 MyISAM 引擎：主要的非事务处理存储引擎 MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM 不支持事务、行级 锁、外键 ，有一个毫无疑问的缺陷就是 崩溃后无法安全恢复 。 5.5之前默认的存储引擎 优势是访问的 速度快 ，对事务完整性没有要求或者以SELECT、INSERT为主的应用 针对数据统计有额外的常数存储。故而 count(*) 的查询效率很高 数据文件结构：（在《第02章_MySQL数据目录》章节已讲） 表名.frm 存储表结构 表名.MYD 存储数据 (MYData) 表名.MYI 存储索引 (MYIndex) 应用场景：只读应用或者以读为主的业务4.3 Archive 引擎：用于数据存档下表展示了ARCHIVE 存储引擎功能4.4 Blackhole 引擎：丢弃写操作，读操作会返回空内容4.5 CSV 引擎：存储数据时，以逗号分隔各个数据项使用案例如下mysql&amp;gt; CREATE TABLE test (i INT NOT NULL, c CHAR(10) NOT NULL) ENGINE = CSV;Query OK, 0 rows affected (0.06 sec)mysql&amp;gt; INSERT INTO test VALUES(1,&#39;record one&#39;),(2,&#39;record two&#39;);Query OK, 2 rows affected (0.05 sec)Records: 2 Duplicates: 0 Warnings: 0创建CSV表还会创建相应的 元文件 ，用于 存储表的状态 和 表中存在的行数 。此文件的名称与表的名称相 同，后缀为 CSM 。如图所示如果检查 test.CSV 通过执行上述语句创建的数据库目录中的文件，其内容使用Notepad++打开如下：&quot;1&quot;,&quot;record one&quot;&quot;2&quot;,&quot;record two&quot;这种格式可以被 Microsoft Excel 等电子表格应用程序读取，甚至写入。4.6 Memory 引擎：置于内存的表​ 概述：Memory采用的逻辑介质是 内存 ， 响应速度很快 ，但是当mysqld守护进程崩溃的时候 数据会丢失 。另 外，要求存储的数据是数据长度不变的格式，比如，Blob和Text类型的数据不可用(长度不固定的)。主要特征： Memory同时 支持哈希（HASH）索引 和 B+树索引 。 Memory表至少比MyISAM表要 快一个数量级 。 MEMORY 表的大小是受到限制 的。表的大小主要取决于两个参数，分别是 max_rows 和 max_heap_table_size 。其中，max_rows可以在创建表时指定；max_heap_table_size的大小默 认为16MB，可以按需要进行扩大。 数据文件与索引文件分开存储。 缺点：其数据易丢失，生命周期短。基于这个缺陷，选择MEMORY存储引擎时需要特别小心。使用Memory存储引擎的场景：1.目标数据比较小 ，而且非常 频繁的进行访问 ，在内存中存放数据，如果太大的数据会造成 内存溢 出 。可以通过参数 max_heap_table_size 控制Memory表的大小，限制Memory表的最大的大 小。2.如果 数据是临时的 ，而且 必须立即可用 得到，那么就可以放在内存中。3.存储在Memory表中的数据如果突然间 丢失的话也没有太大的关系 。4.7 Federated 引擎：访问远程表Federated引擎是访问其他MySQL服务器的一个 代理 ，尽管该引擎看起来提供了一种很好的 跨服务 器的灵活性 ，但也经常带来问题，因此 默认是禁用的 。4.8 Merge引擎：管理多个MyISAM表构成的表集合4.9 NDB引擎：MySQL集群专用存储引擎​ 也叫做 NDB Cluster 存储引擎，主要用于 MySQL Cluster 分布式集群 环境，类似于 Oracle 的 RAC 集 群。4.10 引擎对比MySQL中同一个数据库，不同的表可以选择不同的存储引擎。如下表对常用存储引擎做出了对比。 特点 MyISAM InnoDB MEMORY MERGE NDB 存储限制 有 64TB 有 没有 有 事物安全性   支持       锁机制 表锁，及时操作一条记录也会锁住整个表；不适合高并发 行锁，操作时只锁某一行，不对其他行有影响，适合高并发 表锁 表锁 行锁 B树索引 支持 支持 支持 支持 支持 哈希索引     支持   支持 全文索引 支持         集群索引   支持       数据缓存   支持 支持   支持 索引缓存 只缓存索引，不缓存数据 不仅缓存索引，还要缓存真实数据，对内存要求较高，而且内存对性能有决定性影响 支持 支持 支持 数据可压缩 支持         空间使用 低 高 N/A 低 低 内存使用 低 高 中等 低 高 批量掺入的速度 高 低 高 高 高 支持外键   支持       这些东西没必要立即就给记住，列出来的目的就是想让大家明白不同的存储引擎支持不同的功能。​ 其实我们最常用的就是 InnoDB 和 MyISAM ，有时会提一下Memory 。其中 InnoDB 是 MySQL 默认的存 储引擎。5. MyISAM和InnoDB很多人对 InnoDB 和 MyISAM 的取舍存在疑问，到底选择哪个比较好呢？MySQL5.5之前的默认存储引擎是MyISAM，5.5之后改为了InnoDB。6. 阿里巴巴、淘宝用哪个 Percona 为 MySQL 数据库服务器进行了改进，在功能和性能上较 MySQL 有很显著的提升。 该版本提升了在高负载情况下的 InnoDB 的性能、为 DBA 提供一些非常有用的性能诊断工具；另外 有更多的参数和命令来控制服务器行为。 该公司新建了一款存储引擎叫 Xtradb 完全可以替代 Innodb ，并且在性能和并发上做得更好 阿里巴巴大部分mysql数据库其实使用的percona的原型加以修改。课外补充：1、InnoDB表的优势​ InnoDB存储引擎在实际应用中拥有诸多优势，比如操作便利、提高了数据库的性能、维护成本低等。如 果由于硬件或软件的原因导致服务器崩溃，那么在重启服务器之后不需要进行额外的操作。InnoDB崩溃 恢复功能自动将之前提交的内容定型，然后撤销没有提交的进程，重启之后继续从崩溃点开始执行。​ InnoDB存储引擎在主内存中维护缓冲池，高频率使用的数据将在内存中直接被处理。这种缓存方式应用 于多种信息，加速了处理进程。​ 在专用服务器上，物理内存中高达80%的部分被应用于缓冲池。如果需要将数据插入不同的表中，可以 设置外键加强数据的完整性。更新或者删除数据，关联数据将会被自动更新或删除。如果试图将数据插 入从表，但在主表中没有对应的数据，插入的数据将被自动移除。如果磁盘或内存中的数据出现崩溃， 在使用脏数据之前，校验和机制会发出警告。当每个表的主键都设置合理时，与这些列有关的操作会被 自动优化。插入、更新和删除操作通过做改变缓冲自动机制进行优化。 InnoDB不仅支持当前读写，也会 缓冲改变的数据到数据流磁盘 。​ InnoDB的性能优势不只存在于长时运行查询的大型表。在同一列多次被查询时，自适应哈希索引会提高 查询的速度。使用InnoDB可以压缩表和相关的索引，可以 在不影响性能和可用性的情况下创建或删除索 引 。对于大型文本和BLOB数据，使用动态行形式，这种存储布局更高效。通过查询 INFORMATION_SCHEMA库中的表可以监控存储引擎的内部工作。在同一个语句中，InnoDB表可以与其他 存储引擎表混用。即使有些操作系统限制文件大小为2GB，InnoDB仍然可以处理。 当处理大数据量时， InnoDB兼顾CPU，以达到最大性能 。2、InnoDB和ACID模型​ ACID模型是一系列数据库设计规则，这些规则着重强调可靠性，而可靠性对于商业数据和任务关键型应 用非常重要。MySQL包含类似InnoDB存储引擎的组件，与ACID模型紧密相连，这样出现意外时，数据不 会崩溃，结果不会失真。如果依赖ACID模型，可以不使用一致性检查和崩溃恢复机制。如果拥有额外的 软件保护，极可靠的硬件或者应用可以容忍一小部分的数据丢失和不一致，可以将MySQL设置调整为只 依赖部分ACID特性，以达到更高的性能。下面讲解InnoDB存储引擎与ACID模型相同作用的四个方面。1. 原子方面ACID的原子方面主要涉及InnoDB事务，与MySQL相关的特性主要包括： 自动提交设置。 COMMIT语句。 ROLLBACK语句。 操作INFORMATION_SCHEMA库中的表数据。2. 一致性方面ACID模型的一致性主要涉及保护数据不崩溃的内部InnoDB处理过程，与MySQL相关的特性 主要包括： InnoDB双写缓存。 InnoDB崩溃恢复。3. 隔离方面隔离是应用于事务的级别，与MySQL相关的特性主要包括： 自动提交设置。 SET ISOLATION LEVEL语句。 InnoDB锁的低级别信息。4. 耐久性方面ACID模型的耐久性主要涉及与硬件配置相互影响的MySQL软件特性。由于硬件复杂多样 化，耐久性方面没有具体的规则可循。与MySQL相关的特性有： InnoDB双写缓存，通过innodb_doublewrite配置项配置。 配置项innodb_flush_log_at_trx_commit。 配置项sync_binlog。 配置项innodb_file_per_table。 存储设备的写入缓存。 存储设备的备用电池缓存。 运行MySQL的操作系统。 持续的电力供应。 备份策略。 对分布式或托管的应用，最主要的在于硬件设备的地点以及网络情况。3、InnoDB架构1. 缓冲池缓冲池是主内存中的一部分空间，用来缓存已使用的表和索引数据。缓冲池使得经常被使用的 数据能够直接在内存中获得，从而提高速度。2.更改缓存更改缓存是一个特殊的数据结构，当受影响的索引页不在缓存中时，更改缓存会缓存辅助索 引页的更改。索引页被其他读取操作时会加载到缓存池，缓存的更改内容就会被合并。不同于集群索 引，辅助索引并非独一无二的。当系统大部分闲置时，清除操作会定期运行，将更新的索引页刷入磁 盘。更新缓存合并期间，可能会大大降低查询的性能。在内存中，更新缓存占用一部分InnoDB缓冲池。 在磁盘中，更新缓存是系统表空间的一部分。更新缓存的数据类型由innodb_change_buffering配置项管 理。3. 自适应哈希索引自适应哈希索引将负载和足够的内存结合起来，使得InnoDB像内存数据库一样运行， 不需要降低事务上的性能或可靠性。这个特性通过innodb_adaptive_hash_index选项配置，或者通过– skip-innodb_adaptive_hash_index命令行在服务启动时关闭。4. 重做日志缓存重做日志缓存存放要放入重做日志的数据。重做日志缓存大小通过 innodb_log_buffer_size配置项配置。重做日志缓存会定期地将日志文件刷入磁盘。大型的重做日志缓存 使得大型事务能够正常运行而不需要写入磁盘。5. 系统表空间系统表空间包括InnoDB数据字典、双写缓存、更新缓存和撤销日志，同时也包括表和索引 数据。多表共享，系统表空间被视为共享表空间。6. 双写缓存双写缓存位于系统表空间中，用于写入从缓存池刷新的数据页。只有在刷新并写入双写缓存 后，InnoDB才会将数据页写入合适的位置。7. 撤销日志撤销日志是一系列与事务相关的撤销记录的集合，包含如何撤销事务最近的更改。如果其他 事务要查询原始数据，可以从撤销日志记录中追溯未更改的数据。撤销日志存在于撤销日志片段中，这 些片段包含于回滚片段中。8. 每个表一个文件的表空间每个表一个文件的表空间是指每个单独的表空间创建在自身的数据文件中， 而不是系统表空间中。这个功能通过innodb_file_per_table配置项开启。每个表空间由一个单独的.ibd数 据文件代表，该文件默认被创建在数据库目录中。9. 通用表空间使用CREATE TABLESPACE语法创建共享的InnoDB表空间。通用表空间可以创建在MySQL数 据目录之外能够管理多个表并支持所有行格式的表。10. 撤销表空间撤销表空间由一个或多个包含撤销日志的文件组成。撤销表空间的数量由 innodb_undo_tablespaces配置项配置。11. 临时表空间用户创建的临时表空间和基于磁盘的内部临时表都创建于临时表空间。 innodb_temp_data_file_path配置项定义了相关的路径、名称、大小和属性。如果该值为空，默认会在 innodb_data_home_dir变量指定的目录下创建一个自动扩展的数据文件。12. 重做日志重做日志是基于磁盘的数据结构，在崩溃恢复期间使用，用来纠正数据。正常操作期间， 重做日志会将请求数据进行编码，这些请求会改变InnoDB表数据。遇到意外崩溃后，未完成的更改会自 动在初始化期间重新进行" }, { "title": "MySQL逻辑架构", "url": "/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/", "categories": "数据库", "tags": "MySQL", "date": "2021-07-04 00:00:00 +0800", "snippet": "1. 逻辑架构剖析1.1 服务器处理客户端请求那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？这里以查询请求为 例展示：下面具体展开看一下：1.2 第1层：连接层​ 系统（客户端）访问 MySQL 服务器前，做的第一件事就是建立 TCP 连接。 经过三次握手建立连接成功后， MySQL 服务器对 TCP 传输过来的账号密码做身份认证、权限获取。 用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行 用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依 赖于此时读到的权限TCP 连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后 面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。1.3 第2层：服务层 SQL Interface: SQL接口 接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT … FROM就是调用SQL Interface MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定 义函数等多种SQL语言接口 Parser: 解析器 在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构 传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。 在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建 语法树 ，并根据数据字 典丰富查询语法树，会 验证该客户端是否具有执行该查询的权限 。创建好语法树后，MySQL还 会对SQl查询进行语法上的优化，进行查询重写。 Optimizer: 查询优化器 SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个 执行计划 。 这个执行计划表明应该 使用哪些索引 进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将 查询结果返回给用户。 它使用“ 选取-投影-连接 ”策略进行查询。例如： SELECT id,name FROM student WHERE gender = &#39;女&#39;; ​ 这个SELECT查询先根据WHERE语句进行 选取 ，而不是将表全部查询出来以后再进行gender过 滤。 这个SELECT查询先根据id和name进行属性 投影 ，而不是将属性全部取出以后再进行过滤，将这两个查询条件 连接 起来生成最终查询结果。 Caches &amp;amp; Buffers： 查询缓存组件 MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过 程了，直接将结果反馈给客户端。 这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。 这个查询缓存可以在 不同客户端之间共享 。 从MySQL 5.7.20开始，不推荐使用查询缓存，并在 MySQL 8.0中删除 。 小故事： 如果我问你9+8×16-3×2×17的值是多少，你可能会用计算器去算一下，最终结果35。如果再问你一遍9+8×16- 3×2×17的值是多少，你还用再傻呵呵的再算一遍吗？我们刚刚已经算过了，直接说答案就好了。1.4 第3层：引擎层​ 插件式存储引擎层（ Storage Engines），真正的负责了MySQL中数据的存储和提取，对物理服务器级别 维护的底层数据执行操作，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样 我们可以根据自己的实际需要进行选取。 MySQL 8.0.25默认支持的存储引擎如下：mysql&amp;gt; show engines;+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| Engine | Support | Comment | Transactions | XA | Savepoints |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| ARCHIVE | YES | Archive storage engine | NO | NO | NO || BLACKHOLE | YES | /dev/null storage engine (anything you write to it disappears) | NO | NO | NO || MRG_MYISAM | YES | Collection of identical MyISAM tables | NO | NO | NO || FEDERATED | NO | Federated MySQL storage engine | NULL | NULL | NULL || MyISAM | YES | MyISAM storage engine | NO | NO | NO || PERFORMANCE_SCHEMA | YES | Performance Schema | NO | NO | NO || InnoDB | DEFAULT | Supports transactions, row-level locking, and foreign keys | YES | YES | YES || MEMORY | YES | Hash based, stored in memory, useful for temporary tables | NO | NO | NO || CSV | YES | CSV storage engine | NO | NO | NO |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+9 rows in set (0.00 sec)1.5 存储层​ 所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在 文件系统 上，以 文件 的方式存 在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设 备，但现代文件系统的实现使得这样做没有必要了。在文件系统之下，可以使用本地磁盘，可以使用 DAS、NAS、SAN等各种存储系统。1.6 小结MySQL架构图本节开篇所示。下面为了熟悉SQL执行流程方便，我们可以简化如下：简化为三层结构： 连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端； SQL 层（服务层）：对 SQL 语句进行查询处理；与数据库文件的存储方式无关； 存储引擎层：与数据库文件打交道，负责数据的存储和读取。2.SQL执行流程2.1 MySQL 中的 SQL执行流程MySQL的查询流程：1.查询缓存：Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端；如果没 有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高，所以在 MySQL8.0 之后就抛弃 了这个功能。大多数情况查询缓存就是个鸡肋，为什么呢？SELECT employee_id,last_name FROM employees WHERE employee_id = 101;​ 查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在 MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。这就意味着查询匹配的 鲁棒性大大降低 ，只有 相同的查询操作才会命中查询缓存 。两个查询请求在任何字符上的不同（例如：空格、注释、 大小写），都会导致缓存不会命中。因此 MySQL 的 查询缓存命中率不高 。 同时，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql 、 information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。以某些系统函数 举例，可能同样的函数的两次调用会产生不一样的结果，比如函数 NOW ，每次调用都会产生最新的当前 时间，如果在一个查询请求中调用了这个函数，那即使查询请求的文本信息都一样，那不同时间的两次 查询也应该得到不同的结果，如果在第一次查询时就缓存了，那第二次查询的时候直接使用第一次查询 的结果就是错误的！​ 此外，既然是缓存，那就有它 缓存失效的时候 。MySQL的缓存系统会监测涉及到的每张表，只要该表的 结构或者数据被修改，如对该表使用了 INSERT 、 UPDATE 、 DELETE 、 TRUNCATE TABLE 、 ALTER TABLE 、 DROP TABLE 或 DROP DATABASE 语句，那使用该表的所有高速缓存查询都将变为无效并从高 速缓存中删除！对于 更新压力大的数据库 来说，查询缓存的命中率会非常低。2.解析器：在解析器中对 SQL 语句进行语法分析、语义分析。分析器先做词法分析 。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面 的字符串分别是什么，代表什么。 MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语 句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。接着，要做语法分析 。根据词法分析的结果，语法分析器（比如：Bison）会根据语法规则，判断你输 入的这个 SQL 语句是否 满足 MySQL 语法 。select department_id,job_id,avg(salary) from employees group by department_id; 如果SQL语句正确，则会生成一个这样的语法树：3.优化器：在优化器中会确定 SQL 语句的执行路径，比如是根据 全表检索 ，还是根据 索引检索 等。举例：如下语句是执行两个表的 join：select * from test1 join test2 using(ID)where test1.name=&#39;zhangwei&#39; and test2.name=&#39;mysql高级课程&#39;;方案1：可以先从表 test1 里面取出 name=&#39;zhangwei&#39;的记录的 ID 值，再根据 ID 值关联到表 test2，再判断 test2 里面 name的值是否等于 &#39;mysql高级课程&#39;。方案2：可以先从表 test2 里面取出 name=&#39;mysql高级课程&#39; 的记录的 ID 值，再根据 ID 值关联到 test1，再判断 test1 里面 name的值是否等于 zhangwei。这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等。后面讲到索引我们再谈。在查询优化器中，可以分为 逻辑查询 优化阶段和 物理查询 优化阶段。4.执行器截止到现在，还没有真正去读写真实的表，仅仅只是产出了一个执行计划。于是就进入了 执行器阶段 。​ 在执行之前需要判断该用户是否 具备权限 。如果没有，就会返回权限错误。如果具备权限，就执行 SQL 查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。select * from test where id=1;比如：表 test 中，ID 字段没有索引，那么执行器的执行流程是这样的：调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是1，如果不是则跳过，如果是则将这行存在结果集中；调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。至此，这个语句就执行完成了。对于有索引的表，执行的逻辑也差不多。SQL 语句在 MySQL 中的流程是： SQL语句→查询缓存→解析器→优化器→执行器 。2.2 MySQL8中SQL执行原理1. 确认profiling 是否开启mysql&amp;gt; select @@profiling;+-------------+| @@profiling |+-------------+| 0 |+-------------+1 row in set, 1 warning (0.00 sec)profiling=0 代表关闭，我们需要把 profiling 打开，即设置为 1：mysql&amp;gt; set profiling=1;2. 多次执行相同SQL查询然后我们执行一个 SQL 查询（你可以执行任何一个 SQL 查询）：mysql&amp;gt; select * from employees;3. 查看profiles查看当前会话所产生的所有 profiles：mysql&amp;gt; show profiles; # 显示最近的几次查询mysql&amp;gt; show profiles;+----------+------------+----------------------------+| Query_ID | Duration | Query |+----------+------------+----------------------------+| 1 | 0.00028425 | select host,user from user || 2 | 0.00021700 | select host from user |+----------+------------+----------------------------+2 rows in set, 1 warning (0.00 sec)4. 查看profile显示执行计划，查看程序的执行步骤：mysql&amp;gt; show profile;+--------------------------------+----------+| Status | Duration |+--------------------------------+----------+| starting | 0.000073 || Executing hook on transaction | 0.000007 || starting | 0.000006 || checking permissions | 0.000004 | # 权限检查| Opening tables | 0.000025 | # 打开表| init | 0.000005 | # 初始化 | System lock | 0.000006 | # 锁系统| optimizing | 0.000003 | # 优化查询| statistics | 0.000011 | | preparing | 0.000011 | # 准备 | executing | 0.000031 | # 执行| end | 0.000003 || query end | 0.000002 || waiting for handler commit | 0.000006 || closing tables | 0.000005 || freeing items | 0.000011 || cleaning up | 0.000007 |+--------------------------------+----------+17 rows in set, 1 warning (0.00 sec)当然你也可以查询指定的 Query ID，比如：mysql&amp;gt; show profile for query 1;+--------------------------------+----------+| Status | Duration |+--------------------------------+----------+| starting | 0.000059 || Executing hook on transaction | 0.000004 || starting | 0.000006 || checking permissions | 0.000005 || Opening tables | 0.000025 || init | 0.000004 || System lock | 0.000006 || optimizing | 0.000004 || statistics | 0.000011 || preparing | 0.000012 || executing | 0.000033 || end | 0.000003 || query end | 0.000003 || waiting for handler commit | 0.000006 || closing tables | 0.000006 || freeing items | 0.000090 || cleaning up | 0.000008 |+--------------------------------+----------+17 rows in set, 1 warning (0.00 sec)此外，还可以查询更丰富的内容：mysql&amp;gt; show profile cpu,block io for query 2;+--------------------------------+----------+----------+------------+--------------+---------------+| Status | Duration | CPU_user | CPU_system | Block_ops_in | Block_ops_out |+--------------------------------+----------+----------+------------+--------------+---------------+| starting | 0.000073 | 0.000011 | 0.000062 | 0 | 0 || Executing hook on transaction | 0.000007 | 0.000001 | 0.000006 | 0 | 0 || starting | 0.000006 | 0.000000 | 0.000005 | 0 | 0 || checking permissions | 0.000004 | 0.000001 | 0.000004 | 0 | 0 || Opening tables | 0.000025 | 0.000004 | 0.000021 | 0 | 0 || init | 0.000005 | 0.000000 | 0.000004 | 0 | 0 || System lock | 0.000006 | 0.000001 | 0.000006 | 0 | 0 || optimizing | 0.000003 | 0.000001 | 0.000002 | 0 | 0 || statistics | 0.000011 | 0.000001 | 0.000010 | 0 | 0 || preparing | 0.000011 | 0.000002 | 0.000009 | 0 | 0 || executing | 0.000031 | 0.000004 | 0.000027 | 0 | 0 || end | 0.000003 | 0.000001 | 0.000002 | 0 | 0 || query end | 0.000002 | 0.000000 | 0.000002 | 0 | 0 || waiting for handler commit | 0.000006 | 0.000001 | 0.000005 | 0 | 0 || closing tables | 0.000005 | 0.000001 | 0.000005 | 0 | 0 || freeing items | 0.000011 | 0.000001 | 0.000010 | 0 | 0 || cleaning up | 0.000007 | 0.000001 | 0.000005 | 0 | 0 |+--------------------------------+----------+----------+------------+--------------+---------------+17 rows in set, 1 warning (0.00 sec)2.3 MySQL5.7中SQL执行原理由于后续使用Mysql 8.0版本，此处就不记录了2.4 SQL语法顺序随着Mysql版本的更新换代，其优化器也在不断的升级，优化器会分析不同执行顺序产生的性能消耗不同 而动态调整执行顺序。需求：查询每个部门年龄高于20岁的人数且高于20岁人数不能少于2人，显示人数最多的第一名部门信息下面是经常出现的查询顺序：3. 数据库缓冲池(buffer pool)​ InnoDB 存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。而磁盘 I/O 需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请 占用内存来作为 数据缓冲池 ，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的 Buffer Pool 之后才可以访 问。​ 这样做的好处是可以让磁盘活动最小化，从而 减少与磁盘直接进行 I/O 的时间 。要知道，这种策略对提 升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。3.1 缓冲池 vs 查询缓存缓冲池和查询缓存是一个东西吗？不是。1.缓冲池（Buffer Pool）首先我们需要了解在 InnoDB 存储引擎中，缓冲池都包括了哪些。在 InnoDB 存储引擎中有一部分数据会放到内存中，缓冲池则占了这部分内存的大部分，它用来存储各种 数据的缓存，如下图所示：从图中，你能看到 InnoDB 缓冲池包括了数据页、索引页、插入缓冲、锁信息、自适应 Hash 和数据字典 信息等。缓存池的重要性：缓存原则： 位置 * 频次 这个原则，可以帮我们对 I/O 访问效率进行优化。​ 首先，位置决定效率，提供缓冲池就是为了在内存中可以直接访问数据。​ 其次，频次决定优先级顺序。因为缓冲池的大小是有限的，比如磁盘有 200G，但是内存只有 16G，缓冲 池大小只有 1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会 优先对使用频次高 的热数据进行加载 。2.查询缓存那么什么是查询缓存呢？​ 查询缓存是提前把 查询结果缓存 起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在 MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。因为命中条件苛刻，而且只要数据表 发生变化，查询缓存就会失效，因此命中率低。3.2 缓冲池如何读取数据​ 缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面 是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进 行读取。​ 缓存在数据库中的结构和作用如下图所示：3.3 查看/设置缓冲池的大小如果你使用的是 InnoDB 存储引擎，可以通过查看 innodb_buffer_pool_size 变量来查看缓冲池的大 小。命令如下：mysql&amp;gt; show variables like &#39;innodb_buffer_pool_size&#39;;+-------------------------+-----------+| Variable_name | Value |+-------------------------+-----------+| innodb_buffer_pool_size | 134217728 |+-------------------------+-----------+1 row in set (0.01 sec)你能看到此时 InnoDB 的缓冲池大小只有 134217728/1024/1024=128MB。我们可以修改缓冲池大小，比如 改为256MB，方法如下：mysql&amp;gt; set global innodb_buffer_pool_size = 268435456;或者[server]innodb_buffer_pool_size = 268435456然后再来看下修改后的缓冲池大小，此时已成功修改成了 256 MB：3.4 多个Buffer Pool实例[server]innodb_buffer_pool_instances = 2这样就表明我们要创建2个 Buffer Pool 实例。我们看下如何查看缓冲池的个数，使用命令：mysql&amp;gt; show variables like &#39;innodb_buffer_pool_instances&#39;;+------------------------------+-------+| Variable_name | Value |+------------------------------+-------+| innodb_buffer_pool_instances | 1 |+------------------------------+-------+1 row in set (0.00 sec)那每个 Buffer Pool 实例实际占多少内存空间呢？其实使用这个公式算出来的：innodb_buffer_pool_size/innodb_buffer_pool_instances也就是总共的大小除以实例的个数，结果就是每个Buffer Pool 实例占用的大小。3.5 引申问题Buffer Pool是MySQL内存结构中十分核心的一个组成，你可以先把它想象成一个黑盒子。黑盒下的更新数据流程我更新到一半突然发生错误了，想要回滚到更新之前的版本，该怎么办？连数据持久化的保证、事务回滚都做不到还谈什么崩溃恢复？答案：Redo Log &amp;amp; Undo Log" }, { "title": "MySQL用户与权限管理", "url": "/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/", "categories": "数据库", "tags": "MySQL", "date": "2021-07-03 00:00:00 +0800", "snippet": "1.用户管理1.1 登录MySQL服务器启动MySQL服务后，可以通过mysql命令来登录MySQL服务器，命令如下:mysql –h hostname|hostIP –P port –u username –p DatabaseName –e &quot;SQL语句&quot; -h参数 后面接主机名或者主机IP，hostname为主机，hostIP为主机IP。 -P参数 后面接MySQL服务的端口，通过该参数连接到指定的端口。MySQL服务的默认端口是3306， 不使用该参数时自动连接到3306端口，port为连接的端口号。 -u参数 后面接用户名，username为用户名。 -p参数 会提示输入密码。 DatabaseName参数 指明登录到哪一个数据库中。如果没有该参数，就会直接登录到MySQL数据库 中，然后可以使用USE命令来选择数据库。 -e参数 后面可以直接加SQL语句。登录MySQL服务器以后即可执行这个SQL语句，然后退出MySQL 服务器。mysql -uroot -p -hlocalhost -P3306 mysql -e &quot;select host,user from user&quot;1.2 创建用户CREATE USER语句的基本语法形式如下：CREATE USER 用户名 [IDENTIFIED BY &#39;密码&#39;][,用户名 [IDENTIFIED BY &#39;密码&#39;]]; 用户名参数表示新建用户的账户，由 用户（User） 和 主机名（Host） 构成； [ ]表示可选，也就是说，可以指定用户登录时需要密码验证，也可以不指定密码验证，这样用户 可以直接登录。不过，不指定密码的方式不安全，不推荐使用。如果指定密码值，这里需要使用 IDENTIFIED BY指定明文密码值。 CREATE USER语句可以同时创建多个用户。举例：CREATE USER zhang3 IDENTIFIED BY &#39;123123&#39;; # 默认host是 %CREATE USER &#39;kangshifu&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;注意 远程登录时候，需要修改mysqld中的 bind-address 为 0.0.0.01.3 修改用户修改用户名：UPDATE mysql.user SET USER=&#39;li4&#39; WHERE USER=&#39;wang5&#39;;FLUSH PRIVILEGES;1.4 删除用户方式1：使用DROP方式删除（推荐） 使用DROP USER语句来删除用户时，必须用于DROP USER权限。DROP USER语句的基本语法形式如下：DROP USER user[,user]…;# 举例DROP USER li4 ; # 默认删除host为%的用户DROP USER &#39;kangshifu&#39;@&#39;localhost&#39;;方式2：使用DELETE方式删除DELETE FROM mysql.user WHERE Host=’hostname’ AND User=’username’;FLUSH PRIVILEGES;执行完DELETE命令后要使用FLUSH命令来使用户生效，举例如下：DELETE FROM mysql.user WHERE Host=&#39;localhost&#39; AND User=&#39;Emily&#39;;FLUSH PRIVILEGES注意：不推荐通过 DELETE FROM USER u WHERE USER=&#39;li4&#39; 进行删除，系统会有残留信息保留。而drop user命令会删除用户以及对应的权限，执行命令后你会发现mysql.user表和mysql.db表 的相应记录都消失了。1.5 设置当前用户密码使用ALTER USER命令来修改当前用户密码 用户可以使用ALTER命令来修改自身密码，如下语句代表修 改当前登录用户的密码。基本语法如下：ALTER USER USER() IDENTIFIED BY &#39;new_password&#39;;1.6 修改其它用户密码使用ALTER语句来修改普通用户的密码 可以使用ALTER USER语句来修改普通用户的密码。基本语法形 式如下：ALTER USER user_name [IDENTIFIED BY &#39;新密码&#39;][,user[IDENTIFIED BY &#39;新密码&#39;]]…;1.7 MySQL8密码管理(了解)1. 密码过期策略 在MySQL中，数据库管理员可以 手动设置 账号密码过期，也可以建立一个 自动密码过期策略。 过期策略可以是 全局的 ，也可以为 每个账号 设置单独的过期策略。ALTER USER user PASSWORD EXPIRE;ALTER USER &#39;kangshifu&#39;@&#39;localhost&#39; PASSWORD EXPIRE;方式①：使用SQL语句更改该变量的值并持久化SET PERSIST default_password_lifetime = 180; # 建立全局策略，设置密码每隔180天过期方式②：配置文件my.cnf中进行维护[mysqld]default_password_lifetime=180 #建立全局策略，设置密码每隔180天过期手动设置指定时间过期方式2：单独设置每个账号既可延用全局密码过期策略，也可单独设置策略。在 CREATE USER 和 ALTER USER 语句上加 入 PASSWORD EXPIRE 选项可实现单独设置策略。下面是一些语句示例。#设置kangshifu账号密码每90天过期：CREATE USER &#39;kangshifu&#39;@&#39;localhost&#39; PASSWORD EXPIRE INTERVAL 90 DAY;ALTER USER &#39;kangshifu&#39;@&#39;localhost&#39; PASSWORD EXPIRE INTERVAL 90 DAY;#设置密码永不过期：CREATE USER &#39;kangshifu&#39;@&#39;localhost&#39; PASSWORD EXPIRE NEVER;ALTER USER &#39;kangshifu&#39;@&#39;localhost&#39; PASSWORD EXPIRE NEVER;#延用全局密码过期策略：CREATE USER &#39;kangshifu&#39;@&#39;localhost&#39; PASSWORD EXPIRE DEFAULT;ALTER USER &#39;kangshifu&#39;@&#39;localhost&#39; PASSWORD EXPIRE DEFAULT;2. 密码重用策略手动设置密码重用方式1：全局方式①：使用SQLSET PERSIST password_history = 6; #设置不能选择最近使用过的6个密码SET PERSIST password_reuse_interval = 365; #设置不能选择最近一年内的密码方式②：my.cnf配置文件[mysqld]password_history=6password_reuse_interval=365手动设置密码重用方式2：单独设置#不能使用最近5个密码：CREATE USER &#39;kangshifu&#39;@&#39;localhost&#39; PASSWORD HISTORY 5;ALTER USER &#39;kangshifu&#39;@&#39;localhost&#39; PASSWORD HISTORY 5;#不能使用最近365天内的密码：CREATE USER &#39;kangshifu&#39;@&#39;localhost&#39; PASSWORD REUSE INTERVAL 365 DAY;ALTER USER &#39;kangshifu&#39;@&#39;localhost&#39; PASSWORD REUSE INTERVAL 365 DAY;#既不能使用最近5个密码，也不能使用365天内的密码CREATE USER &#39;kangshifu&#39;@&#39;localhost&#39;PASSWORD HISTORY 5PASSWORD REUSE INTERVAL 365 DAY;ALTER USER &#39;kangshifu&#39;@&#39;localhost&#39;PASSWORD HISTORY 5PASSWORD REUSE INTERVAL 365 DAY;2. 权限管理2.1 权限列表MySQL到底都有哪些权限呢？mysql&amp;gt; show privileges;（1） CREATE和DROP权限 ，可以创建新的数据库和表，或删除（移掉）已有的数据库和表。如果将 MySQL数据库中的DROP权限授予某用户，用户就可以删除MySQL访问权限保存的数据库。（2） SELECT、INSERT、UPDATE和DELETE权限 允许在一个数据库现有的表上实施操作。（3） SELECT权限 只有在它们真正从一个表中检索行时才被用到。（4） INDEX权限 允许创建或删除索引，INDEX适用于已 有的表。如果具有某个表的CREATE权限，就可以在CREATE TABLE语句中包括索引定义。（5） ALTER权 限 可以使用ALTER TABLE来更改表的结构和重新命名表。（6） CREATE ROUTINE权限 用来创建保存的 程序（函数和程序），ALTER ROUTINE权限用来更改和删除保存的程序， EXECUTE权限 用来执行保存的 程序。（7） GRANT权限 允许授权给其他用户，可用于数据库、表和保存的程序。（8） FILE权限 使用 户可以使用LOAD DATA INFILE和SELECT … INTO OUTFILE语句读或写服务器上的文件，任何被授予FILE权 限的用户都能读或写MySQL服务器上的任何文件（说明用户可以读任何数据库目录下的文件，因为服务 器可以访问这些文件）。2.2 授予权限的原则权限控制主要是出于安全因素，因此需要遵循以下几个 经验原则 ：1、只授予能 满足需要的最小权限 ，防止用户干坏事。比如用户只是需要查询，那就只给select权限就可 以了，不要给用户赋予update、insert或者delete权限。2、创建用户的时候 限制用户的登录主机 ，一般是限制成指定IP或者内网IP段。3、为每个用户 设置满足密码复杂度的密码 。 4、 定期清理不需要的用户 ，回收权限或者删除用户。2.3 授予权限给用户授权的方式有 2 种，分别是通过把 角色赋予用户给用户授权 和 直接给用户授权 。用户是数据库的 使用者，我们可以通过给用户授予访问数据库中资源的权限，来控制使用者对数据库的访问，消除安全 隐患。 授权命令:GRANT 权限1,权限2,…权限n ON 数据库名称.表名称 TO 用户名@用户地址 [IDENTIFIED BY ‘密码口令’];该权限如果发现没有该用户，则会直接新建一个用户。比如： 给li4用户用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。GRANT SELECT,INSERT,DELETE,UPDATE ON atguigudb.* TO li4@localhost ; 授予通过网络方式登录的joe用户 ，对所有库所有表的全部权限，密码设为123。注意这里唯独不包括grant的权限GRANT ALL PRIVILEGES ON *.* TO joe@&#39;%&#39; IDENTIFIED BY &#39;123&#39;; 实际应用中，可以创建一个远程可用的root账户，负责远程管理CREATE USER &#39;root&#39;@&#39;%&#39; identified with mysql_native_password by &#39;123&#39;;GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; ;FLUSH PRIVILEGES; 实际应用中，需要对本地的mysql进行加密处理mysqladmin -u root password &quot;123&quot;2.4 查看权限查看当前用户权限SHOW GRANTS;# 或SHOW GRANTS FOR CURRENT_USER;# 或SHOW GRANTS FOR CURRENT_USER();查看某用户的全局权限SHOW GRANTS FOR &#39;user&#39;@&#39;主机地址&#39; ;2.5 收回权限​ 收回权限就是取消已经赋予用户的某些权限。收回用户不必要的权限可以在一定程度上保证系统的安全性。MySQL中使用 REVOKE语句 取消用户的某些权限。使用REVOKE收回权限之后，用户账户的记录将从 db、host、tables_priv和columns_priv表中删除，但是用户账户记录仍然在user表中保存（删除user表中 的账户记录使用DROP USER语句）。注意：在将用户账户从user表删除之前，应该收回相应用户的所有权限。收回权限命令REVOKE 权限1,权限2,…权限n ON 数据库名称.表名称 FROM 用户名@用户地址;举例#收回全库全表的所有权限REVOKE ALL PRIVILEGES ON *.* FROM joe@&#39;%&#39;;#收回mysql库下的所有表的插删改查权限REVOKE SELECT,INSERT,UPDATE,DELETE ON mysql.* FROM joe@localhost;3.权限表3.1 user表user表是MySQL中最重要的一个权限表， 记录用户账号和权限信息 ，有49个字段。如下图： 字段名 数据类型 默认值 Host char(60)   User char(16)   authentication_string text   Select_priv enum(“N”，”Y”) N Insert_priv enum(“N”，”Y”) N Update_priv enum(“N”，”Y”) N Delete_priv enum(“N”，”Y”) N Create_priv enum(“N”，”Y”) N Drop_priv enum(“N”，”Y”) N Reload_priv enum(“N”，”Y”) N Shutdown_priv enum(“N”，”Y”) N Process_priv enum(“N”，”Y”) N File_priv enum(“N”，”Y”) N Grant_priv enum(“N”，”Y”) N Reference_priv enum(“N”，”Y”) N Index_priv enum(“N”，”Y”) N Alter_priv enum(“N”，”Y”) N Show_db_priv enum(“N”，”Y”) N Super_priv enum(“N”，”Y”) N Create_tem_table_priv enum(“N”，”Y”) N Lock_table_priv enum(“N”，”Y”) N Execute_priv enum(“N”，”Y”) N Repl_slave_priv enum(“N”，”Y”) N Repl_client_priv enum(“N”，”Y”) N Create_view_priv enum(“N”，”Y”) N Show_view_priv enum(“N”，”Y”) N Create_user_priv enum(“N”，”Y”) N Event_priv enum(“N”，”Y”) N Trigger_priv enum(“N”，”Y”) N Create_tablespace_priv enum(“N”，”Y”) N ssl_type enum(“‘ANY,’X509,’SPECIFIED”)   ssl_copher blob NULL x509_issuer blob NULL x509_subject blob NULL max_questions int(11)unsigned   max_updates int(11)unsigned 0 max_connections int(11)unsigned 0 max_user_connections int(11)unsigned 0 plugin char(64) 0       这些字段可以分成4类，分别是范围列（或用户列）、权限列、安全列和资源控制列。1.范围列（或用户列）host ： 表示连接类型 % 表示所有远程通过 TCP方式的连接 IP 地址 如 (192.168.1.2、127.0.0.1) 通过制定ip地址进行的TCP方式的连接 机器名 通过制定网络中的机器名进行的TCP方式的连接 ::1 IPv6的本地ip地址，等同于IPv4的 127.0.0.1 localhost 本地方式通过命令行方式的连接 ，比如mysql -u xxx -p xxx 方式的连接。user ： 表示用户名，同一用户通过不同方式链接的权限是不一样的。password ： 密码 所有密码串通过 password(明文字符串) 生成的密文字符串。MySQL 8.0 在用户管理方面增加了 角色管理，默认的密码加密方式也做了调整，由之前的 SHA1 改为了 SHA2 ，不可逆 。同时 加上 MySQL 5.7 的禁用用户和用户过期的功能，MySQL 在用户管理方面的功能和安全性都较之 前版本大大的增强了。 mysql 5.7 及之后版本的密码保存到 authentication_string 字段中不再使用password 字 段。2.权限列 Grant_priv字段 表示是否拥有GRANT权限 Shutdown_priv字段 表示是否拥有停止MySQL服务的权限 Super_priv字段 表示是否拥有超级权限 Execute_priv字段 表示是否拥有EXECUTE权限。拥有EXECUTE权限，可以执行存储过程和函数。 Select_priv , Insert_priv等 为该用户所拥有的权限。 3. 安全列​ 安全列只有6个字段，其中两个是ssl相关的（ssl_type、ssl_cipher），用于 加密 ；两个是x509 相关的（x509_issuer、x509_subject），用于 标识用户 ；另外两个Plugin字段用于 验证用户身份 的插件， 该字段不能为空。如果该字段为空，服务器就使用内建授权验证机制验证用户身份。4. 资源控制列资源控制列的字段用来 限制用户使用的资源 ，包含4个字段，分别为：①max_questions，用户每小时允许执行的查询操作次数；②max_updates，用户每小时允许执行的更新 操作次数；③max_connections，用户每小时允许执行的连接操作次数；④max_user_connections，用户 允许同时建立的连接次数。查看字段：DESC mysql.user;查看用户, 以列的方式显示数据：SELECT * FROM mysql.user \\G;查询特定字段：SELECT host,user,authentication_string,select_priv,insert_priv,drop_privFROM mysql.user;3.2 db表使用DESCRIBE查看db表的基本结构：DESCRIBE mysql.db;1.用户列 db表用户列有3个字段，分别是Host、User、Db。这3个字段分别表示主机名、用户名和数据库 名。表示从某个主机连接某个用户对某个数据库的操作权限，这3个字段的组合构成了db表的主键。2.权限列 Create_routine_priv和Alter_routine_priv这两个字段决定用户是否具有创建和修改存储过程的权限。3.3 tables_priv表和columns_priv表tables_priv表用来 对表设置操作权限 ，columns_priv表用来对表的 某一列设置权限 。tables_priv表和 columns_priv表的结构分别如图：desc mysql.tables_priv;tables_priv表有8个字段，分别是Host、Db、User、Table_name、Grantor、Timestamp、Table_priv和 Column_priv，各个字段说明如下： Host 、 Db 、 User 和 Table_name 四个字段分别表示主机名、数据库名、用户名和表名。 Grantor表示修改该记录的用户。 Timestamp表示修改该记录的时间。 Table_priv 表示对象的操作权限。包括Select、Insert、Update、Delete、Create、Drop、Grant、 References、Index和Alter。 Column_priv字段表示对表中的列的操作权限，包括Select、Insert、Update和References。3.4 procs_priv表procs_priv表可以对 存储过程和存储函数设置操作权限 ，表结构如图：desc mysql.procs_priv; 字段名 数据类型 默认值 Host char(60)   Db char(64)   User char(16)   Routine_name char(64)   Rountine_type enum(‘FUNCTION’,’PROCEDURE’) NULL Grantor char(77)   Proc_priv set(‘Executer’,’Alter’,’Routine’,’Grant’)   Timestamp timestamp CURRENT_TIMESTAMP 4. 访问控制(了解)4.1 连接核实阶段​ 当用户试图连接MySQL服务器时，服务器基于用户的身份以及用户是否能提供正确的密码验证身份来确 定接受或者拒绝连接。即客户端用户会在连接请求中提供用户名、主机地址、用户密码，MySQL服务器 接收到用户请求后，会使用user表中的host、user和authentication_string这3个字段匹配客户端提供信 息。​ 服务器只有在user表记录的Host和User字段匹配客户端主机名和用户名，并且提供正确的密码时才接受 连接。如果连接核实没有通过，服务器就完全拒绝访问；否则，服务器接受连接，然后进入阶段2等待 用户请求。4.2 请求核实阶段​ 一旦建立了连接，服务器就进入了访问控制的阶段2，也就是请求核实阶段。对此连接上进来的每个请 求，服务器检查该请求要执行什么操作、是否有足够的权限来执行它，这正是需要授权表中的权限列发 挥作用的地方。这些权限可以来自user、db、table_priv和column_priv表。 确认权限时，MySQL首先 检查user表 ，如果指定的权限没有在user表中被授予，那么MySQL就会继续 检 查db表 ，db表是下一安全层级，其中的权限限定于数据库层级，在该层级的SELECT权限允许用户查看指 定数据库的所有表中的数据；如果在该层级没有找到限定的权限，则MySQL继续 检查tables_priv表 以 及 columns_priv表 ，如果所有权限表都检查完毕，但还是没有找到允许的权限操作，MySQL将 返回错 误信息 ，用户请求的操作不能执行，操作失败。提示： MySQL通过向下层级的顺序（从user表到columns_priv表）检查权限表，但并不是所有的权限都要执行该过程。例如，一个用户登录到MySQL服务器之后只执行对MySQL的管理操作，此时只涉及管理权限，因此MySQL只检查user表。另外，如果请求的权限操作不被允许，MySQL也不会继续检查下一层级的表。5. 角色管理5.1 角色的理解引入角色的目的是 方便管理拥有相同权限的用户 。恰当的权限设定，可以确保数据的安全性，这是至关重要的。5.2 创建角色使用 CREATE ROLE 语句，语法如下：CREATE ROLE &#39;role_name&#39;[@&#39;host_name&#39;] [,&#39;role_name&#39;[@&#39;host_name&#39;]]...角色名称的命名规则和用户名类似。如果 host_name省略，默认为% ， role_name不可省略 ，不可为 空。练习：我们现在需要创建一个经理的角色，就可以用下面的代码：CREATE ROLE &#39;manager&#39;@&#39;localhost&#39;;5.3 给角色赋予权限创建角色之后，默认这个角色是没有任何权限的，我们需要给角色授权。给角色授权的语法结构是：GRANT privileges ON table_name TO &#39;role_name&#39;[@&#39;host_name&#39;];上述语句中privileges代表权限的名称，多个权限以逗号隔开。可使用SHOW语句查询权限名称，图11-43 列出了部分权限列表。SHOW PRIVILEGES\\G;练习1：我们现在想给经理角色授予商品信息表、盘点表和应付账款表的只读权限，就可以用下面的代码 来实现：GRANT SELECT ON demo.settlement TO &#39;manager&#39;;GRANT SELECT ON demo.goodsmaster TO &#39;manager&#39;;GRANT SELECT ON demo.invcount TO &#39;manager&#39;;5.4 查看角色的权限赋予角色权限之后，我们可以通过 SHOW GRANTS 语句，来查看权限是否创建成功了：mysql&amp;gt; SHOW GRANTS FOR &#39;manager&#39;;+-------------------------------------------------------+| Grants for manager@% |+-------------------------------------------------------+| GRANT USAGE ON *.* TO `manager`@`%` || GRANT SELECT ON `demo`.`goodsmaster` TO `manager`@`%` || GRANT SELECT ON `demo`.`invcount` TO `manager`@`%` || GRANT SELECT ON `demo`.`settlement` TO `manager`@`%` |+-------------------------------------------------------+​ 只要你创建了一个角色，系统就会自动给你一个 USAGE 权限，意思是 连接登录数据库的权限 。代码的 最后三行代表了我们给角色“manager”赋予的权限，也就是对商品信息表、盘点表和应付账款表的只读权 限。结果显示，库管角色拥有商品信息表的只读权限和盘点表的增删改查权限。5.5 回收角色的权限​ 角色授权后，可以对角色的权限进行维护，对权限进行添加或撤销。添加权限使用GRANT语句，与角色 授权相同。撤销角色或角色权限使用REVOKE语句。 修改了角色的权限，会影响拥有该角色的账户的权限。撤销角色权限的SQL语法如下：REVOKE privileges ON tablename FROM &#39;rolename&#39;;练习1：撤销school_write角色的权限。（1）使用如下语句撤销school_write角色的权限。REVOKE INSERT, UPDATE, DELETE ON school.* FROM &#39;school_write&#39;;（2）撤销后使用SHOW语句查看school_write对应的权限，语句如下。SHOW GRANTS FOR &#39;school_write&#39;;5.6 删除角色​ 当我们需要对业务重新整合的时候，可能就需要对之前创建的角色进行清理，删除一些不会再使用的角 色。删除角色的操作很简单，你只要掌握语法结构就行了。DROP ROLE role [,role2]...注意， 如果你删除了角色，那么用户也就失去了通过这个角色所获得的所有权限 。练习：执行如下SQL删除角色school_read。DROP ROLE &#39;school_read&#39;;5.7 给用户赋予角色​ 角色创建并授权后，要赋给用户并处于 激活状态 才能发挥作用。给用户添加角色可使用GRANT语句，语 法形式如下：GRANT role [,role2,...] TO user [,user2,...];在上述语句中，role代表角色，user代表用户。可将多个角色同时赋予多个用户，用逗号隔开即可。 练习：给kangshifu用户添加角色school_read权限。 （1）使用GRANT语句给kangshifu添加school_`read权 限，SQL语句如下。GRANT &#39;school_read&#39; TO &#39;kangshifu&#39;@&#39;localhost&#39;;（2）添加完成后使用SHOW语句查看是否添加成功，SQL语句如下。SHOW GRANTS FOR &#39;kangshifu&#39;@&#39;localhost&#39;;（3）使用kangshifu用户登录，然后查询当前角色，如果角色未激活，结果将显示NONE。SQL语句如 下。SELECT CURRENT_ROLE();5.8 激活角色方式1：使用set default role 命令激活角色举例：SET DEFAULT ROLE ALL TO &#39;kangshifu&#39;@&#39;localhost&#39;;举例：使用 SET DEFAULT ROLE 为下面4个用户默认激活所有已拥有的角色如下：SET DEFAULT ROLE ALL TO&#39;dev1&#39;@&#39;localhost&#39;,&#39;read_user1&#39;@&#39;localhost&#39;,&#39;read_user2&#39;@&#39;localhost&#39;,&#39;rw_user1&#39;@&#39;localhost&#39;;方式2：将activate_all_roles_on_login设置为ON默认情况：mysql&amp;gt; show variables like &#39;activate_all_roles_on_login&#39;;+-----------------------------+-------+| Variable_name | Value |+-----------------------------+-------+| activate_all_roles_on_login | OFF |+-----------------------------+-------+1 row in set (0.00 sec)设置：SET GLOBAL activate_all_roles_on_login=ON;这条 SQL 语句的意思是，对 所有角色永久激活 。运行这条语句之后，用户才真正拥有了赋予角色的所有 权限。5.9 撤销用户的角色撤销用户角色的SQL语法如下：REVOKE role FROM user;练习：撤销kangshifu用户的school_read角色。（1）撤销的SQL语句如下REVOKE &#39;school_read&#39; FROM &#39;kangshifu&#39;@&#39;localhost&#39;;（2）撤销后，执行如下查询语句，查看kangshifu用户的角色信息SHOW GRANTS FOR &#39;kangshifu&#39;@&#39;localhost&#39;;执行发现，用户kangshifu之前的school_read角色已被撤销。5.10 设置强制角色(mandatory role)方式1：服务启动前设置[mysqld]mandatory_roles=&#39;role1,role2@localhost,r3@%.atguigu.com&#39;方式2：运行时设置SET PERSIST mandatory_roles = &#39;role1,role2@localhost,r3@%.example.com&#39;; #系统重启后仍然有效SET GLOBAL mandatory_roles = &#39;role1,role2@localhost,r3@%.example.com&#39;; #系统重启后失效6.配置文件的使用6.1 配置文件格式与在命令行中指定启动选项不同的是，配置文件中的启动选项被划分为若干个组，每个组有一个组名，用中括号[]括起来，[server](具体的启动选项...)[mysqld](具体的启动选项...)[mysqld_safe](具体的启动选项...)[client](具体的启动选项...)[mysql](具体的启动选项...)[mysqladmin](具体的启动选项...)像这个配置文件里就定义了许多个组，组名分别为server、mysqld、mysqld_safe、client、mysql、mysqladmin。每个组下面可以定义若干个启动项，我们以[server]组为例看一下启动项的形式[server]option1 # 这里option1，该选项不需要选项值opiton2 = value2 #这是option2，该选项需要选项值...在配置文件中指定启动选项的语法类似于命令行语法，但是配置文件中指定的启动选项不允许加--前缀，并且每行只指定一个选项，而且=周围可以有空白字符（命令行中选项名、=、选项值之间不允许有空白字符）。另外，配置文件中，我们可以使用#来注释。6.2 启动命名和选项组配置文件中不同的选项是给不同的启动命令使用的，不过有两个选项组比较特别 [server]组下面启动选项作用域所有服务器程序 [server]组下面启动选项作用域所有客户端程序下面是启动命令能读取的选项组有哪些 启动命令 类别 能读取的组 mysqld 启动服务器 [mysqld]、[server] mysqld_safe 启动服务器 [mysqld]、[server]、[mysqld_safe] mysql.server 启动服务器 [mysqld]、[server]、[mysqld_server] mysql 启动客户端 [mysql]、[client] mysqladmin 启动客户端 [mysqladmin]、[client] mysqldump 启动客户端 [mysqldump]、[client]       比如，在/etc/mysql/my.cnf这个配置文件中添加一些内容[server]skip-networkingdefault-storage-engine = MYISAM然后直接使用mysqld启动服务器mysqld虽然在命令行没有添加启动选项，但是在程序启动的时候，就会默认的到我们上面提到的配置文件路径下查找配置文件，其中就包括/etc/my.cnf。又由于mysqld命令可以读取[server]选项组的内容，所以skip-networking和default-storage-engine= MyISAM这两个选项是生效的。试试把上面两个参数写到[client]组里，试试启动mysqld，就不能生效。6.3特定MySQL版本专用选项组我们可以在选项组名称后面加上特定的MySQL版本号，比如对于[mysqld]选项组来说，我们可以定义一个[mysql-5.7]的选项组，它的含义和[mysqld]一样，只不过只有版本号为5.7的mysqld程序才能使用这个选项组中的选项。6.4 同一个配置文件中多个组的优先级我们说同一个命令可以访问配置文件中的多个组，比如，mysqld可以访问[mysqld]、[server]组，如果在同一个配置文件中，比如~/my.cnf，在这些组里出现同样的配置项，比如[server]default-storage-engine = InnoDB[mysqld]default-storage-engine = MYISAM那么，将以最后一个出现的组中的启动选项为准，比方说例子中default-storage-engine既出现在了[server]中，也出现在了[mysqld]中。因为[mysqld]出现在[server]组的后面，所以以[mysqld]的配置项为准。6.5命令行和配置文件中启动选项的区别在命令行上指定的绝大部分启动选项都可以放在配置文件中，但是有一些选项是专门为命令行设计的，比方说，defaults-extra-flie、defaults-flies这样的选项本身就是为了指定配置文件路径的，再放在配置文件中使用就没啥意义了。如果同一个启动选项既出现在命令行中，也出现在配置文件中，那么以命令行中启动选项为准！。比如我们在配置文件中写了[server]default-storage-engine = InnoDB而我们的启动命令是mysql.server.start --default-storage-engine = MyISAM那最后default-storage-engine的值就是MyISAM。7.系统变量（复习）7.1系统变量简介MySQL服务器程序运行过程中会用到许多影响程序行为的变量，它们被称为MySQL系统变量，比如max_connections:运行同时连接的客户端数量default_storage_engine：表默认的存储引擎query_cache_size：查询缓存的大小详细的见上篇吧，就不写了！" }, { "title": "MySQL文件目录", "url": "/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95/", "categories": "数据库", "tags": "MySQL", "date": "2021-07-02 00:00:00 +0800", "snippet": "1. MySQL8的主要目录结构root@ubuntu:~# find / -name mysql/var/log/mysql/var/lib/mysql/var/lib/mysql/mysql/home/zheng/.cache/vmware/drag_and_drop/QvvJYE/BigScreen/mysql/home/zheng/.cache/vmware/drag_and_drop/QvvJYE/BigScreen/mysql/data/mysql/home/zheng/IEM_box/venv/lib/python3.8/site-packages/sqlalchemy/dialects/mysql/home/zheng/Desktop/Lab_V1.1/venv/lib/python3.8/site-packages/sqlalchemy/dialects/mysql/home/zheng/VueExample/db/data/mysql/home/zheng/ShanweiTest/BigScreen/mysql/home/zheng/ShanweiTest/BigScreen/mysql/data/mysql/home/zheng/venv/lib/python3.8/site-packages/sqlalchemy/dialects/mysql/home/zheng/.local/share/Trash/files/ven/lib/python3.8/site-packages/sqlalchemy/dialects/mysql/snap/core18/2409/etc/apparmor.d/abstractions/mysql/snap/core18/2409/usr/share/bash-completion/completions/mysql/snap/core18/2344/etc/apparmor.d/abstractions/mysql/snap/core18/2344/usr/share/bash-completion/completions/mysql/snap/core20/1434/etc/apparmor.d/abstractions/mysql/snap/core20/1434/usr/share/bash-completion/completions/mysql/snap/core20/1494/etc/apparmor.d/abstractions/mysql/snap/core20/1494/usr/share/bash-completion/completions/mysql/etc/mysql/etc/init.d/mysql/etc/apparmor.d/abstractions/mysqlfind: ‘/run/user/1000/gvfs’: 权限不够/usr/bin/mysql/usr/share/bash-completion/completions/mysql/usr/share/mysql/usr/lib/mysqlfind: ‘/proc/3900/task/3900/net’: 无效的参数find: ‘/proc/3900/net’: 无效的参数1.1 数据库文件的存放路径MySQL数据库文件的存放路径：/var/lib/mysql/mysql&amp;gt; show variables like &#39;datadir&#39;;+---------------+-----------------+| Variable_name | Value |+---------------+-----------------+| datadir | /var/lib/mysql/ |+---------------+-----------------+1 row in set (0.01 sec)从结果中可以看出，在我的计算机上MySQL的数据目录就是 /var/lib/mysql/ 。1.2 相关命令目录相关命令目录：/usr/bin（mysqladmin、mysqlbinlog、mysqldump等命令）和/usr/sbin。1.3 配置文件目录配置文件目录：/usr/share/mysql（命令及配置文件），/etc/mysql（如my.cnf）root@ubuntu:/usr/share/mysql# cd /usr/share/mysqlroot@ubuntu:/usr/share/mysql# ll总用量 180drwxr-xr-x 28 root root 4096 5月 31 11:35 ./drwxr-xr-x 258 root root 12288 5月 31 10:35 ../drwxr-xr-x 2 root root 4096 5月 31 11:35 bulgarian/drwxr-xr-x 2 root root 4096 5月 31 11:35 charsets/drwxr-xr-x 2 root root 4096 5月 31 11:35 czech/drwxr-xr-x 2 root root 4096 5月 31 11:35 danish/-rw-r--r-- 1 root root 1833 5月 4 20:36 debian_create_root_user.sql-rw-r--r-- 1 root root 25575 3月 23 21:52 dictionary.txtdrwxr-xr-x 2 root root 4096 5月 31 11:35 docs/drwxr-xr-x 2 root root 4096 5月 31 11:35 dutch/-rwxr-xr-x 1 root root 27 5月 4 20:36 echo_stderr*drwxr-xr-x 2 root root 4096 5月 31 11:35 english/drwxr-xr-x 2 root root 4096 5月 31 11:35 estonian/drwxr-xr-x 2 root root 4096 5月 31 11:35 french/drwxr-xr-x 2 root root 4096 5月 31 11:35 german/drwxr-xr-x 2 root root 4096 5月 31 11:35 greek/drwxr-xr-x 2 root root 4096 5月 31 11:35 hungarian/-rw-r--r-- 1 root root 3999 3月 23 21:52 innodb_memcached_config.sql-rw-r--r-- 1 root root 2216 5月 4 20:36 install_rewriter.sqldrwxr-xr-x 2 root root 4096 5月 31 11:35 italian/drwxr-xr-x 2 root root 4096 5月 31 11:35 japanese/drwxr-xr-x 2 root root 4096 5月 31 11:35 korean/-rwxr-xr-x 1 root root 1061 3月 23 21:52 mysqld_multi.server*-rw-r--r-- 1 root root 1977 5月 4 20:36 mysql-log-rotate-rwxr-xr-x 1 root root 2140 3月 11 04:45 mysql-systemd-start*drwxr-xr-x 2 root root 4096 5月 31 11:35 norwegian/drwxr-xr-x 2 root root 4096 5月 31 11:35 norwegian-ny/drwxr-xr-x 2 root root 4096 5月 31 11:35 polish/drwxr-xr-x 2 root root 4096 5月 31 11:35 portuguese/drwxr-xr-x 2 root root 4096 5月 31 11:35 romanian/drwxr-xr-x 2 root root 4096 5月 31 11:35 russian/drwxr-xr-x 2 root root 4096 5月 31 11:35 serbian/drwxr-xr-x 2 root root 4096 5月 31 11:35 slovak/drwxr-xr-x 2 root root 4096 5月 31 11:35 spanish/drwxr-xr-x 2 root root 4096 5月 31 11:35 swedish/drwxr-xr-x 2 root root 4096 5月 31 11:35 ukrainian/-rw-r--r-- 1 root root 1248 5月 4 20:36 uninstall_rewriter.sql2. 数据库和文件系统的关系2.1 查看默认数据库查看一下在我的计算机上当前有哪些数据库：mysql&amp;gt; SHOW DATABASES;可以看到有4个数据库是属于MySQL自带的系统数据库。 mysql ​ MySQL 系统自带的核心数据库，它存储了MySQL的用户账户和权限信息，一些存储过程、事件的定 义信息，一些运行过程中产生的日志信息，一些帮助信息以及时区信息等。 information_schema ​ MySQL 系统自带的数据库，这个数据库保存着MySQL服务器 维护的所有其他数据库的信息 ，比如有 哪些表、哪些视图、哪些触发器、哪些列、哪些索引。这些信息并不是真实的用户数据，而是一些 描述性信息，有时候也称之为 元数据 。 mysql&amp;gt; use information_schema;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -A Database changedmysql&amp;gt; show tables like &quot;innodb_sys%&quot;;Empty set (0.00 sec) mysql&amp;gt; show tables like &quot;innodb%&quot;;+----------------------------------------+| Tables_in_information_schema (INNODB%) |+----------------------------------------+| INNODB_BUFFER_PAGE || INNODB_BUFFER_PAGE_LRU || INNODB_BUFFER_POOL_STATS || INNODB_CACHED_INDEXES || INNODB_CMP || INNODB_CMPMEM || INNODB_CMPMEM_RESET || INNODB_CMP_PER_INDEX || INNODB_CMP_PER_INDEX_RESET || INNODB_CMP_RESET || INNODB_COLUMNS || INNODB_DATAFILES || INNODB_FIELDS || INNODB_FOREIGN || INNODB_FOREIGN_COLS || INNODB_FT_BEING_DELETED || INNODB_FT_CONFIG || INNODB_FT_DEFAULT_STOPWORD || INNODB_FT_DELETED || INNODB_FT_INDEX_CACHE || INNODB_FT_INDEX_TABLE || INNODB_INDEXES || INNODB_METRICS || INNODB_SESSION_TEMP_TABLESPACES || INNODB_TABLES || INNODB_TABLESPACES || INNODB_TABLESPACES_BRIEF || INNODB_TABLESTATS || INNODB_TEMP_TABLE_INFO || INNODB_TRX || INNODB_VIRTUAL |+----------------------------------------+31 rows in set (0.00 sec) performance_schema ​ MySQL 系统自带的数据库，这个数据库里主要保存MySQL服务器运行过程中的一些状态信息，可以 用来 监控 MySQL 服务的各类性能指标 。包括统计最近执行了哪些语句，在执行过程的每个阶段都 花费了多长时间，内存的使用情况等信息。 sys ​ MySQL 系统自带的数据库，这个数据库主要是通过 视图 的形式把 information_schema 和 performance_schema 结合起来，帮助系统管理员和开发人员监控 MySQL 的技术性能。 2.2 数据库在文件系统中的表示root@ubuntu:/usr/share/mysql# cd root@ubuntu:~# cd /var/lib/mysqlroot@ubuntu:/var/lib/mysql# ll总用量 191960drwx------ 6 mysql mysql 4096 5月 31 11:35 ./drwxr-xr-x 73 root root 4096 5月 31 11:35 ../-rw-r----- 1 mysql mysql 56 5月 31 11:35 auto.cnf-rw-r----- 1 mysql mysql 180 5月 31 11:35 binlog.000001-rw-r----- 1 mysql mysql 404 5月 31 11:35 binlog.000002-rw-r----- 1 mysql mysql 157 5月 31 11:35 binlog.000003-rw-r----- 1 mysql mysql 48 5月 31 11:35 binlog.index-rw------- 1 mysql mysql 1680 5月 31 11:35 ca-key.pem-rw-r--r-- 1 mysql mysql 1112 5月 31 11:35 ca.pem-rw-r--r-- 1 mysql mysql 1112 5月 31 11:35 client-cert.pem-rw------- 1 mysql mysql 1680 5月 31 11:35 client-key.pem-rw-r--r-- 1 root root 0 5月 31 11:35 debian-5.7.flag-rw-r----- 1 mysql mysql 196608 5月 31 11:37 &#39;#ib_16384_0.dblwr&#39;-rw-r----- 1 mysql mysql 8585216 5月 31 11:35 &#39;#ib_16384_1.dblwr&#39;-rw-r----- 1 mysql mysql 3397 5月 31 11:35 ib_buffer_pool-rw-r----- 1 mysql mysql 12582912 5月 31 11:35 ibdata1-rw-r----- 1 mysql mysql 50331648 5月 31 11:37 ib_logfile0-rw-r----- 1 mysql mysql 50331648 5月 31 11:35 ib_logfile1-rw-r----- 1 mysql mysql 12582912 5月 31 11:35 ibtmp1drwxr-x--- 2 mysql mysql 4096 5月 31 11:35 &#39;#innodb_temp&#39;/drwxr-x--- 2 mysql mysql 4096 5月 31 11:35 mysql/-rw-r----- 1 mysql mysql 28311552 5月 31 11:35 mysql.ibddrwxr-x--- 2 mysql mysql 4096 5月 31 11:35 performance_schema/-rw------- 1 mysql mysql 1680 5月 31 11:35 private_key.pem-rw-r--r-- 1 mysql mysql 452 5月 31 11:35 public_key.pem-rw-r--r-- 1 mysql mysql 1112 5月 31 11:35 server-cert.pem-rw------- 1 mysql mysql 1676 5月 31 11:35 server-key.pemdrwxr-x--- 2 mysql mysql 4096 5月 31 11:35 sys/-rw-r----- 1 mysql mysql 6 5月 31 11:35 ubuntu.pid-rw-r----- 1 mysql mysql 16777216 5月 31 11:37 undo_001-rw-r----- 1 mysql mysql 16777216 5月 31 11:37 undo_002这个数据目录下的文件和子目录比较多，除了 information_schema 这个系统数据库外，其他的数据库 在 数据目录 下都有对应的子目录。2.3 表在文件系统中的表示2.3.1 InnoDB存储引擎模式1.表结构​ 为了保存表结构， InnoDB 在 数据目录 下对应的数据库子目录下创建了一个专门用于 描述表结构的文 件 ，文件名是表名.frm比方说我们在 atguigu 数据库下创建一个名为 test 的表：mysql&amp;gt; USE atguigu;Database changedmysql&amp;gt; CREATE TABLE test ( c1 INT );Query OK, 0 rows affected (0.03 sec)​ 那在数据库 atguigu 对应的子目录下就会创建一个名为 test.frm 的用于描述表结构的文件。.frm文件 的格式在不同的平台上都是相同的。这个后缀名为.frm是以 二进制格式 存储的，我们直接打开是乱码 的。2. 表中数据和索引① 系统表空间（system tablespace）​ 默认情况下，InnoDB会在数据目录下创建一个名为 ibdata1 、大小为 12M 的文件，这个文件就是对应 的 系统表空间 在文件系统上的表示。怎么才12M？​ 注意这个文件是 自扩展文件 ，当不够用的时候它会自己增加文件大小。 当然，如果你想让系统表空间对应文件系统上多个实际文件，或者仅仅觉得原来的 ibdata1 这个文件名 难听，那可以在MySQL启动时配置对应的文件路径以及它们的大小，比如我们这样修改一下my.cnf 配置 文件：[server]innodb_data_file_path=data1:512M;data2:512M:autoextend② 独立表空间(file-per-table tablespace)​ 在MySQL5.6.6以及之后的版本中，InnoDB并不会默认的把各个表的数据存储到系统表空间中，而是为 每 一个表建立一个独立表空间 ，也就是说我们创建了多少个表，就有多少个独立表空间。使用 独立表空间 来 存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表 名相同，只不过添加了一个 .ibd 的扩展名而已，所以完整的文件名称长这样：表名.ibd比如：我们使用了 独立表空间 去存储 atguigu 数据库下的 test 表的话，那么在该表所在数据库对应 的 atguigu 目录下会为 test 表创建这两个文件：test.frm (用来存储表结构)test.ibd (用来存储 test 表中的`数据和索引`)其中 test.ibd 文件就用来存储 test 表中的数据和索引。③ 系统表空间与独立表空间的设置​ 我们可以自己指定使用 系统表空间 还是 独立表空间 来存储数据，这个功能由启动参数 innodb_file_per_table 控制，比如说我们想刻意将表数据都存储到 系统表空间 时，可以在启动 MySQL服务器的时候这样配置：[server]innodb_file_per_table=0 # 0：代表使用系统表空间； 1：代表使用独立表空间默认情况：mysql&amp;gt; show variables like &#39;innodb_file_per_table&#39;;+-----------------------+-------+| Variable_name | Value |+-----------------------+-------+| innodb_file_per_table | ON |+-----------------------+-------+1 row in set (0.00 sec)④ 其他类型的表空间​ 随着MySQL的发展，除了上述两种老牌表空间之外，现在还新提出了一些不同类型的表空间，比如通用 表空间（general tablespace）、临时表空间（temporary tablespace）等。2.3.2 MyISAM存储引擎模式1. 表结构​ 在存储表结构方面， MyISAM 和 InnoDB 一样，也是在 数据目录 下对应的数据库子目录下创建了一个专 门用于描述表结构的文件：表名.frm2. 表中数据和索引​ 在MyISAM中的索引全部都是 二级索引 ，该存储引擎的 数据和索引是分开存放 的。所以在文件系统中也是 使用不同的文件来存储数据文件和索引文件，同时表数据都存放在对应的数据库子目录下。假如 test 表使用MyISAM存储引擎的话，那么在它所在数据库对应的 atguigu 目录下会为 test 表创建这三个文 件：test.frm 存储表结构test.MYD 存储数据 (MYData)test.MYI 存储索引 (MYIndex)test.frm 存储表结构 test.MYD 存储数据 (MYData) test.MYI 存储索引 (MYIndex)CREATE TABLE `student_myisam` ( `id` bigint NOT NULL AUTO_INCREMENT, `name` varchar(64) DEFAULT NULL, `age` int DEFAULT NULL, `sex` varchar(2) DEFAULT NULL, PRIMARY KEY (`id`))ENGINE=MYISAM AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb3;2.4 小结举例： 数据库a ， 表b 。1、如果表b采用 InnoDB ，data\\a中会产生1个或者2个文件： b.frm ：描述表结构文件，字段长度等 如果采用 系统表空间 模式的，数据信息和索引信息都存储在 ibdata1 中 如果采用 独立表空间 存储模式，data\\a中还会产生 b.ibd 文件（存储数据信息和索引信息） 此外：​ ① MySQL5.7 中会在data/a的目录下生成 db.opt 文件用于保存数据库的相关配置。比如：字符集、比较 规则。而MySQL8.0不再提供db.opt文件。​ ② MySQL8.0中不再单独提供b.frm，而是合并在b.ibd文件中。2、如果表b采用 MyISAM ，data\\a中会产生3个文件：MySQL5.7 中： b.frm ：描述表结构文件，字段长度等。MySQL8.0 中 b.xxx.sdi ：描述表结构文件，字段长度等b.MYD (MYData)：数据信息文件，存储数据信息(如果采用独立表存储模式)b.MYI (MYIndex)：存放索引信息文件" }, { "title": "MySQL在Linux安装", "url": "/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E5%9C%A8Linux%E5%AE%89%E8%A3%85/", "categories": "数据库", "tags": "MySQL", "date": "2021-07-01 00:00:00 +0800", "snippet": "1.MySQL的4大版本1. MySQL Community Server 社区版本，开源免费，自由下载，但不提供官方技术支持，适用于大多数普通用户。2. MySQL Enterprise Edition 企业版本，需付费，不能在线下载，可以试用30天。提供了更多的功能和更完备的技术支持，更适合于对数据库的功能和可靠性要求较高的企业客户。3. MySQL Cluster 集群版，开源免费。用于架设集群服务器，可将几个MySQL Server封装成一个Server。需要在社区版或企业版的基础上使用。4. MySQL Cluster CGE 高级集群版，需付费1.1 MySQL卸载# 删除数据文件sudo rm /var/lib/mysql/ -R# 删除mysql的配置文件sudo rm /etc/mysql/ -R# 自动卸载mysql（包括server和client）sudo apt-get autoremove mysql* --purgesudo apt-get remove apparmor# 检查是否卸载干净dpkg -l | grep mysql# 若没有返回，说明已完成卸载1.2 MySQL安装sudo apt-get install mysql-server mysql-client# 检查安装zheng@ubuntu:~/Desktop$ mysql -Vmysql Ver 8.0.29-0ubuntu0.20.04.3 for Linux on x86_64 ((Ubuntu))zheng@ubuntu:/var/log/mysql$ systemctl status mysql● mysql.service - MySQL Community Server Loaded: loaded (/lib/systemd/system/mysql.service; enabled; vendor preset: enabled) Active: active (running) since Tue 2022-05-31 11:35:36 CST; 32s ago Process: 40389 ExecStartPre=/usr/share/mysql/mysql-systemd-start pre (code=exited, status=0/SUCCESS) Main PID: 40397 (mysqld) Status: &quot;Server is operational&quot; Tasks: 39 (limit: 9420) Memory: 359.4M CGroup: /system.slice/mysql.service └─40397 /usr/sbin/mysqld5月 31 11:35:36 ubuntu systemd[1]: Starting MySQL Community Server...5月 31 11:35:36 ubuntu systemd[1]: Started MySQL Community Server.root@ubuntu:~# mysqlWelcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 13Server version: 8.0.29-0ubuntu0.20.04.3 (Ubuntu)Copyright (c) 2000, 2022, Oracle and/or its affiliates.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &#39;help;&#39; or &#39;\\h&#39; for help. Type &#39;\\c&#39; to clear the current input statement.mysql&amp;gt; # 开机自启动root@ubuntu:~# systemctl list-unit-files | grep mysqlmysql.service enabled enabled # 如果不是enabledroot@ubuntu:~# systemctl enable mysqld.service1.3 远程连接1.关注机器是否开启防火墙# ubuntu系统root@ubuntu:~# ufw status状态： 激活至 动作 来自- -- --3306 ALLOW Anywhere 22 ALLOW Anywhere 3306 (v6) ALLOW Anywhere (v6) 22 (v6) ALLOW Anywhere (v6) root@ubuntu:~# ufw enable在系统启动时启用和激活防火墙root@ubuntu:~# ufw disable 防火墙在系统启动时自动禁用# 如果3306端口没有打开，需要打开3306端口ufw allow 3306# 如果需要关闭，使用下面命令ufw delete allow 33062.更改权限mysql&amp;gt; use mysqlDatabase changedmysql&amp;gt; select host,user from user;+-----------+------------------+| host | user |+-----------+------------------+| localhost | debian-sys-maint || localhost | mysql.infoschema || localhost | mysql.session || localhost | mysql.sys || localhost | root |+-----------+------------------+5 rows in set (0.00 sec)更新user表中的root的属性# 此处可以直接使用%，所有用户都可以连接update user set host = &#39;192.168.1.%&#39; where user = &#39;root&#39;;flush privileges;在mysql8.0中，需要修改密码保存格式alter user &#39;root&#39;@&#39;%&#39; identified with mysql_native_password by &#39;abc123&#39;;外部连接即可2.字符集2.1 修改字符集​ 在MySQL 8.0版本之前，默认字符集为 latin1 ，utf8字符集指向的是 utf8mb3 。网站开发人员在数据库 设计的时候往往会将编码修改为utf8字符集。如果遗忘修改默认的编码，就会出现乱码的问题。从MySQL 8.0开始，数据库的默认编码将改为 utf8mb4 ，从而避免上述乱码的问题。show variables like &#39;%char%&#39;;+--------------------------+----------------------------+| Variable_name | Value |+--------------------------+----------------------------+| character_set_client | utf8mb4 || character_set_connection | utf8mb4 || character_set_database | utf8mb4 || character_set_filesystem | binary || character_set_results | utf8mb4 || character_set_server | utf8mb4 || character_set_system | utf8mb3 || character_sets_dir | /usr/share/mysql/charsets/ |+--------------------------+----------------------------+8 rows in set (0.00 sec)在MySQL5.7或之前的版本中，在文件最后加上中文字符集配置：vim /etc/my.cnf# 在[mysqld]下添加下面的修改character_set_server=utf8systemctl restart mysqld这样，没修改前录入的数据任然是latin，修改后录入的才是utf8。所以，已有的数据需要导出后，重新导入才行。修改已创建数据库的字符集alter database dbtest1 character set &#39;utf8&#39;;修改已创建数据表的字符集alter table t_emp convert to character set &#39;utf8&#39;;注意：但是原有的数据如果是用非&#39;utf8&#39;编码的话，数据本身编码不会发生改变。已有数据需要导出或删除，然后重新插入。2.2 各级别的字符集MySQL有4个级别的字符集和比较规则，分别是： 服务器级别 数据库级别 表级别 列级别执行如下SQL语句：show variables like &#39;character%&#39;;+--------------------------+----------------------------+| Variable_name | Value |+--------------------------+----------------------------+| character_set_client | utf8mb4 || character_set_connection | utf8mb4 || character_set_database | utf8mb4 || character_set_filesystem | binary || character_set_results | utf8mb4 || character_set_server | utf8mb4 || character_set_system | utf8mb3 || character_sets_dir | /usr/share/mysql/charsets/ |+--------------------------+----------------------------+8 rows in set (0.01 sec) character_set_server：服务器级别的字符集 character_set_database：当前数据库的字符集 character_set_client：服务器解码请求时使用的字符集 character_set_connection：服务器处理请求时会把请求字符串从character_set_client转为 character_set_connection character_set_results：服务器向客户端返回数据时使用的字符集1.服务器级别character_set_server ：服务器级别的字符集。我们可以在启动服务器程序时通过启动选项或者在服务器程序运行过程中使用 SET 语句修改这两个变量 的值。比如我们可以在配置文件中这样写：[server]character_set_server=gbk # 默认字符集collation_server=gbk_chinese_ci #对应的默认的比较规则当服务器启动的时候读取这个配置文件后这两个系统变量的值便修改了。2.数据库级别character_set_database ：当前数据库的字符集我们在创建和修改数据库的时候可以指定该数据库的字符集和比较规则，具体语法如下：CREATE DATABASE 数据库名[[DEFAULT] CHARACTER SET 字符集名称][[DEFAULT] COLLATE 比较规则名称];ALTER DATABASE 数据库名[[DEFAULT] CHARACTER SET 字符集名称][[DEFAULT] COLLATE 比较规则名称];3.表级别我们也可以在创建和修改表的时候指定表的字符集和比较规则，语法如下：CREATE TABLE 表名 (列的信息)[[DEFAULT] CHARACTER SET 字符集名称][COLLATE 比较规则名称]]ALTER TABLE 表名[[DEFAULT] CHARACTER SET 字符集名称][COLLATE 比较规则名称]4.列级别对于存储字符串的列，同一个表中的不同的列也可以有不同的字符集和比较规则。我们在创建和修改列 定义的时候可以指定该列的字符集和比较规则，语法如下：CREATE TABLE 表名(列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称],其他列...);ALTER TABLE 表名 MODIFY 列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称];对于某个列来说，如果在创建和修改的语句中没有指明字符集和比较规则，将使用该列所在表的字符集 和比较规则作为该列的字符集和比较规则。提示 在转换列的字符集时需要注意，如果转换前列中存储的数据不能用转换后的字符集进行表示会发生 错误。比方说原先列使用的字符集是utf8，列中存储了一些汉字，现在把列的字符集转换为ascii的 话就会出错，因为ascii字符集并不能表示汉字字符。5.小结我们介绍的这4个级别字符集和比较规则的联系如下： 如果 创建或修改列 时没有显式的指定字符集和比较规则，则该列 默认用表的 字符集和比较规则 如果 创建表时 没有显式的指定字符集和比较规则，则该表 默认用数据库的 字符集和比较规则 如果 创建数据库时 没有显式的指定字符集和比较规则，则该数据库 默认用服务器的 字符集和比较规 则 知道了这些规则之后，对于给定的表，我们应该知道它的各个列的字符集和比较规则是什么，从而根据 这个列的类型来确定存储数据时每个列的实际数据占用的存储空间大小了。比方说我们向表 t 中插入一 条记录：mysql&amp;gt; INSERT INTO t(col) VALUES(&#39;我们&#39;);Query OK, 1 row affected (0.00 sec)mysql&amp;gt; SELECT * FROM t;+--------+| s |+--------+| 我们 |+--------+1 row in set (0.00 sec)首先列 col 使用的字符集是 gbk ，一个字符 &#39;我&#39; 在 gbk 中的编码为 0xCED2 ，占用两个字节，两个字 符的实际数据就占用4个字节。如果把该列的字符集修改为 utf8 的话，这两个字符就实际占用6个字节3 字符集与比较规则(了解)1. utf8 与 utf8mb4utf8 字符集表示一个字符需要使用1～4个字节，但是我们常用的一些字符使用1～3个字节就可以表示 了。而字符集表示一个字符所用的最大字节长度，在某些方面会影响系统的存储和性能，所以设计 MySQL的设计者偷偷的定义了两个概念： utf8mb3 ：阉割过的 utf8 字符集，只使用1～3个字节表示字符。 utf8mb4 ：正宗的 utf8 字符集，使用1～4个字节表示字符。 2. 比较规则上表中，MySQL版本一共支持41种字符集，其中的 Default collation 列表示这种字符集中一种默认 的比较规则，里面包含着该比较规则主要作用于哪种语言，比如 utf8_polish_ci 表示以波兰语的规则 比较， utf8_spanish_ci 是以西班牙语的规则比较， utf8_general_ci 是一种通用的比较规则。后缀表示该比较规则是否区分语言中的重音、大小写。具体如下： 后缀 英文释义 描述 _ai accent insensitive 不区分重音 _as accent sensitive 区分重音 _ci case insensitive 不区分大小写 _cs case sensitive 区分大小写 _bin binary 以二进制方式比较 最后一列 Maxlen ，它代表该种字符集表示一个字符最多需要几个字节。常用操作1：#查看GBK字符集的比较规则SHOW COLLATION LIKE &#39;gbk%&#39;;#查看UTF-8字符集的比较规则SHOW COLLATION LIKE &#39;utf8%&#39;;常用操作2：#查看服务器的字符集和比较规则SHOW VARIABLES LIKE &#39;%_server&#39;;#查看数据库的字符集和比较规则SHOW VARIABLES LIKE &#39;%_database&#39;;#查看具体数据库的字符集SHOW CREATE DATABASE dbtest1;#修改具体数据库的字符集ALTER DATABASE dbtest1 DEFAULT CHARACTER SET &#39;utf8&#39; COLLATE &#39;utf8_general_ci&#39;;常用操作3：#查看表的字符集show create table employees;#查看表的比较规则show table status from atguigudb like &#39;employees&#39;;#修改表的字符集和比较规则ALTER TABLE emp1 DEFAULT CHARACTER SET &#39;utf8&#39; COLLATE &#39;utf8_general_ci&#39;;3.请求到响应过程中字符集的变化 系统变量 描述 character_set_client 服务器解码请求时使用的字符集 character_set_connection 服务器处理请求时会把请求字符串从 character_set_client 转为 character_set_connection character_set_results 服务器向客户端返回数据时使用的字符集 这几个系统变量在我的计算机上的默认值如下（不同操作系统的默认值可能不同）：为了体现出字符集在请求处理过程中的变化，我们这里特意修改一个系统变量的值：mysql&amp;gt; set character_set_connection = gbk;Query OK, 0 rows affected (0.00 sec)现在假设我们客户端发送的请求是下边这个字符串：SELECT * FROM t WHERE s = &#39;我&#39;;为了方便大家理解这个过程，我们只分析字符 ‘我’ 在这个过程中字符集的转换。 现在看一下在请求从发送到结果返回过程中字符集的变化： 客户端发送请求所使用的字符集 一般情况下客户端所使用的字符集和当前操作系统一致，不同操作系统使用的字符集可能不一 样，如下： 类 Unix 系统使用的是 utf8 Windows 使用的是 gbk 当客户端使用的是 utf8 字符集，字符 ‘我’ 在发送给服务器的请求中的字节形式就是： 0xE68891 提示 如果你使用的是可视化工具，比如navicat之类的，这些工具可能会使用自定义的字符集来编 码发送到服务器的字符串，而不采用操作系统默认的字符集（所以在学习的时候还是尽量用 命令行窗口）。 服务器接收到客户端发送来的请求其实是一串二进制的字节，它会认为这串字节采用的字符集是 character_set_client ，然后把这串字节转换为 character_set_connection 字符集编码的 字符。 由于我的计算机上 character_set_client 的值是 utf8 ，首先会按照 utf8 字符集对字节串 0xE68891 进行解码，得到的字符串就是 ‘我’ ，然后按照 character_set_connection 代表的 字符集，也就是 gbk 进行编码，得到的结果就是字节串 0xCED2 。 因为表 t 的列 col 采用的是 gbk 字符集，与 character_set_connection 一致，所以直接到列 中找字节值为 0xCED2 的记录，最后找到了一条记录。 提示 如果某个列使用的字符集和character_set_connection代表的字符集不一致的话，还需要进行 一次字符集转换。 上一步骤找到的记录中的 col 列其实是一个字节串 0xCED2 ， col 列是采用 gbk 进行编码的，所 以首先会将这个字节串使用 gbk 进行解码，得到字符串 ‘我’ ，然后再把这个字符串使用 character_set_results 代表的字符集，也就是 utf8 进行编码，得到了新的字节串： 0xE68891 ，然后发送给客户端。 由于客户端是用的字符集是 utf8 ，所以可以顺利的将 0xE68891 解释成字符 我 ，从而显示到我 们的显示器上，所以我们人类也读懂了返回的结果。 4. SQL大小写规范1.Windows和Linux平台区别​ 在 SQL 中，关键字和函数名是不用区分字母大小写的，比如 SELECT、WHERE、ORDER、GROUP BY 等关 键字，以及 ABS、MOD、ROUND、MAX 等函数名。​ 不过在 SQL 中，你还是要确定大小写的规范，因为在 Linux 和 Windows 环境下，你可能会遇到不同的大 小写问题。 windows系统默认大小写不敏感 ，但是 linux系统是大小写敏感的 。​ 通过如下命令查看：SHOW VARIABLES LIKE &#39;%lower_case_table_names%&#39;+------------------------+-------+| Variable_name | Value |+------------------------+-------+| lower_case_table_names | 0 |+------------------------+-------+1 row in set (0.00 sec)lower_case_table_names参数值的设置： 默认为0，大小写敏感 。 设置1，大小写不敏感。创建的表，数据库都是以小写形式存放在磁盘上，对于sql语句都是转 换为小写对表和数据库进行查找。 设置2，创建的表和数据库依据语句上格式存放，凡是查找都是转换为小写进行。两个平台上SQL大小写的区别具体来说：MySQL在Linux下数据库名、表名、列名、别名大小写规则是这样的：1、数据库名、表名、表的别名、变量名是严格区分大小写的；2、关键字、函数名称在 SQL 中不区分大小写；3、列名（或字段名）与列的别名（或字段别名）在所有的情况下均是忽略大小写的；MySQL在Windows的环境下全部不区分大小写2 Linux下大小写规则设置​ 当想设置为大小写不敏感时，要在 my.cnf 这个配置文件 [mysqld] 中加入 lower_case_table_names=1 ，然后重启服务器。 但是要在重启数据库实例之前就需要将原来的数据库和表转换为小写，否则将找不到数据库名。此参数适用于MySQL5.7。​ 在MySQL 8下禁止在重新启动 MySQL 服务时将 lower_case_table_names 设置成不同于初始化 MySQL 服务时设置的 lower_case_table_names 值。如果非要将MySQL8设置为大小写不敏感，具体步骤为：1、停止MySQL服务2、删除数据目录，即删除 /var/lib/mysql 目录3、在MySQL配置文件（ /etc/my.cnf ）中添加 lower_case_table_names=14、启动MySQL服务3 SQL编写建议如果你的变量名命名规范没有统一，就可能产生错误。这里有一个有关命名规范的建议：1. 关键字和函数名称全部大写；2. 数据库名、表名、表别名、字段名、字段别名等全部小写；3. SQL 语句必须以分号结尾。数据库名、表名和字段名在 Linux MySQL 环境下是区分大小写的，因此建议你统一这些字段的命名规 则，比如全部采用小写的方式。​ 虽然关键字和函数名称在 SQL 中不区分大小写，也就是如果小写的话同样可以执行。但是同时将关键词 和函数名称全部大写，以便于区分数据库名、表名、字段名。5.sql_mode的合理设置5.1 宽松模式 vs 严格模式宽松模式： 如果设置的是宽松模式，那么我们在插入数据的时候，即便是给了一个错误的数据，也可能会被接受， 并且不报错。​ 举例 ：我在创建一个表时，该表中有一个字段为name，给name设置的字段类型时 char(10) ，如果我 在插入数据的时候，其中name这个字段对应的有一条数据的 长度超过了10 ，例如’1234567890abc’，超过了设定的字段长度10，那么不会报错，并且取前10个字符存上，也就是说你这个数据被存为 了’1234567890’，而’abc’就没有了。但是，我们给的这条数据是错误的，因为超过了字段长度，但是并没 有报错，并且mysql自行处理并接受了，这就是宽松模式的效果。应用场景 ：通过设置sql mode为宽松模式，来保证大多数sql符合标准的sql语法，这样应用在不同数据库之间进行迁移 时，则不需要对业务sql 进行较大的修改。严格模式： 出现上面宽松模式的错误，应该报错才对，所以MySQL5.7版本就将sql_mode默认值改为了严格模式。所 以在 生产等环境 中，我们必须采用的是严格模式，进而 开发、测试环境 的数据库也必须要设置，这样在 开发测试阶段就可以发现问题。并且我们即便是用的MySQL5.6，也应该自行将其改为严格模式。​ 开发经验 ：MySQL等数据库总想把关于数据的所有操作都自己包揽下来，包括数据的校验，其实开发 中，我们应该在自己 开发的项目程序级别将这些校验给做了 ，虽然写项目的时候麻烦了一些步骤，但是这 样做之后，我们在进行数据库迁移或者在项目的迁移时，就会方便很多。 改为严格模式后可能会存在的问题：若设置模式中包含了 NO_ZERO_DATE ，那么MySQL数据库不允许插入零日期，插入零日期会抛出错误而 不是警告。例如，表中含字段TIMESTAMP列（如果未声明为NULL或显示DEFAULT子句）将自动分配 DEFAULT ‘0000-00-00 00:00:00’（零时间戳），这显然是不满足sql_mode中的NO_ZERO_DATE而报错。5.2 模式查看和设置查看当前的sql_modeselect @@session.sql_modeselect @@global.sql_mode#或者show variables like &#39;sql_mode&#39;;临时设置方式：设置当前窗口中设置sql_modeSET GLOBAL sql_mode = &#39;modes...&#39;; #全局SET SESSION sql_mode = &#39;modes...&#39;; #当前会话#改为严格模式。此方法只在当前会话中生效，关闭当前会话就不生效了。set SESSION sql_mode=&#39;STRICT_TRANS_TABLES&#39;;#改为严格模式。此方法在当前服务中生效，重启MySQL服务后失效。set GLOBAL sql_mode=&#39;STRICT_TRANS_TABLES&#39;;永久设置方式：在/etc/my.cnf中配置sql_mode在my.cnf文件(windows系统是my.ini文件)，新增：[mysqld]sql_mode=ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION然后 重启MySQL 。​ 当然生产环境上是禁止重启MySQL服务的，所以采用 临时设置方式 + 永久设置方式 来解决线上的问题， 那么即便是有一天真的重启了MySQL服务，也会永久生效了。" }, { "title": "MySQL触发器", "url": "/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E8%A7%A6%E5%8F%91%E5%99%A8/", "categories": "数据库", "tags": "MySQL", "date": "2021-06-17 00:00:00 +0800", "snippet": "​ 在实际开发中，我们经常会遇到这样的情况：有 2 个或者多个相互关联的表，如 商品信息 和 库存信息 分别存放在 2 个不同的数据表中，我们在添加一条新商品记录的时候，为了保证数据的完整性，必须同时 在库存表中添加一条库存记录。​ 这样一来，我们就必须把这两个关联的操作步骤写到程序里面，而且要用 事务 包裹起来，确保这两个操作成为一个 原子操作 ，要么全部执行，要么全部不执行。要是遇到特殊情况，可能还需要对数据进行手动维护，这样就很 容易忘记其中的一步 ，导致数据缺失。 这个时候，咱们可以使用触发器。你可以创建一个触发器，让商品信息数据的插入操作自动触发库存数据的插入操作。这样一来，就不用担心因为忘记添加库存数据而导致的数据缺失了。1. 触发器概述​ MySQL从 5.0.2 版本开始支持触发器。MySQL的触发器和存储过程一样，都是嵌入到MySQL服务器的一 段程序。​ 触发器是由 事件来触发 某个操作，这些事件包括 INSERT 、 UPDATE 、 DELETE 事件。所谓事件就是指 用户的动作或者触发某项行为。如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生 了，就会 自动 激发触发器执行相应的操作。​ 当对数据表中的数据执行插入、更新和删除操作，需要自动执行一些数据库逻辑时，可以使用触发器来实现。2. 触发器的创建2.1 创建触发器语法创建触发器的语法结构是：CREATE TRIGGER 触发器名称{BEFORE|AFTER} {INSERT|UPDATE|DELETE} ON 表名FOR EACH ROW触发器执行的语句块;说明： 表名 ：表示触发器监控的对象。 BEFORE AFTER ：表示触发的时间。BEFORE 表示在事件之前触发；AFTER 表示在事件之后触发。 INSERT UPDATE DELETE ：表示触发的事件。 INSERT 表示插入记录时触发； UPDATE 表示更新记录时触发； DELETE 表示删除记录时触发。 触发器执行的语句块 ：可以是单条SQL语句，也可以是由BEGIN…END结构组成的复合语句块。2.2 代码举例举例1：1、创建数据表：CREATE TABLE test_trigger ( id INT PRIMARY KEY AUTO_INCREMENT, t_note VARCHAR(30));CREATE TABLE test_trigger_log ( id INT PRIMARY KEY AUTO_INCREMENT, t_log VARCHAR(30));2、创建触发器：创建名称为before_insert的触发器，向test_trigger数据表插入数据之前，向 test_trigger_log数据表中插入before_insert的日志信息。DELIMITER //CREATE TRIGGER before_insertBEFORE INSERT ON test_triggerFOR EACH ROWBEGININSERT INTO test_trigger_log (t_log)VALUES(&#39;before_insert&#39;);END //DELIMITER ;3、向test_trigger数据表中插入数据INSERT INTO test_trigger (t_note) VALUES (&#39;测试 BEFORE INSERT 触发器&#39;);4、查看test_trigger_log数据表中的数据mysql&amp;gt; SELECT * FROM test_trigger_log;+----+---------------+| id | t_log |+----+---------------+| 1 | before_insert |+----+---------------+1 row in set (0.00 sec)举例2：1、创建名称为after_insert的触发器，向test_trigger数据表插入数据之后，向test_trigger_log数据表中插 入after_insert的日志信息。DELIMITER //CREATE TRIGGER after_insertAFTER INSERT ON test_triggerFOR EACH ROWBEGININSERT INTO test_trigger_log (t_log)VALUES(&#39;after_insert&#39;);END //DELIMITER ;2、向test_trigger数据表中插入数据。INSERT INTO test_trigger (t_note) VALUES (&#39;测试 AFTER INSERT 触发器&#39;);3、查看test_trigger_log数据表中的数据mysql&amp;gt; SELECT * FROM test_trigger_log;+----+---------------+| id | t_log |+----+---------------+| 1 | before_insert || 2 | before_insert || 3 | after_insert |+----+---------------+3 rows in set (0.00 sec)举例3：定义触发器“salary_check_trigger”，基于员工表“employees”的INSERT事件，在INSERT之前检查 将要添加的新员工薪资是否大于他领导的薪资，如果大于领导薪资，则报sqlstate_value为’HY000’的错 误，从而使得添加失败。DELIMITER //CREATE TRIGGER salary_check_triggerBEFORE INSERT ON employees FOR EACH ROWBEGINDECLARE mgrsalary DOUBLE;SELECT salary INTO mgrsalary FROM employees WHERE employee_id = NEW.manager_id;IF NEW.salary &amp;gt; mgrsalary THENSIGNAL SQLSTATE &#39;HY000&#39; SET MESSAGE_TEXT = &#39;薪资高于领导薪资错误&#39;;END IF;END //DELIMITER ;上面触发器声明过程中的NEW关键字代表INSERT添加语句的新记录。3. 查看、删除触发器3.1 查看触发器查看触发器是查看数据库中已经存在的触发器的定义、状态和语法信息等。方式1：查看当前数据库的所有触发器的定义SHOW TRIGGERS\\G方式2：查看当前数据库中某个触发器的定义SHOW CREATE TRIGGER 触发器名方式3：从系统库information_schema的TRIGGERS表中查询“salary_check_trigger”触发器的信息。SELECT * FROM information_schema.TRIGGERS;3.2 删除触发器触发器也是数据库对象，删除触发器也用DROP语句，语法格式如下：DROP TRIGGER IF EXISTS 触发器名称;4. 触发器的优缺点4.1 优点1、触发器可以确保数据的完整性。​ 假设我们用 进货单头表 （demo.importhead）来保存进货单的总体信息，包括进货单编号、供货商编号、仓库编号、总计进货数量、总计进货金额和验收日期。 进货单编号 供货商编号 参库编号 总计数量 总计金额 验收日期             用 进货单明细表 （demo.importdetails）来保存进货商品的明细，包括进货单编号、商品编号、进货数量、进货价格和进货金额。 进货单编号 商品编号 进货数量 进货价格 进货金额           ​ 每当我们录入、删除和修改一条进货单明细数据的时候，进货单明细表里的数据就会发生变动。这个时候，在进货单头表中的总计数量和总计金额就必须重新计算，否则，进货单头表中的总计数量和总计金额就不等于进货单明细表中数量合计和金额合计了，这就是数据不一致。为了解决这个问题，我们就可以使用触发器，规定每当进货单明细表有数据插入、修改和删除的操作 时，自动触发 2 步操作：1）重新计算进货单明细表中的数量合计和金额合计；2）用第一步中计算出来的值更新进货单头表中的合计数量与合计金额。这样一来，进货单头表中的合计数量与合计金额的值，就始终与进货单明细表中计算出来的合计数量与 合计金额的值相同，数据就是一致的，不会互相矛盾。2、触发器可以帮助我们记录操作日志。​ 利用触发器，可以具体记录什么时间发生了什么。比如，记录修改会员储值金额的触发器，就是一个很好的例子。这对我们还原操作执行时的具体场景，更好地定位问题原因很有帮助。3、触发器还可以用在操作数据前，对数据进行合法性检查。​ 比如，超市进货的时候，需要库管录入进货价格。但是，人为操作很容易犯错误，比如说在录入数量的时候，把条形码扫进去了；录入金额的时候，看串了行，录入的价格远超售价，导致账面上的巨亏…… 这些都可以通过触发器，在实际插入或者更新操作之前，对相应的数据进行检查，及时提示错误，防止错误数据进入系统。4.2 缺点1、触发器最大的一个问题就是可读性差。​ 因为触发器存储在数据库中，并且由事件驱动，这就意味着触发器有可能 不受应用层的控制 。这对系统维护是非常有挑战的。比如，创建触发器用于修改会员储值操作。如果触发器中的操作出了问题，会导致会员储值金额更新失 败。我用下面的代码演示一下：mysql&amp;gt; update demo.membermaster set memberdeposit=20 where memberid = 2;ERROR 1054 (42S22): Unknown column &#39;aa&#39; in &#39;field list&#39;结果显示，系统提示错误，字段“aa”不存在。​ 这是因为，触发器中的数据插入操作多了一个字段，系统提示错误。可是，如果你不了解这个触发器， 很可能会认为是更新语句本身的问题，或者是会员信息表的结构出了问题。说不定你还会给会员信息表 添加一个叫“aa”的字段，试图解决这个问题，结果只能是白费力。2、相关数据的变更，可能会导致触发器出错。​ 特别是数据表结构的变更，都可能会导致触发器出错，进而影响数据操作的正常运行。这些都会由于触 发器本身的隐蔽性，影响到应用中错误原因排查的效率。4.3 注意点​ 注意，如果在子表中定义了外键约束，并且外键指定了ON UPDATE/DELETE CASCADE/SET NULL子句，此时修改父表被引用的键值或删除父表被引用的记录行时，也会引起子表的修改和删除操作，此时基于子 表的UPDATE和DELETE语句定义的触发器并不会被激活。例如：基于子表员工表（t_employee）的DELETE语句定义了触发器t1，而子表的部门编号（did）字段定 义了外键约束引用了父表部门表（t_department）的主键列部门编号（did），并且该外键加了“ON DELETE SET NULL”子句，那么如果此时删除父表部门表（t_department）在子表员工表（t_employee） 有匹配记录的部门记录时，会引起子表员工表（t_employee）匹配记录的部门编号（did）修改为NULL，但是此时不会激活触发器t1。只有直接对子表员工表（t_employee）执行DELETE语句时才会激活触发器 t1。" }, { "title": "MySQL变量、流程控制和游标", "url": "/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E5%8F%98%E9%87%8F-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%92%8C%E6%B8%B8%E6%A0%87/", "categories": "数据库", "tags": "MySQL", "date": "2021-06-16 00:00:00 +0800", "snippet": "1. 变量​ 在MySQL数据库的存储过程和函数中，可以使用变量来存储查询或计算的中间结果数据，或者输出最终 的结果数据。 在 MySQL 数据库中，变量分为 系统变量 以及 用户自定义变量 。1.1 系统变量1.1.1 系统变量分类​ 变量由系统定义，不是用户定义，属于 服务器 层面。启动MySQL服务，生成MySQL服务实例期间， MySQL将为MySQL服务器内存中的系统变量赋值，这些系统变量定义了当前MySQL服务实例的属性、特 征。这些系统变量的值要么是 编译MySQL时参数 的默认值，要么是 配置文件 （例如my.ini等）中的参数 值。大家可以通过网址 https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html 查看MySQL文档的系统变量。​ 系统变量分为全局系统变量（需要添加 global 关键字）以及会话系统变量（需要添加 session 关键 字），有时也把全局系统变量简称为全局变量，有时也把会话系统变量称为local变量。如果不写，默认 会话级别。静态变量（在 MySQL 服务实例运行期间它们的值不能使用 set 动态修改）属于特殊的全局系 统变量。​ 每一个MySQL客户机成功连接MySQL服务器后，都会产生与之对应的会话。会话期间，MySQL服务实例 会在MySQL服务器内存中生成与该会话对应的会话系统变量，这些会话系统变量的初始值是全局系统变 量值的复制。如下图： 全局系统变量针对于所有会话（连接）有效，但 不能跨重启 会话系统变量仅针对于当前会话（连接）有效。会话期间，当前会话对某个会话系统变量值的修 改，不会影响其他会话同一个会话系统变量的值。 会话1对某个全局系统变量值的修改会导致会话2中同一个全局系统变量值的修改。​ 在MySQL中有些系统变量只能是全局的，例如 max_connections 用于限制服务器的最大连接数；有些系 统变量作用域既可以是全局又可以是会话，例如 character_set_client 用于设置客户端的字符集；有些系 统变量的作用域只能是当前会话，例如 pseudo_thread_id 用于标记当前会话的 MySQL 连接 ID。1.1.2 查看系统变量查看所有或部分系统变量#查看所有全局变量SHOW GLOBAL VARIABLES;#查看所有会话变量SHOW SESSION VARIABLES;或SHOW VARIABLES;#查看满足条件的部分系统变量。SHOW GLOBAL VARIABLES LIKE &#39;%标识符%&#39;;#查看满足条件的部分会话变量SHOW SESSION VARIABLES LIKE &#39;%标识符%&#39;;举例：SHOW GLOBAL VARIABLES LIKE &#39;admin_%&#39;;查看指定系统变量​ 作为 MySQL 编码规范，MySQL 中的系统变量以 两个“@” 开头，其中“@@global”仅用于标记全局系统变 量，“@@session”仅用于标记会话系统变量。“@@”首先标记会话系统变量，如果会话系统变量不存在， 则标记全局系统变量。#查看指定的系统变量的值SELECT @@global.变量名;#查看指定的会话变量的值SELECT @@session.变量名;#或者SELECT @@变量名;修改系统变量的值​ 有些时候，数据库管理员需要修改系统变量的默认值，以便修改当前会话或者MySQL服务实例的属性、 特征。具体方法： 方式1：修改MySQL 配置文件 ，继而修改MySQL系统变量的值（该方法需要重启MySQL服务） 方式2：在MySQL服务运行期间，使用“set”命令重新设置系统变量的值#为某个系统变量赋值#方式1：SET @@global.变量名=变量值;#方式2：SET GLOBAL 变量名=变量值;#为某个会话变量赋值#方式1：SET @@session.变量名=变量值;#方式2：SET SESSION 变量名=变量值;举例：SELECT @@global.autocommit;SET GLOBAL autocommit=0;SELECT @@session.tx_isolation;SET @@session.tx_isolation=&#39;read-uncommitted&#39;;SET GLOBAL max_connections = 1000;SELECT @@global.max_connections;1.2 用户变量1.2.1 用户变量分类​ 用户变量是用户自己定义的，作为 MySQL 编码规范，MySQL 中的用户变量以 一个“@” 开头。根据作用 范围不同，又分为 会话用户变量 和 局部变量 。 会话用户变量：作用域和会话变量一样，只对 当前连接 会话有效。 局部变量：只在 BEGIN 和 END 语句块中有效。局部变量只能在 存储过程和函数 中使用。1.2.2 会话用户变量变量的定义#方式1：“=”或“:=”SET @用户变量 = 值;SET @用户变量 := 值;#方式2：“:=” 或 INTO关键字SELECT @用户变量 := 表达式 [FROM 等子句];SELECT 表达式 INTO @用户变量 [FROM 等子句];查看用户变量的值 （查看、比较、运算等）SELECT @用户变量举例SET @a = 1;SELECT @a;SELECT @num := COUNT(*) FROM employees;SELECT @num;SELECT AVG(salary) INTO @avgsalary FROM employees;SELECT @avgsalary;SELECT @big; #查看某个未声明的变量时，将得到NULL值1.2.3 局部变量定义：可以使用 DECLARE 语句定义一个局部变量作用域：仅仅在定义它的 BEGIN … END 中有效位置：只能放在 BEGIN … END 中，而且只能放在第一句BEGIN#声明局部变量DECLARE 变量名1 变量数据类型 [DEFAULT 变量默认值];DECLARE 变量名2,变量名3,... 变量数据类型 [DEFAULT 变量默认值];#为局部变量赋值SET 变量名1 = 值;SELECT 值 INTO 变量名2 [FROM 子句];#查看局部变量的值SELECT 变量1,变量2,变量3;END1.定义变量DECLARE 变量名 类型 [default 值]; # 如果没有DEFAULT子句，初始值为NULL举例：DECLARE myparam INT DEFAULT 100;2.变量赋值方式1：一般用于赋简单的值SET 变量名=值;SET 变量名:=值;方式2：一般用于赋表中的字段值SELECT 字段名或表达式 INTO 变量名 FROM 表;3.使用变量（查看、比较、运算等）SELECT 局部变量名;举例1：声明局部变量，并分别赋值为employees表中employee_id为102的last_name和salaryDELIMITER //CREATE PROCEDURE set_value()BEGINDECLARE emp_name VARCHAR(25);DECLARE sal DOUBLE(10,2);SELECT last_name,salary INTO emp_name,salFROM employeesWHERE employee_id = 102;SELECT emp_name,sal;END //DELIMITER ;举例2：声明两个变量，求和并打印 （分别使用会话用户变量、局部变量的方式实现）#方式1：使用用户变量SET @m=1;SET @n=1;SET @sum=@m+@n;SELECT @sum;#方式2：使用局部变量DELIMITER //CREATE PROCEDURE add_value()BEGIN#局部变量DECLARE m INT DEFAULT 1;DECLARE n INT DEFAULT 3;DECLARE SUM INT;SET SUM = m+n;SELECT SUM;END //DELIMITER ;举例3：创建存储过程“different_salary”查询某员工和他领导的薪资差距，并用IN参数emp_id接收员工 id，用OUT参数dif_salary输出薪资差距结果。#声明DELIMITER //CREATE PROCEDURE different_salary(IN emp_id INT,OUT dif_salary DOUBLE)BEGIN#声明局部变量DECLARE emp_sal,mgr_sal DOUBLE DEFAULT 0.0;DECLARE mgr_id INT;SELECT salary INTO emp_sal FROM employees WHERE employee_id = emp_id;SELECT manager_id INTO mgr_id FROM employees WHERE employee_id = emp_id;SELECT salary INTO mgr_sal FROM employees WHERE employee_id = mgr_id;SET dif_salary = mgr_sal - emp_sal;END //DELIMITER ;#调用SET @emp_id = 102;CALL different_salary(@emp_id,@diff_sal);#查看SELECT @diff_sal;1.2.4 对比会话用户变量与局部变量   作用域 定义位置 语法 会话用户变量 当前会话 会话的任何地方 加@符号，不用指定类型 局部变量 定义它的BEGIN AND 中 BEGIN END的第一句话 一般不加@，需要指定类型 2. 定义条件与处理程序定义条件 是事先定义程序执行过程中可能遇到的问题， 处理程序定义了在遇到问题时应当采取的处理方 式，并且保证存储过程或函数在遇到警告或错误时能继续执行。这样可以增强存储程序处理问题的能 力，避免程序异常停止运行。 说明：定义条件和处理程序在存储过程、存储函数中都是支持的。2.1 案例分析案例分析：创建一个名称为“UpdateDataNoCondition”的存储过程。代码如下：DELIMITER //CREATE PROCEDURE UpdateDataNoCondition()BEGINSET @x = 1;UPDATE employees SET email = NULL WHERE last_name = &#39;Abel&#39;;SET @x = 2;UPDATE employees SET email = &#39;aabbel&#39; WHERE last_name = &#39;Abel&#39;;SET @x = 3;END //DELIMITER ;调用存储过程：mysql&amp;gt; CALL UpdateDataNoCondition();ERROR 1048 (23000): Column &#39;email&#39; cannot be nullmysql&amp;gt; SELECT @x;+------+| @x |+------+| 1 |+------+1 row in set (0.00 sec)​ 可以看到，此时@x变量的值为1。结合创建存储过程的SQL语句代码可以得出：在存储过程中未定义条件 和处理程序，且当存储过程中执行的SQL语句报错时，MySQL数据库会抛出错误，并退出当前SQL逻辑， 不再向下继续执行。2.2 定义条件定义条件就是给MySQL中的错误码命名，这有助于存储的程序代码更清晰。它将一个 错误名字 和 指定的 错误条件 关联起来。这个名字可以随后被用在定义处理程序的 DECLARE HANDLER 语句中。 定义条件使用DECLARE语句，语法格式如下：DECLARE 错误名称 CONDITION FOR 错误码（或错误条件）错误码的说明： MySQL_error_code 和 sqlstate_value 都可以表示MySQL的错误。 MySQL_error_code是数值类型错误代码。 sqlstate_value是长度为5的字符串类型错误代码。 例如，在ERROR 1418 (HY000)中，1418是MySQL_error_code，’HY000’是sqlstate_value。 例如，在ERROR 1142（42000）中，1142是MySQL_error_code，’42000’是sqlstate_value。举例1：定义“Field_Not_Be_NULL”错误名与MySQL中违反非空约束的错误类型是“ERROR 1048 (23000)”对 应。#使用MySQL_error_codeDECLARE Field_Not_Be_NULL CONDITION FOR 1048;#使用sqlstate_valueDECLARE Field_Not_Be_NULL CONDITION FOR SQLSTATE &#39;23000&#39;;举例2：定义”ERROR 1148(42000)”错误，名称为command_not_allowed。#使用MySQL_error_codeDECLARE command_not_allowed CONDITION FOR 1148;#使用sqlstate_valueDECLARE command_not_allowed CONDITION FOR SQLSTATE &#39;42000&#39;;2.3 定义处理程序可以为SQL执行过程中发生的某种类型的错误定义特殊的处理程序。定义处理程序时，使用DECLARE语句 的语法如下：DECLARE 处理方式 HANDLER FOR 错误类型 处理语句处理方式：处理方式有3个取值：CONTINUE、EXIT、UNDO。 CONTINUE ：表示遇到错误不处理，继续执行。 EXIT ：表示遇到错误马上退出。 UNDO ：表示遇到错误后撤回之前的操作。MySQL中暂时不支持这样的操作。错误类型（即条件）可以有如下取值： SQLSTATE ‘字符串错误码’ ：表示长度为5的sqlstate_value类型的错误代码； MySQL_error_code ：匹配数值类型错误代码； 错误名称 ：表示DECLARE … CONDITION定义的错误条件名称。 SQLWARNING ：匹配所有以01开头的SQLSTATE错误代码； NOT FOUND ：匹配所有以02开头的SQLSTATE错误代码； SQLEXCEPTION ：匹配所有没有被SQLWARNING或NOT FOUND捕获的SQLSTATE错误代码；处理语句：如果出现上述条件之一，则采用对应的处理方式，并执行指定的处理语句。语句可以是 像“ SET 变量 = 值 ”这样的简单语句，也可以是使用 BEGIN … END 编写的复合语句。定义处理程序的几种方式，代码如下：#方法1：捕获sqlstate_valueDECLARE CONTINUE HANDLER FOR SQLSTATE &#39;42S02&#39; SET @info = &#39;NO_SUCH_TABLE&#39;;#方法2：捕获mysql_error_valueDECLARE CONTINUE HANDLER FOR 1146 SET @info = &#39;NO_SUCH_TABLE&#39;;#方法3：先定义条件，再调用DECLARE no_such_table CONDITION FOR 1146;DECLARE CONTINUE HANDLER FOR NO_SUCH_TABLE SET @info = &#39;NO_SUCH_TABLE&#39;;#方法4：使用SQLWARNINGDECLARE EXIT HANDLER FOR SQLWARNING SET @info = &#39;ERROR&#39;;#方法5：使用NOT FOUNDDECLARE EXIT HANDLER FOR NOT FOUND SET @info = &#39;NO_SUCH_TABLE&#39;;#方法6：使用SQLEXCEPTIONDECLARE EXIT HANDLER FOR SQLEXCEPTION SET @info = &#39;ERROR&#39;;2.4 案例解决​ 在存储过程中，定义处理程序，捕获sqlstate_value值，当遇到MySQL_error_code值为1048时，执行 CONTINUE操作，并且将@proc_value的值设置为-1。DELIMITER //CREATE PROCEDURE UpdateDataNoCondition()BEGIN#定义处理程序DECLARE CONTINUE HANDLER FOR 1048 SET @proc_value = -1;SET @x = 1;UPDATE employees SET email = NULL WHERE last_name = &#39;Abel&#39;;SET @x = 2;UPDATE employees SET email = &#39;aabbel&#39; WHERE last_name = &#39;Abel&#39;;SET @x = 3;END //DELIMITER ;调用过程：mysql&amp;gt; CALL UpdateDataWithCondition();Query OK, 0 rows affected (0.01 sec)mysql&amp;gt; SELECT @x,@proc_value;+------+-------------+| @x | @proc_value |+------+-------------+| 3 | -1 |+------+-------------+1 row in set (0.00 sec)举例：创建一个名称为“InsertDataWithCondition”的存储过程，代码如下。在存储过程中，定义处理程序，捕获sqlstate_value值，当遇到sqlstate_value值为23000时，执行EXIT操 作，并且将@proc_value的值设置为-1。#准备工作CREATE TABLE departmentsASSELECT * FROM atguigudb.`departments`;ALTER TABLE departmentsADD CONSTRAINT uk_dept_name UNIQUE(department_id);DELIMITER //CREATE PROCEDURE InsertDataWithCondition()BEGINDECLARE duplicate_entry CONDITION FOR SQLSTATE &#39;23000&#39; ;DECLARE EXIT HANDLER FOR duplicate_entry SET @proc_value = -1;SET @x = 1;INSERT INTO departments(department_name) VALUES(&#39;测试&#39;);SET @x = 2;INSERT INTO departments(department_name) VALUES(&#39;测试&#39;);SET @x = 3;END //DELIMITER ;调用存储过程：mysql&amp;gt; CALL InsertDataWithCondition();Query OK, 0 rows affected (0.01 sec)mysql&amp;gt; SELECT @x,@proc_value;+------+-------------+| @x | @proc_value |+------+-------------+| 2 | -1 |+------+-------------+1 row in set (0.00 sec)3. 流程控制解决复杂问题不可能通过一个 SQL 语句完成，我们需要执行多个 SQL 操作。流程控制语句的作用就是控 制存储过程中 SQL 语句的执行顺序，是我们完成复杂操作必不可少的一部分。只要是执行的程序，流程 就分为三大类： 顺序结构 ：程序从上往下依次执行 分支结构 ：程序按条件进行选择执行，从两条或多条路径中选择一条执行 循环结构 ：程序满足一定条件下，重复执行一组语句针对于MySQL 的流程控制语句主要有 3 类。注意：只能用于存储程序。 条件判断语句 ：IF 语句和 CASE 语句 循环语句 ：LOOP、WHILE 和 REPEAT 语句 跳转语句 ：ITERATE 和 LEAVE 语句3.1 分支结构之 IFIF 语句的语法结构是：IF 表达式1 THEN 操作1[ELSEIF 表达式2 THEN 操作2]……[ELSE 操作N]END IF根据表达式的结果为TRUE或FALSE执行相应的语句。这里“[]”中的内容是可选的。特点：① 不同的表达式对应不同的操作 ② 使用在begin end中举例1：IF val IS NULLTHEN SELECT &#39;val is null&#39;;ELSE SELECT &#39;val is not null&#39;;END IF;举例2：声明存储过程“update_salary_by_eid1”，定义IN参数emp_id，输入员工编号。判断该员工 薪资如果低于8000元并且入职时间超过5年，就涨薪500元；否则就不变。DELIMITER //CREATE PROCEDURE update_salary_by_eid1(IN emp_id INT)BEGINDECLARE emp_salary DOUBLE;DECLARE hire_year DOUBLE;SELECT salary INTO emp_salary FROM employees WHERE employee_id = emp_id;SELECT DATEDIFF(CURDATE(),hire_date)/365 INTO hire_yearFROM employees WHERE employee_id = emp_id;IF emp_salary &amp;lt; 8000 AND hire_year &amp;gt; 5THEN UPDATE employees SET salary = salary + 500 WHERE employee_id = emp_id;END IF;END //DELIMITER ;举例3：声明存储过程“update_salary_by_eid2”，定义IN参数emp_id，输入员工编号。判断该员工 薪资如果低于9000元并且入职时间超过5年，就涨薪500元；否则就涨薪100元。DELIMITER //CREATE PROCEDURE update_salary_by_eid2(IN emp_id INT)BEGINDECLARE emp_salary DOUBLE;DECLARE hire_year DOUBLE;SELECT salary INTO emp_salary FROM employees WHERE employee_id = emp_id;SELECT DATEDIFF(CURDATE(),hire_date)/365 INTO hire_yearFROM employees WHERE employee_id = emp_id;IF emp_salary &amp;lt; 8000 AND hire_year &amp;gt; 5THEN UPDATE employees SET salary = salary + 500 WHERE employee_id =emp_id;ELSEUPDATE employees SET salary = salary + 100 WHERE employee_id = emp_id;END IF;END //DELIMITER ;举例4：声明存储过程“update_salary_by_eid3”，定义IN参数emp_id，输入员工编号。判断该员工 薪资如果低于9000元，就更新薪资为9000元；薪资如果大于等于9000元且低于10000的，但是奖金 比例为NULL的，就更新奖金比例为0.01；其他的涨薪100元。DELIMITER //CREATE PROCEDURE update_salary_by_eid3(IN emp_id INT)BEGINDECLARE emp_salary DOUBLE;DECLARE bonus DECIMAL(3,2);SELECT salary INTO emp_salary FROM employees WHERE employee_id = emp_id;SELECT commission_pct INTO bonus FROM employees WHERE employee_id = emp_id;IF emp_salary &amp;lt; 9000THEN UPDATE employees SET salary = 9000 WHERE employee_id = emp_id;DELIMITER //CREATE PROCEDURE update_salary_by_eid3(IN emp_id INT)BEGINDECLARE emp_salary DOUBLE;DECLARE bonus DECIMAL(3,2);SELECT salary INTO emp_salary FROM employees WHERE employee_id = emp_id;SELECT commission_pct INTO bonus FROM employees WHERE employee_id = emp_id;IF emp_salary &amp;lt; 9000THEN UPDATE employees SET salary = 9000 WHERE employee_id = emp_id;3.2 分支结构之 CASECASE 语句的语法结构1：#情况一：类似于switchCASE 表达式WHEN 值1 THEN 结果1或语句1(如果是语句，需要加分号)WHEN 值2 THEN 结果2或语句2(如果是语句，需要加分号)...ELSE 结果n或语句n(如果是语句，需要加分号)END [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）CASE 语句的语法结构2：#情况二：类似于多重ifCASEWHEN 条件1 THEN 结果1或语句1(如果是语句，需要加分号)WHEN 条件2 THEN 结果2或语句2(如果是语句，需要加分号)...ELSE 结果n或语句n(如果是语句，需要加分号)END [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）举例1：使用CASE流程控制语句的第1种格式，判断val值等于1、等于2，或者两者都不等。CASE valWHEN 1 THEN SELECT &#39;val is 1&#39;;WHEN 2 THEN SELECT &#39;val is 2&#39;;ELSE SELECT &#39;val is not 1 or 2&#39;;END CASE;举例2：使用CASE流程控制语句的第2种格式，判断val是否为空、小于0、大于0或者等于0。CASEWHEN val IS NULL THEN SELECT &#39;val is null&#39;;WHEN val &amp;lt; 0 THEN SELECT &#39;val is less than 0&#39;;WHEN val &amp;gt; 0 THEN SELECT &#39;val is greater than 0&#39;;ELSE SELECT &#39;val is 0&#39;;END CASE;举例3：声明存储过程“update_salary_by_eid4”，定义IN参数emp_id，输入员工编号。判断该员工 薪资如果低于9000元，就更新薪资为9000元；薪资大于等于9000元且低于10000的，但是奖金比例 为NULL的，就更新奖金比例为0.01；其他的涨薪100元。DELIMITER //CREATE PROCEDURE update_salary_by_eid4(IN emp_id INT)BEGINDECLARE emp_sal DOUBLE;DECLARE bonus DECIMAL(3,2);SELECT salary INTO emp_sal FROM employees WHERE employee_id = emp_id;SELECT commission_pct INTO bonus FROM employees WHERE employee_id = emp_id;CASEWHEN emp_sal&amp;lt;9000THEN UPDATE employees SET salary=9000 WHERE employee_id = emp_id;WHEN emp_sal&amp;lt;10000 AND bonus IS NULLTHEN UPDATE employees SET commission_pct=0.01 WHERE employee_id = emp_id;ELSEUPDATE employees SET salary=salary+100 WHERE employee_id = emp_id;END CASE;END //DELIMITER ;举例4：声明存储过程update_salary_by_eid5，定义IN参数emp_id，输入员工编号。判断该员工的 入职年限，如果是0年，薪资涨50；如果是1年，薪资涨100；如果是2年，薪资涨200；如果是3年， 薪资涨300；如果是4年，薪资涨400；其他的涨薪500。DELIMITER //CREATE PROCEDURE update_salary_by_eid5(IN emp_id INT)BEGINDECLARE emp_sal DOUBLE;DECLARE hire_year DOUBLE;SELECT salary INTO emp_sal FROM employees WHERE employee_id = emp_id;SELECT ROUND(DATEDIFF(CURDATE(),hire_date)/365) INTO hire_year FROM employeesWHERE employee_id = emp_id;CASE hire_yearWHEN 0 THEN UPDATE employees SET salary=salary+50 WHERE employee_id = emp_id;WHEN 1 THEN UPDATE employees SET salary=salary+100 WHERE employee_id = emp_id;WHEN 2 THEN UPDATE employees SET salary=salary+200 WHERE employee_id = emp_id;WHEN 3 THEN UPDATE employees SET salary=salary+300 WHERE employee_id = emp_id;WHEN 4 THEN UPDATE employees SET salary=salary+400 WHERE employee_id = emp_id;ELSE UPDATE employees SET salary=salary+500 WHERE employee_id = emp_id;END CASE;END //DELIMITER ;3.3 循环结构之LOOPLOOP循环语句用来重复执行某些语句。LOOP内的语句一直重复执行直到循环被退出（使用LEAVE子 句），跳出循环过程。 LOOP语句的基本格式如下：[loop_label:] LOOP循环执行的语句END LOOP [loop_label]其中，loop_label表示LOOP语句的标注名称，该参数可以省略。举例1： 使用LOOP语句进行循环操作，id值小于10时将重复执行循环过程。DECLARE id INT DEFAULT 0;add_loop:LOOPSET id = id +1;IF id &amp;gt;= 10 THEN LEAVE add_loop;END IF;END LOOP add_loop;举例2：当市场环境变好时，公司为了奖励大家，决定给大家涨工资。声明存储过程 “update_salary_loop()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家涨薪，薪资涨为 原来的1.1倍。直到全公司的平均薪资达到12000结束。并统计循环次数。DELIMITER //CREATE PROCEDURE update_salary_loop(OUT num INT)BEGINDECLARE avg_salary DOUBLE;DECLARE loop_count INT DEFAULT 0;SELECT AVG(salary) INTO avg_salary FROM employees;label_loop:LOOPIF avg_salary &amp;gt;= 12000 THEN LEAVE label_loop;END IF;UPDATE employees SET salary = salary * 1.1;SET loop_count = loop_count + 1;SELECT AVG(salary) INTO avg_salary FROM employees;END LOOP label_loop;SET num = loop_count;END //DELIMITER ;3.4 循环结构之WHILEWHILE语句创建一个带条件判断的循环过程。WHILE在执行语句执行时，先对指定的表达式进行判断，如 果为真，就执行循环内的语句，否则退出循环。WHILE语句的基本格式如下：[while_label:] WHILE 循环条件 DO循环体END WHILE [while_label];while_label为WHILE语句的标注名称；如果循环条件结果为真，WHILE语句内的语句或语句群被执行，直 至循环条件为假，退出循环。举例1： WHILE语句示例，i值小于10时，将重复执行循环过程，代码如下：DELIMITER //CREATE PROCEDURE test_while()BEGINDECLARE i INT DEFAULT 0;WHILE i &amp;lt; 10 DOSET i = i + 1;END WHILE;SELECT i;END //DELIMITER ;#调用CALL test_while();举例2：市场环境不好时，公司为了渡过难关，决定暂时降低大家的薪资。声明存储过程 “update_salary_while()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家降薪，薪资降 为原来的90%。直到全公司的平均薪资达到5000结束。并统计循环次数。DELIMITER //CREATE PROCEDURE update_salary_while(OUT num INT)BEGINDECLARE avg_sal DOUBLE ;DECLARE while_count INT DEFAULT 0;SELECT AVG(salary) INTO avg_sal FROM employees;WHILE avg_sal &amp;gt; 5000 DOUPDATE employees SET salary = salary * 0.9;SET while_count = while_count + 1;SELECT AVG(salary) INTO avg_sal FROM employees;END WHILE;SET num = while_count;END //DELIMITER ;3.5 循环结构之REPEAT​ REPEAT语句创建一个带条件判断的循环过程。与WHILE循环不同的是，REPEAT 循环首先会执行一次循 环，然后在 UNTIL 中进行表达式的判断，如果满足条件就退出，即 END REPEAT；如果条件不满足，则会 就继续执行循环，直到满足退出条件为止。 REPEAT语句的基本格式如下：[repeat_label:] REPEAT循环体的语句UNTIL 结束循环的条件表达式END REPEAT [repeat_label]repeat_label为REPEAT语句的标注名称，该参数可以省略；REPEAT语句内的语句或语句群被重复，直至 expr_condition为真。举例1：DELIMITER //CREATE PROCEDURE test_repeat()BEGINDECLARE i INT DEFAULT 0;REPEATSET i = i + 1;UNTIL i &amp;gt;= 10END REPEAT;SELECT i;END //DELIMITER ;举例2：当市场环境变好时，公司为了奖励大家，决定给大家涨工资。声明存储过程 “update_salary_repeat()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家涨薪，薪资涨 为原来的1.15倍。直到全公司的平均薪资达到13000结束。并统计循环次数。DELIMITER //CREATE PROCEDURE update_salary_repeat(OUT num INT)BEGINDECLARE avg_sal DOUBLE ;DECLARE repeat_count INT DEFAULT 0;SELECT AVG(salary) INTO avg_sal FROM employees;REPEATUPDATE employees SET salary = salary * 1.15;SET repeat_count = repeat_count + 1;SELECT AVG(salary) INTO avg_sal FROM employees;UNTIL avg_sal &amp;gt;= 13000END REPEAT;SET num = repeat_count;END //DELIMITER ;对比三种循环结构：1、这三种循环都可以省略名称，但如果循环中添加了循环控制语句（LEAVE或ITERATE）则必须添加名 称。2、 LOOP：一般用于实现简单的”死”循环 WHILE：先判断后执行 REPEAT：先执行后判断，无条件 至少执行一次3.6 跳转语句之LEAVE语句LEAVE语句：可以用在循环语句内，或者以 BEGIN 和 END 包裹起来的程序体内，表示跳出循环或者跳出 程序体的操作。如果你有面向过程的编程语言的使用经验，你可以把 LEAVE 理解为 break。 基本格式如下：LEAVE 标记名其中，label参数表示循环的标志。LEAVE和BEGIN … END或循环一起被使用。举例1：创建存储过程 “leave_begin()”，声明INT类型的IN参数num。给BEGIN…END加标记名，并在 BEGIN…END中使用IF语句判断num参数的值。 如果num&amp;lt;=0，则使用LEAVE语句退出BEGIN…END； 如果num=1，则查询“employees”表的平均薪资； 如果num=2，则查询“employees”表的最低薪资； 如果num&amp;gt;2，则查询“employees”表的最高薪资。IF语句结束后查询“employees”表的总人数。DELIMITER //CREATE PROCEDURE leave_begin(IN num INT)begin_label: BEGINIF num&amp;lt;=0THEN LEAVE begin_label;ELSEIF num=1THEN SELECT AVG(salary) FROM employees;ELSEIF num=2THEN SELECT MIN(salary) FROM employees;ELSESELECT MAX(salary) FROM employees;END IF;SELECT COUNT(*) FROM employees;END //DELIMITER ;举例2： 当市场环境不好时，公司为了渡过难关，决定暂时降低大家的薪资。声明存储过程“leave_while()”，声明 OUT参数num，输出循环次数，存储过程中使用WHILE循环给大家降低薪资为原来薪资的90%，直到全公 司的平均薪资小于等于10000，并统计循环次数。DELIMITER //CREATE PROCEDURE leave_while(OUT num INT)BEGIN#DECLARE avg_sal DOUBLE;#记录平均工资DECLARE while_count INT DEFAULT 0; #记录循环次数SELECT AVG(salary) INTO avg_sal FROM employees; #① 初始化条件while_label:WHILE TRUE DO #② 循环条件#③ 循环体IF avg_sal &amp;lt;= 10000 THENLEAVE while_label;END IF;UPDATE employees SET salary = salary * 0.9;SET while_count = while_count + 1;#④ 迭代条件SELECT AVG(salary) INTO avg_sal FROM employees;END WHILE;#赋值SET num = while_count;END //DELIMITER ;3.7 跳转语句之ITERATE语句ITERATE语句：只能用在循环语句（LOOP、REPEAT和WHILE语句）内，表示重新开始循环，将执行顺序 转到语句段开头处。如果你有面向过程的编程语言的使用经验，你可以把 ITERATE 理解为 continue，意 思为“再次循环”。 语句基本格式如下：ITERATE labellabel参数表示循环的标志。ITERATE语句必须跟在循环标志前面。举例： 定义局部变量num，初始值为0。循环结构中执行num + 1操作。 如果num &amp;lt; 10，则继续执行循环； 如果num &amp;gt; 15，则退出循环结构；DELIMITER //CREATE PROCEDURE test_iterate()BEGINDECLARE num INT DEFAULT 0;my_loop:LOOPSET num = num + 1;IF num &amp;lt; 10THEN ITERATE my_loop;ELSEIF num &amp;gt; 15THEN LEAVE my_loop;END IF;SELECT &#39;尚硅谷：让天下没有难学的技术&#39;;END LOOP my_loop;END //DELIMITER ;4. 游标4.1 什么是游标（或光标）​ 虽然我们也可以通过筛选条件 WHERE 和 HAVING，或者是限定返回记录的关键字 LIMIT 返回一条记录， 但是，却无法在结果集中像指针一样，向前定位一条记录、向后定位一条记录，或者是 随意定位到某一 条记录 ，并对记录的数据进行处理。​ 这个时候，就可以用到游标。游标，提供了一种灵活的操作方式，让我们能够对结果集中的每一条记录 进行定位，并对指向的记录中的数据进行操作的数据结构。游标让 SQL 这种面向集合的语言有了面向过 程开发的能力。​ 在 SQL 中，游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。这里游标 充当了 指针的作用 ，我们可以通过操作游标来对数据行进行操作。 MySQL中游标可以在存储过程和函数中使用。 比如，我们查询了 employees 数据表中工资高于15000的员工都有哪些：SELECT employee_id,last_name,salary FROM employeesWHERE salary &amp;gt; 15000;​ 这里我们就可以通过游标来操作数据行，如图所示此时游标所在的行是“108”的记录，我们也可以在结果 集上滚动游标，指向结果集中的任意一行。4.2 使用游标步骤​ 游标必须在声明处理程序之前被声明，并且变量和条件还必须在声明游标或处理程序之前被声明。 如果我们想要使用游标，一般需要经历四个步骤。不同的 DBMS 中，使用游标的语法可能略有不同。第一步，声明游标​ 在MySQL中，使用DECLARE关键字来声明游标，其语法的基本形式如下：DECLARE cursor_name CURSOR FOR select_statement;这个语法适用于 MySQL，SQL Server，DB2 和 MariaDB。​ 如果是用 Oracle 或者 PostgreSQL，需要写成：DECLARE cursor_name CURSOR IS select_statement;​ 要使用 SELECT 语句来获取数据结果集，而此时还没有开始遍历数据，这里 select_statement 代表的是 SELECT 语句，返回一个用于创建游标的结果集。比如：DECLARE cur_emp CURSOR FORSELECT employee_id,salary FROM employees;DECLARE cursor_fruit CURSOR FORSELECT f_name, f_price FROM fruits ;第二步，打开游标打开游标的语法如下：OPEN cursor_name​ 当我们定义好游标之后，如果想要使用游标，必须先打开游标。打开游标的时候 SELECT 语句的查询结 果集就会送到游标工作区，为后面游标的 逐条读取 结果集中的记录做准备。OPEN cur_emp ;第三步，使用游标（从游标中取得数据）语法如下：FETCH cursor_name INTO var_name [, var_name] ...​ 这句的作用是使用 cursor_name 这个游标来读取当前行，并且将数据保存到 var_name 这个变量中，游 标指针指到下一行。如果游标读取的数据行有多个列名，则在 INTO 关键字后面赋值给多个变量名即可。 注意：var_name必须在声明游标之前就定义好。FETCH cur_emp INTO emp_id, emp_sal ;注意：游标的查询结果集中的字段数，必须跟 INTO 后面的变量数一致，否则，在存储过程执行的时 候，MySQL 会提示错误。第四步，关闭游标CLOSE cursor_name​ 有 OPEN 就会有 CLOSE，也就是打开和关闭游标。当我们使用完游标后需要关闭掉该游标。因为游标会 占用系统资源 ，如果不及时关闭，游标会一直保持到存储过程结束，影响系统运行的效率。而关闭游标 的操作，会释放游标占用的系统资源。​ 关闭游标之后，我们就不能再检索查询结果中的数据行，如果需要检索只能再次打开游标。CLOSE cur_emp;4.3 举例​ 创建存储过程“get_count_by_limit_total_salary()”，声明IN参数 limit_total_salary，DOUBLE类型；声明 OUT参数total_count，INT类型。函数的功能可以实现累加薪资最高的几个员工的薪资值，直到薪资总和 达到limit_total_salary参数的值，返回累加的人数给total_count。DELIMITER //CREATE PROCEDURE get_count_by_limit_total_salary(IN limit_total_salary DOUBLE,OUTtotal_count INT)BEGINDECLARE sum_salary DOUBLE DEFAULT 0; #记录累加的总工资DECLARE cursor_salary DOUBLE DEFAULT 0; #记录某一个工资值DECLARE emp_count INT DEFAULT 0; #记录循环个数#定义游标DECLARE emp_cursor CURSOR FOR SELECT salary FROM employees ORDER BY salary DESC;#打开游标OPEN emp_cursor;REPEAT#使用游标（从游标中获取数据）FETCH emp_cursor INTO cursor_salary;SET sum_salary = sum_salary + cursor_salary;SET emp_count = emp_count + 1;UNTIL sum_salary &amp;gt;= limit_total_salaryEND REPEAT;SET total_count = emp_count;#关闭游标CLOSE emp_cursor;END //DELIMITER ;4.4小结​ 游标是 MySQL 的一个重要的功能，为 逐条读取 结果集中的数据，提供了完美的解决方案。跟在应用层 面实现相同的功能相比，游标可以在存储程序中使用，效率高，程序也更加简洁。 但同时也会带来一些性能问题，比如在使用游标的过程中，会对数据行进行 加锁 ，这样在业务并发量大 的时候，不仅会影响业务之间的效率，还会 消耗系统资源 ，造成内存不足，这是因为游标是在内存中进 行的处理。 建议：养成用完之后就关闭的习惯，这样才能提高系统的整体效率。补充：MySQL 8.0的新特性—全局变量的持久化​ 在MySQL数据库中，全局变量可以通过SET GLOBAL语句来设置。例如，设置服务器语句超时的限制，可 以通过设置系统变量max_execution_time来实现：SET GLOBAL MAX_EXECUTION_TIME=2000;​ 使用SET GLOBAL语句设置的变量值只会 临时生效 。 数据库重启后，服务器又会从MySQL配置文件中读取变量的默认值。 MySQL 8.0版本新增了 SET PERSIST 命令。例如，设置服务器的最大连接数为1000：SET PERSIST global max_connections = 1000;​ MySQL会将该命令的配置保存到数据目录下的 mysqld-auto.cnf 文件中，下次启动时会读取该文件，用 其中的配置来覆盖默认的配置文件。举例： 查看全局变量max_connections的值，结果如下：mysql&amp;gt; show variables like &#39;%max_connections%&#39;;+------------------------+-------+| Variable_name | Value |+------------------------+-------+| max_connections | 151 || mysqlx_max_connections | 100 |+------------------------+-------+2 rows in set, 1 warning (0.00 sec)设置全局变量max_connections的值：mysql&amp;gt; set persist max_connections=1000;Query OK, 0 rows affected (0.00 sec)重启MySQL服务器 ，再次查询max_connections的值：mysql&amp;gt; show variables like &#39;%max_connections%&#39;;+------------------------+-------+| Variable_name | Value |+------------------------+-------+| max_connections | 1000 || mysqlx_max_connections | 100 |+------------------------+-------+2 rows in set, 1 warning (0.00 sec)5.课后练习1.创建函数get_count()，返回公司的员工个数DELIMITER $CREATE FUNCTION get_count()RETURNS INTBEGIN # 声明变量 DECLARE emp_count INT; # 赋值 SELECT COUNT(*) INTO emp_count FROM employees RETURN emp_count;END $DELIMITER ;调用SELECT get_count();2.创建函数ename_salary()，根据员工姓名，返回它的工资DELIMITER $CREATE FUNCTION ename_salary(emp_name VARCHAR(15))RETURN DOUBLEBEGIN # 声明变量，定义一个会话用户变量 SET @sal = 0; # 赋值 SELECT salary INTO @sal FROM employees WHERE last_name = emp_name RETURN @sal;END $DELIMITER ;调用SELECT ename_salary(&#39;Abel&#39;)3.创建函数dept_sal()，根据部门名，返回该部门的平均工资DELIMITER //CREATE FUNCTION dept_sal(dept_name VARCHAR(15))RETURNS DOUBLEBEGIN DECLARE avg_sal DOUBLE; SELECT AVG(salary) INTO avg_sal FROM employees e JOIN departments d ON e.department_id = d.department_id WHERE d.department_name = dept_name; RETURN avg_sal; END // DELIMITER ;调用SELECT dept_sal(&#39;Marketing&#39;);4.创建函数add_float()，实现传入两个float，返回二者之和DELIMITER //CREATE FUNCTION add_float(value1 FLOAT,value2 FLOAT)RETURNS FLOATBEGIN DECLARE sun_val FLOAT; SET sum_val = value1 + value2; RETURN sum_val;END // DELIMITER ;调用SET @V1 :=12.2;SET @V2 = 2.3;SELECT add_float(@v1,@v2);5.创建函数test_if_case()，实现传入成绩，如果成绩&amp;gt;90，返回A；如果成绩大于80，返回B；如果成绩大于60，返回C，否则返回D。要求分别使用if结构和case结构实现。DELIMITER $CREATE FUNCTION test_if_case1(score DOUBLE)RETURNS CHARBEGIN DECLARE score_level CHAR; IF score &amp;gt;90 THEN SET score_level = &#39;A&#39;; IF score &amp;gt;80 THEN SET score_level = &#39;B&#39;; IF score &amp;gt;60 THEN SET score_level = &#39;C&#39;; ELSE SET score_level = &#39;D&#39;; END IF; RETURNS score_level;END $DELIMITER ;调用SELECT test_if_case1(56);6.游标的使用。创建存储过程update_salary()参数1为IN的INT类型变量dept_id，表示部门id；参数2为IN的INT类型变量change_sal_count，表示要调整薪资的员工个数。查询指定id部门的员工，按照salary升序排列，根据hire_date的情况，调整前change_sal_count个员工的薪资，详情如下。DELIMITER $CREATE PROCEDURE update_salary(IN dept_id INT,IN change_sal_count INT)BEGIN # 声明变量 DECLARE emp_id INT; DECLARE emp_hire_date DATE; DECLARE init_count INT DEFAULT 1; DECLARE add_sal_rate DOUBLE; # 声明游标 DECLARE emp_cursor cursor FOR select employee_id hire_date FROM employees WHERE department_id = dept_id ORDER BY salary ASC; # 打开游标 OPEN emp_cursor; WHILE init_count &amp;lt;= change_sal_count DO # 使用游标 FETCH emp_cursor INTO emp_id,emp_hire_date; IF(YEAR(emp_hire_date)&amp;lt;1995) THEN SET add_sal_rate=1.2; ELSEIF(YEAR(emp_hire_date)&amp;lt;1998) THEN SET add_sal_rate=1.15; ELSEIF(YEAR(emp_hire_date)&amp;lt;2001) THEN SET add_sal_rate=1.10; ELSE SET add_sal_rate=1.05; END IF ; # 涨薪操作 UPDATE employees SET salary * add_sal_rate WHERE employee_id =emp_id; # 迭代条件的更新 SET init_count = init_count+1; END WHILE; CLOSE emp_cursor;END $DELIMITER ;调用SELECT update_salary(50,2)" }, { "title": "MySQL存储过程与存储函数", "url": "/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0/", "categories": "数据库", "tags": "MySQL", "date": "2021-06-15 00:00:00 +0800", "snippet": "MySQL从5.0版本开始支持存储过程和函数。存储过程和函数能够将复杂的SQL逻辑封装在一起，应用程 序无须关注存储过程和函数内部复杂的SQL逻辑，而只需要简单地调用存储过程和函数即可。1. 存储过程概述1.1 理解含义：存储过程的英文是 Stored Procedure 。它的思想很简单，就是一组经过 预先编译 的 SQL 语句 的封装。 执行过程：存储过程预先存储在 MySQL 服务器上，需要执行的时候，客户端只需要向服务器端发出调用 存储过程的命令，服务器端就可以把预先存储好的这一系列 SQL 语句全部执行。好处：1、简化操作，提高了sql语句的重用性，减少了开发程序员的压力2、减少操作过程中的失误，提高效率3、减少网络传输量（客户端不需要把所有的 SQL 语句通过网络发给服务器）4、减少了 SQL 语句暴露在 网上的风险，也提高了数据查询的安全性和视图、函数的对比：它和视图有着同样的优点，清晰、安全，还可以减少网络传输量。不过它和视图不同，视图是 虚拟表 ， 通常不对底层数据表直接操作，而存储过程是程序化的 SQL，可以 直接操作底层数据表 ，相比于面向集 合的操作方式，能够实现一些更复杂的数据处理。 一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过调用存储过程名即可。相较于 函数，存储过程是 没有返回值 的。1.2 分类存储过程的参数类型可以是IN、OUT和INOUT。根据这点分类如下：1、没有参数（无参数无返回）2、仅仅带 IN 类型（有参数无返回）3、仅仅带 OUT 类型（无参数有返 回）4、既带 IN 又带 OUT（有参数有返回）5、带 INOUT（有参数有返回） 注意：IN、OUT、INOUT 都可以在一个存储过程中带多个。2. 创建存储过程2.1 语法分析语法：CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...)[characteristics ...]BEGIN存储过程体END类似于Java中的方法：修饰符 返回类型 方法名(参数类型 参数名,...){方法体;}说明：1、参数前面的符号的意思IN ：当前参数为输入参数，也就是表示入参； 存储过程只是读取这个参数的值。如果没有定义参数种类， 默认就是 IN ，表示输入参数。OUT ：当前参数为输出参数，也就是表示出参； 执行完成之后，调用这个存储过程的客户端或者应用程序就可以读取这个参数返回的值了。INOUT ：当前参数既可以为输入参数，也可以为输出参数。2、形参类型可以是 MySQL数据库中的任意类型。3、 characteristics 表示创建存储过程时指定的对存储过程的约束条件，其取值信息如下：LANGUAGE SQL| [NOT] DETERMINISTIC| { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }| SQL SECURITY { DEFINER | INVOKER }| COMMENT &#39;string&#39;LANGUAGE SQL ：说明存储过程执行体是由SQL语句组成的，当前系统支持的语言为SQL。` [NOT] DETERMINISTIC` ：指明存储过程执行的结果是否确定。DETERMINISTIC表示结果是确定 的。每次执行存储过程时，相同的输入会得到相同的输出。NOT DETERMINISTIC表示结果是不确定 的，相同的输入可能得到不同的输出。如果没有指定任意一个值，默认为NOT DETERMINISTIC。{ CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA } ：指明子程序使 用SQL语句的限制。 CONTAINS SQL表示当前存储过程的子程序包含SQL语句，但是并不包含读写数据的SQL语句； NO SQL表示当前存储过程的子程序中不包含任何SQL语句； READS SQL DATA表示当前存储过程的子程序中包含读数据的SQL语句； MODIFIES SQL DATA表示当前存储过程的子程序中包含写数据的SQL语句。 默认情况下，系统会指定为CONTAINS SQL。SQL SECURITY { DEFINER | INVOKER } ：执行当前存储过程的权限，即指明哪些用户能够执 行当前存储过程。 DEFINER 表示只有当前存储过程的创建者或者定义者才能执行当前存储过程； INVOKER 表示拥有当前存储过程的访问权限的用户能够执行当前存储过程。 如果没有设置相关的值，则MySQL默认指定值为DEFINER。COMMENT &#39;string&#39; ：注释信息，可以用来描述存储过程。4、存储过程体中可以有多条 SQL 语句，如果仅仅一条SQL 语句，则可以省略 BEGIN 和 END 编写存储过程并不是一件简单的事情，可能存储过程中需要复杂的 SQL 语句。1. BEGIN…END：BEGIN…END 中间包含了多个语句，每个语句都以（;）号为结束符。2. DECLARE：DECLARE 用来声明变量，使用的位置在于 BEGIN…END 语句中间，而且需要在其他语句使用之前进行变量的声明。3. SET：赋值语句，用于对变量进行赋值。4. SELECT… INTO：把从数据表中查询的结果存放到变量中，也就是为变量赋值。5、需要设置新的结束标记DELIMITER 新的结束标记​ 因为MySQL默认的语句结束符号为分号‘;’。为了避免与存储过程中SQL语句结束符相冲突，需要使用 DELIMITER改变存储过程的结束符。​ 比如：“DELIMITER //”语句的作用是将MySQL的结束符设置为//，并以“END //”结束存储过程。存储过程定 义完毕之后再使用“DELIMITER ;”恢复默认结束符。DELIMITER也可以指定其他符号作为结束符。​ 当使用DELIMITER命令时，应该避免使用反斜杠（‘\\’）字符，因为反斜线是MySQL的转义字符。DELIMITER $CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...)[characteristics ...]BEGINsql语句1;sql语句2;END $2.2 代码举例举例1：创建存储过程select_all_data()，查看 emps 表的所有数据DELIMITER $CREATE PROCEDURE select_all_data()BEGINSELECT * FROM emps;END $DELIMITER ;举例2：创建存储过程avg_employee_salary()，返回所有员工的平均工资DELIMITER //CREATE PROCEDURE avg_employee_salary ()BEGINSELECT AVG(salary) AS avg_salary FROM emps;END //DELIMITER ;举例3：创建存储过程show_max_salary()，用来查看“emps”表的最高薪资值。CREATE PROCEDURE show_max_salary()LANGUAGE SQLNOT DETERMINISTICCONTAINS SQLSQL SECURITY DEFINERCOMMENT &#39;查看最高薪资&#39;BEGINSELECT MAX(salary) FROM emps;END //DELIMITER ;举例4：创建存储过程show_min_salary()，查看“emps”表的最低薪资值。并将最低薪资通过OUT参数“ms” 输出DELIMITER //CREATE PROCEDURE show_min_salary(OUT ms DOUBLE)BEGINSELECT MIN(salary) INTO ms FROM emps;END //DELIMITER ;举例5：创建存储过程show_someone_salary()，查看“emps”表的某个员工的薪资，并用IN参数empname 输入员工姓名。DELIMITER //CREATE PROCEDURE show_someone_salary(IN empname VARCHAR(20))BEGINSELECT salary FROM emps WHERE ename = empname;END //DELIMITER ;举例6：创建存储过程show_someone_salary2()，查看“emps”表的某个员工的薪资，并用IN参数empname 输入员工姓名，用OUT参数empsalary输出员工薪资。DELIMITER //CREATE PROCEDURE show_someone_salary2(IN empname VARCHAR(20),OUT empsalary DOUBLE)BEGINSELECT salary INTO empsalary FROM emps WHERE ename = empname;END //DELIMITER ;举例7：创建存储过程show_mgr_name()，查询某个员工领导的姓名，并用INOUT参数“empname”输入员 工姓名，输出领导的姓名。DELIMITER //CREATE PROCEDURE show_mgr_name(INOUT empname VARCHAR(20))BEGINSELECT ename INTO empname FROM empsWHERE eid = (SELECT MID FROM emps WHERE ename=empname);END //DELIMITER ;3. 调用存储过程3.1 调用格式存储过程有多种调用方法。存储过程必须使用CALL语句调用，并且存储过程和数据库相关，如果要执行 其他数据库中的存储过程，需要指定数据库名称，例如CALL dbname.procname。CALL 存储过程名(实参列表)格式：1、调用in模式的参数：CALL sp1(&#39;值&#39;);2、调用out模式的参数：SET @name;CALL sp1(@name);SELECT @name;3、调用inout模式的参数：SET @name=值;CALL sp1(@name);SELECT @name;3.2 代码举例举例1：DELIMITER //CREATE PROCEDURE CountProc(IN sid INT,OUT num INT)BEGINSELECT COUNT(*) INTO num FROM fruitsWHERE s_id = sid;END //DELIMITER ;调用存储过程：mysql&amp;gt; CALL CountProc (101, @num);Query OK, 1 row affected (0.00 sec)查看返回结果：mysql&amp;gt; SELECT @num;该存储过程返回了指定 s_id=101 的水果商提供的水果种类，返回值存储在num变量中，使用SELECT查 看，返回结果为3。举例2：创建存储过程，实现累加运算，计算 1+2+…+n 等于多少。具体的代码如下：DELIMITER //CREATE PROCEDURE `add_num`(IN n INT)BEGINDECLARE i INT;DECLARE sum INT;SET i = 1;SET sum = 0;WHILE i &amp;lt;= n DOSET sum = sum + i;SET i = i +1;END WHILE;SELECT sum;END //DELIMITER ;​ 如果你用的是 Navicat 工具，那么在编写存储过程的时候，Navicat 会自动设置 DELIMITER 为其他符号， 我们不需要再进行 DELIMITER 的操作。​ 直接使用 CALL add_num(50); 即可。这里我传入的参数为 50，也就是统计 1+2+…+50 的积累之和。3.3 如何调试​ 在 MySQL 中，存储过程不像普通的编程语言（比如 VC++、Java 等）那样有专门的集成开发环境。因 此，你可以通过 SELECT 语句，把程序执行的中间结果查询出来，来调试一个 SQL 语句的正确性。调试 成功之后，把 SELECT 语句后移到下一个 SQL 语句之后，再调试下一个 SQL 语句。这样 逐步推进 ，就可 以完成对存储过程中所有操作的调试了。当然，你也可以把存储过程中的 SQL 语句复制出来，逐段单独 调试。4. 存储函数的使用​ 前面学习了很多函数，使用这些函数可以对数据进行的各种处理操作，极大地提高用户对数据库的管理 效率。MySQL支持自定义函数，定义好之后，调用方式与调用MySQL预定义的系统函数一样。4.1 语法分析学过的函数：LENGTH、SUBSTR、CONCAT等 语法格式：CREATE FUNCTION 函数名(参数名 参数类型,...)RETURNS 返回值类型[characteristics ...]BEGIN函数体 #函数体中肯定有 RETURN 语句END说明：1、参数列表：指定参数为IN、OUT或INOUT只对PROCEDURE是合法的，FUNCTION中总是默认为IN参 数。2、RETURNS type 语句表示函数返回数据的类型； RETURNS子句只能对FUNCTION做指定，对函数而言这是 强制 的。它用来指定函数的返回类型，而且函 数体必须包含一个 RETURN value 语句。3、characteristic 创建函数时指定的对函数的约束。取值与创建存储过程时相同，这里不再赘述。4、函数体也可以用BEGIN…END来表示SQL代码的开始和结束。如果函数体只有一条语句，也可以省略 BEGIN…END。4.2 调用存储函数​ 在MySQL中，存储函数的使用方法与MySQL内部函数的使用方法是一样的。换言之，用户自己定义的存 储函数与MySQL内部函数是一个性质的。区别在于，存储函数是 用户自己定义 的，而内部函数是MySQL 的 开发者定义 的。SELECT 函数名(实参列表)4.3 代码举例举例1：创建存储函数，名称为email_by_name()，参数定义为空，该函数查询Abel的email，并返回，数据类型为 字符串型。DELIMITER //CREATE FUNCTION email_by_name()RETURNS VARCHAR(25)DETERMINISTICCONTAINS SQLBEGINRETURN (SELECT email FROM employees WHERE last_name = &#39;Abel&#39;);END //DELIMITER ;调用：SELECT email_by_name();举例2： 创建存储函数，名称为email_by_id()，参数传入emp_id，该函数查询emp_id的email，并返回，数据类型 为字符串型。DELIMITER //CREATE FUNCTION email_by_id(emp_id INT)RETURNS VARCHAR(25)DETERMINISTICCONTAINS SQLBEGINRETURN (SELECT email FROM employees WHERE employee_id = emp_id);END //DELIMITER ;调用：SET @emp_id = 102;SELECT email_by_id(102);举例3：创建存储函数count_by_id()，参数传入dept_id，该函数查询dept_id部门的员工人数，并返回，数据类型 为整型。DELIMITER //CREATE FUNCTION count_by_id(dept_id INT)RETURNS INTLANGUAGE SQLNOT DETERMINISTICREADS SQL DATASQL SECURITY DEFINERCOMMENT &#39;查询部门平均工资&#39;BEGINRETURN (SELECT COUNT(*) FROM employees WHERE department_id = dept_id);END //DELIMITER ;调用：SET @dept_id = 50;SELECT count_by_id(@dept_id);注意：若在创建存储函数中报错“ you might want to use the less safe log_bin_trust_function_creators variable ”，有两种处理方法： 方式1：加上必要的函数特性“[NOT] DETERMINISTIC”和“{CONTAINS SQL NO SQL READS SQL DATA MODIFIES SQL DATA}” 方式2：方式1：加上必要的函数特性“[NOT] DETERMINISTIC”和“{CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA}” 方式2：4.4 对比存储函数和存储过程   关键字 调用语法 返回值 应用场景 存储过 程 PROCEDURE CALL 存储过 程() 理解为有0个或 多个 一般用于更新 存储函 数 FUNCTION SELECT 函数 () 只能是一个 一般用于查询结果为一个值并 返回时 此外，存储函数可以放在查询语句中使用，存储过程不行。反之，存储过程的功能更加强大，包括能够 执行对表的操作（比如创建表，删除表等）和事务操作，这些功能是存储函数不具备的。5. 存储过程和函数的查看、修改、删除5.1 查看创建完之后，怎么知道我们创建的存储过程、存储函数是否成功了呢？MySQL存储了存储过程和函数的状态信息，用户可以使用SHOW STATUS语句或SHOW CREATE语句来查 看，也可直接从系统的information_schema数据库中查询。这里介绍3种方法。1.使用SHOW CREATE语句查看存储过程和函数的创建信息基本语法结构如下：SHOW CREATE {PROCEDURE | FUNCTION} 存储过程名或函数名举例：SHOW CREATE FUNCTION test_db.CountProc \\G2.使用SHOW STATUS语句查看存储过程和函数的状态信息基本语法结构如下：SHOW {PROCEDURE | FUNCTION} STATUS [LIKE &#39;pattern&#39;]这个语句返回子程序的特征，如数据库、名字、类型、创建者及创建和修改日期。[LIKE ‘pattern’]：匹配存储过程或函数的名称，可以省略。当省略不写时，会列出MySQL数据库中存在的 所有存储过程或函数的信息。 举例：SHOW STATUS语句示例，代码如下：mysql&amp;gt; SHOW PROCEDURE STATUS LIKE &#39;SELECT%&#39; \\G*************************** 1. row ***************************Db: test_dbName: SelectAllDataType: PROCEDUREDefiner: root@localhostModified: 2021-10-16 15:55:07Created: 2021-10-16 15:55:07Security_type: DEFINERComment:character_set_client: utf8mb4collation_connection: utf8mb4_general_ciDatabase Collation: utf8mb4_general_ci1 row in set (0.00 sec)3.从information_schema.Routines表中查看存储过程和函数的信息​ MySQL中存储过程和函数的信息存储在information_schema数据库下的Routines表中。可以通过查询该表 的记录来查询存储过程和函数的信息。其基本语法形式如下：SELECT * FROM information_schema.Routines WHERE ROUTINE_NAME=&#39;存储过程或函数的名&#39; [AND ROUTINE_TYPE = {&#39;PROCEDURE|FUNCTION&#39;}];​ 说明：如果在MySQL数据库中存在存储过程和函数名称相同的情况，最好指定ROUTINE_TYPE查询条件来 指明查询的是存储过程还是函数。举例：从Routines表中查询名称为CountProc的存储函数的信息，代码如下:SELECT * FROM information_schema.Routines WHERE ROUTINE_NAME=&#39;count_by_id&#39; AND ROUTINE_TYPE = &#39;FUNCTION&#39; \\G5.2 修改修改存储过程或函数，不影响存储过程或函数功能，只是修改相关特性。使用ALTER语句实现。ALTER {PROCEDURE | FUNCTION} 存储过程或函数的名 [characteristic ...]其中，characteristic指定存储过程或函数的特性，其取值信息与创建存储过程、函数时的取值信息略有 不同。{ CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }| SQL SECURITY { DEFINER | INVOKER }| COMMENT &#39;string&#39; CONTAINS SQL ，表示子程序包含SQL语句，但不包含读或写数据的语句。 NO SQL ，表示子程序中不包含SQL语句。 READS SQL DATA ，表示子程序中包含读数据的语句。 MODIFIES SQL DATA ，表示子程序中包含写数据的语句。 SQL SECURITY { DEFINER INVOKER } ，指明谁有权限来执行。 DEFINER ，表示只有定义者自己才能够执行。 INVOKER ，表示调用者可以执行。 COMMENT ‘string’ ，表示注释信息。修改存储过程使用ALTER PROCEDURE语句，修改存储函数使用ALTER FUNCTION语句。但是，这两 个语句的结构是一样的，语句中的所有参数也是一样的。举例1： 修改存储过程CountProc的定义。将读写权限改为MODIFIES SQL DATA，并指明调用者可以执行，代码如 下：ALTER PROCEDURE CountProcMODIFIES SQL DATASQL SECURITY INVOKER ;查询修改后的信息：SELECT specific_name,sql_data_access,security_typeFROM information_schema.`ROUTINES`WHERE routine_name = &#39;CountProc&#39; AND routine_type = &#39;PROCEDURE&#39;;结果显示，存储过程修改成功。从查询的结果可以看出，访问数据的权限（SQL_DATA_ ACCESS）已经变 成MODIFIES SQL DATA，安全类型（SECURITY_TYPE）已经变成INVOKER。举例2： 修改存储函数CountProc的定义。将读写权限改为READS SQL DATA，并加上注释信息“FIND NAME”，代码 如下：ALTER FUNCTION CountProcREADS SQL DATACOMMENT &#39;FIND NAME&#39; ;存储函数修改成功。从查询的结果可以看出，访问数据的权限（SQL_DATA_ACCESS）已经变成READS SQL DATA，函数注释（ROUTINE_COMMENT）已经变成FIND NAME。5.3 删除删除存储过程和函数，可以使用DROP语句，其语法结构如下：DROP {PROCEDURE | FUNCTION} [IF EXISTS] 存储过程或函数的名IF EXISTS：如果程序或函数不存储，它可以防止发生错误，产生一个用SHOW WARNINGS查看的警告。 举例：DROP PROCEDURE CountProc;DROP FUNCTION CountProc;6. 关于存储过程使用的争议尽管存储过程有诸多优点，但是对于存储过程的使用，一直都存在着很多争议，比如有些公司对于大型 项目要求使用存储过程，而有些公司在手册中明确禁止使用存储过程，为什么这些公司对存储过程的使 用需求差别这么大呢？6.1 优点1、存储过程可以一次编译多次使用。存储过程只在创建时进行编译，之后的使用都不需要重新编译， 这就提升了 SQL 的执行效率。2、可以减少开发工作量。将代码 封装 成模块，实际上是编程的核心思想之一，这样可以把复杂的问题 拆解成不同的模块，然后模块之间可以 重复使用 ，在减少开发工作量的同时，还能保证代码的结构清 晰。3、存储过程的安全性强。我们在设定存储过程的时候可以 设置对用户的使用权限 ，这样就和视图一样具 有较强的安全性。4、可以减少网络传输量。因为代码封装到存储过程中，每次使用只需要调用存储过程即可，这样就减 少了网络传输量。5、良好的封装性。在进行相对复杂的数据库操作时，原本需要使用一条一条的 SQL 语句，可能要连接 多次数据库才能完成的操作，现在变成了一次存储过程，只需要 连接一次即可 。6.2 缺点基于上面这些优点，不少大公司都要求大型项目使用存储过程，比如微软、IBM 等公司。但是国内的阿 里并不推荐开发人员使用存储过程，这是为什么呢？阿里开发规范 【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。存储过程虽然有诸如上面的好处，但缺点也是很明显的。1、可移植性差。存储过程不能跨数据库移植，比如在 MySQL、Oracle 和 SQL Server 里编写的存储过 程，在换成其他数据库时都需要重新编写。2、调试困难。只有少数 DBMS 支持存储过程的调试。对于复杂的存储过程来说，开发和维护都不容 易。虽然也有一些第三方工具可以对存储过程进行调试，但要收费。3、存储过程的版本管理很困难。比如数据表索引发生变化了，可能会导致存储过程失效。我们在开发 软件的时候往往需要进行版本管理，但是存储过程本身没有版本控制，版本迭代更新的时候很麻烦。4、它不适合高并发的场景。高并发的场景需要减少数据库的压力，有时数据库会采用分库分表的方 式，而且对可扩展性要求很高，在这种情况下，存储过程会变得难以维护， 增加数据库的压力 ，显然就 不适用了。6.3 小结​ 存储过程既方便，又有局限性。尽管不同的公司对存储过程的态度不一，但是对于我们开发人员来说， 不论怎样，掌握存储过程都是必备的技能之一7.课后练习7.1存储过程练习0准备工作CREATE DATABASE test15;USE test15;1.创建存储过程insert_user()，实现传入用户名和密码，插入到admin表中CREATE TABLE admin( id INT PRIMARY KEY AUTO_INCREMENT, user_name VARCHAR(15) NOT NULL, pwd VARCHAR(25) NOT NULL);DELIMITER $CREATE PROCEDURE insert_user(IN user_name VARCHAR(15),IN pwd VARCHAR(25))BEGIN INSERT INTO admin(user_name,pwd) VALUES (user_name,pwd);END $DELIMITER ;2.存储过程get_phone，实现女神的编号，返回女神姓名和电话CREATE TABLE beauty( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(15) NOT NULL, phone VARCHAR(15) UNIQUE, birth DATE);INSERT INTO beauty(NAME,phone,birth)VALUES (&#39;朱茵&#39;,&#39;12354361443&#39;,&#39;1982-02-12&#39;), (&#39;孙燕姿&#39;,&#39;13541254135&#39;,&#39;1980-12-09&#39;), (&#39;邓紫棋&#39;,&#39;13625425458&#39;,&#39;1993-09-22&#39;), (&#39;田馥甄&#39;,&#39;12543655412&#39;,&#39;1983-08-21&#39;);DELIMITER $CREATE PROCEDURE get_phone(IN id INT, OUT NAME VARCHAR(15),OUT phone VARCHAR(15))BEGIN SELECT b.NAME,b.phone INTO NAME,phone FROM beauty b WHERE b.id = id;END $DELIMITER ;3.创建存储过程date_diff()，实现传入两个女神生日，返回日期间隔大小DELIMITER //CREATE PROCEDURE date_diff(IN birth1 DATE, IN birth2 DATE,OUT sum_date INT)BEGINSELECT DATEDIFF(birth1,birth2) INTO sum_date;END //DELIMITER ;调用SET @birth1 = &#39;1992-10-10&#39;;SET @birth2 = &#39;1993-10-20&#39;;CALL date_diff(@birth1,@birth2,@sum_date);SELECT @sum_date;+-----------+| @sum_date |+-----------+| -375 |+-----------+1 row in set4.创建存储过程format_date()，实现传入一个日期，格式化成xx年xx月xx日并返回DELIMITER //CREATE PROCEDURE format_date(IN my_date DATE,OUT str_date VARCHAR(25))BEGIN SELECT DATE_FORMAT(my_date,&#39;%y年%m月%d日&#39;) INTO str_date;END //DELIMITER ;调用CALL format_date(CURDATE(),@str);SELECT @str;+--------------+| @str |+--------------+| 22年05月28日 |+--------------+1 row in set5.创建存储过程beauty_limit()，根据传入的起始索引和条目数，查询女神表的记录DELIMITER //CREATE PROCEDURE beauty_limit(IN start_index INT,IN size INT)BEGIN SELECT * FROM beauty LIMIT start_index,size;END //DELIMITER ;调用CALL beauty_limit(1,3);+----+--------+-------------+------------+| id | NAME | phone | birth |+----+--------+-------------+------------+| 2 | 孙燕姿 | 13541254135 | 1980-12-09 || 3 | 邓紫棋 | 13625425458 | 1993-09-22 || 4 | 田馥甄 | 12543655412 | 1983-08-21 |+----+--------+-------------+------------+3 rows in setQuery OK, 0 rows affected6.创建带IN/OUT模式参数的存储过程。传入a和b两个值，最终a和b都双倍返回DELIMITER //CREATE PROCEDURE add_double (INOUT a INT,INOUT b INT)BEGIN SET a= a*2; SET b = b*2;END //DELIMITER ;调用SET @a=3,@b=5;CALL add_double(@a,@b);SELECT @a,@b;+----+----+| @a | @b |+----+----+| 6 | 10 |+----+----+1 row in set7.删除题目5中的存储过程DROP PROCEDURE IF EXISTS beauty_limit;8.查看题目6中存储过程的信息SHOW CREATE PROCEDURE add_double;SHOW PROCEDURE STATUS LIKE &quot;add_%&quot;;7.2存储函数练习1.创建函数get_count()，返回公司的员工个数DELIMITER $CREATE FUNCTION get_count()RETURNS INTBEGIN RETURN (SELECT COUNT(*) FROM employees);END $DELIMITER ;1418 - This function has none of DETERMINISTIC, NO SQL, or READS SQL DATA in its declaration and binary logging is enabled (you *might* want to use the less safe log_bin_trust_function_creators variable)需要设置SET GLOBAL log_bin_trust_function_creators = 1;调用SELECT get_count();+-------------+| get_count() |+-------------+| 107 |+-------------+1 row in set2.创建函数ename_salary()，根据员工姓名，返回它的工资DELIMITER $CREATE FUNCTION ename_salary(emp_name VARCHAR(15))RETURN DOUBLEBEGIN RETURN (SELECT salary FROM employees WHERE last_name = emp_name);END $DELIMITER ;调用SELECT ename_salary(&#39;Abel&#39;);3.创建函数dept_sal()，根据部门名，返回该部门的平均工资DELIMITER //CREATE FUNCTION dept_sal(dept_name VARCHAR(15))RETURNS DOUBLEBEGIN RETURN (SELECT AVG(salary) FROM employees e JOIN departments d ON e.department_id = d.department_id WHERE d.department_name = dept_name); END // DELIMITER ;调用SELECT * FROM departments;+---------------+----------------------+------------+-------------+| department_id | department_name | manager_id | location_id |+---------------+----------------------+------------+-------------+| 10 | Administration | 200 | 1700 || 20 | Marketing | 201 | 1800 || 30 | Purchasing | 114 | 1700 || 40 | Human Resources | 203 | 2400 || 50 | Shipping | 121 | 1500 || 60 | IT | 103 | 1400 || 70 | Public Relations | 204 | 2700 || 80 | Sales | 145 | 2500 || 90 | Executive | 100 | 1700 || 100 | Finance | 108 | 1700 || 110 | Accounting | 205 | 1700 || 120 | Treasury | NULL | 1700 || 130 | Corporate Tax | NULL | 1700 || 140 | Control And Credit | NULL | 1700 || 150 | Shareholder Services | NULL | 1700 || 160 | Benefits | NULL | 1700 || 170 | Manufacturing | NULL | 1700 || 180 | Construction | NULL | 1700 || 190 | Contracting | NULL | 1700 || 200 | Operations | NULL | 1700 || 210 | IT Support | NULL | 1700 || 220 | NOC | NULL | 1700 || 230 | IT Helpdesk | NULL | 1700 || 240 | Government Sales | NULL | 1700 || 250 | Retail Sales | NULL | 1700 || 260 | Recruiting | NULL | 1700 || 270 | Payroll | NULL | 1700 |+---------------+----------------------+------------+-------------+27 rows in setSELECT dept_sal(&#39;Marketing&#39;);+-----------------------+| dept_sal(&#39;Marketing&#39;) |+-----------------------+| 9500 |+-----------------------+1 row in set4.创建函数add_float()，实现传入两个float，返回二者之和DELIMITER //CREATE FUNCTION add_float(value1 FLOAT,value2 FLOAT)RETURNS FLOATBEGIN RETURN (SELECT value1 + value2);END // DELIMITER ;调用SET @V1 :=12.2;SET @V2 = 2.3;SELECT add_float(@v1,@v2);+--------------------+| add_float(@v1,@v2) |+--------------------+| 14.5 |+--------------------+1 row in set" }, { "title": "MySQL视图", "url": "/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E8%A7%86%E5%9B%BE/", "categories": "数据库", "tags": "MySQL", "date": "2021-06-14 00:00:00 +0800", "snippet": "1.常见的数据库对象 对象 描述 表(TABLE) 表是存储数据的逻辑单元，以行和列的形式存在，列就是字段，行就是记录 数据字典 就是系统表，存放数据库相关信息的表。系统表的数据通常由数据库系统维护， 程序员通常不应该修改，只可查看 约束 (CONSTRAINT) 执行数据校验的规则，用于保证数据完整性的规则 视图(VIEW) 一个或者多个数据表里的数据的逻辑显示，视图并不存储数据 索引(INDEX) 用于提高查询性能，相当于书的目录 存储过程 (PROCEDURE) 用于完成一次完整的业务处理，没有返回值，但可通过传出参数将多个值传给调 用环境 存储函数 (FUNCTION) 用于完成一次特定的计算，具有一个返回值 触发器 (TRIGGER) 相当于一个事件监听器，当数据库发生特定事件后，触发器被触发，完成相应的 处理 2. 视图概述2.1 为什么使用视图？​ 视图一方面可以帮我们使用表的一部分而不是所有的表，另一方面也可以针对不同的用户制定不同的查 询视图。比如，针对一个公司的销售人员，我们只想给他看部分数据，而某些特殊的数据，比如采购的 价格，则不会提供给他。再比如，人员薪酬是个敏感的字段，那么只给某个级别以上的人员开放，其他 人的查询视图中则不提供这个字段。 刚才讲的只是视图的一个使用场景，实际上视图还有很多作用。最后，我们总结视图的优点。2.2 视图的理解 视图是一种 虚拟表 ，本身是 不具有数据 的，占用很少的内存空间，它是 SQL 中的一个重要概念。 视图建立在已有表的基础上, 视图赖以建立的这些表称为基表。 视图的创建和删除只影响视图本身，不影响对应的基表。但是当对视图中的数据进行增加、删除和 修改操作时，数据表中的数据会相应地发生变化，反之亦然。 在数据库中，视图不会保存数据，数据真正保存在数据表中。当对视图中的数据进行增加、删 除和修改操作时，数据表中的数据会相应地发生变化；反之亦然。 视图，是向用户提供基表数据的另一种表现形式。通常情况下，小型项目的数据库可以不使用视 图，但是在大型项目中，以及数据表比较复杂的情况下，视图的价值就凸显出来了，它可以帮助我 们把经常查询的结果集放到虚拟表中，提升使用效率。理解和使用起来都非常方便。 3. 创建视图在 CREATE VIEW 语句中嵌入子查询CREATE [OR REPLACE][ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]VIEW 视图名称 [(字段列表)]AS 查询语句[WITH [CASCADED|LOCAL] CHECK OPTION]精简版CREATE VIEW 视图名称AS 查询语句3.1 创建单表视图举例：CREATE VIEW empvu80ASSELECT employee_id, last_name, salaryFROM employeesWHERE department_id = 80;查询视图：SELECT *FROM salvu80;CREATE VIEW emp_year_salary (ename,year_salary)ASSELECT ename,salary*12*(1+IFNULL(commission_pct,0))FROM t_employee;举例CREATE VIEW salvu50ASSELECT employee_id ID_NUMBER, last_name NAME,salary*12 ANN_SALARYFROM employeesWHERE department_id = 50;说明1：实际上就是我们在 SQL 查询语句的基础上封装了视图 VIEW，这样就会基于 SQL 语句的结果集形 成一张虚拟表。说明2：在创建视图时，没有在视图名后面指定字段列表，则视图中字段列表默认和SELECT语句中的字 段列表一致。如果SELECT语句中给字段取了别名，那么视图中的字段名和别名相同。3.2 创建多表联合视图举例：CREATE VIEW empviewASSELECT employee_id emp_id,last_name NAME,department_nameFROM employees e,departments dWHERE e.department_id = d.department_id;CREATE VIEW emp_deptASSELECT ename,dnameFROM t_employee LEFT JOIN t_departmentON t_employee.did = t_department.did;CREATE VIEW dept_sum_vu(name, minsal, maxsal, avgsal)ASSELECT d.department_name, MIN(e.salary), MAX(e.salary),AVG(e.salary)FROM employees e, departments dWHERE e.department_id = d.department_idGROUP BY d.department_name;利用视图对数据进行格式化我们经常需要输出某个格式的内容，比如我们想输出员工姓名和对应的部门名，对应格式为 emp_name(department_name)，就可以使用视图来完成数据格式化的操作：CREATE VIEW emp_departASSELECT CONCAT(last_name,&#39;(&#39;,department_name,&#39;)&#39;) AS emp_deptFROM employees e JOIN departments dWHERE e.department_id = d.department_id当我们创建好一张视图之后，还可以在它的基础上继续创建视图。举例：联合“emp_dept”视图和“emp_year_salary”视图查询员工姓名、部门名称、年薪信息创建 “emp_dept_ysalary”视图。CREATE VIEW emp_dept_ysalaryASSELECT emp_dept.ename,dname,year_salaryFROM emp_dept INNER JOIN emp_year_salaryON emp_dept.ename = emp_year_salary.ename;4. 查看视图语法1：查看数据库的表对象、视图对象SHOW TABLES;语法2：查看视图的结构DESC / DESCRIBE 视图名称;语法3：查看视图的属性信息# 查看视图信息（显示数据表的存储引擎、版本、数据行数和数据大小等）SHOW TABLE STATUS LIKE &#39;视图名称&#39;\\G执行结果显示，注释Comment为VIEW，说明该表为视图，其他的信息为NULL，说明这是一个虚表。语法4：查看视图的详细定义信息SHOW CREATE VIEW 视图名称;5. 更新视图的数据5.1 一般情况​ MySQL支持使用INSERT、UPDATE和DELETE语句对视图中的数据进行插入、更新和删除操作。当视图中的 数据发生变化时，数据表中的数据也会发生变化，反之亦然。举例：UPDATE操作mysql&amp;gt; SELECT ename,tel FROM emp_tel WHERE ename = &#39;孙洪亮&#39;;+---------+-------------+| ename | tel |+---------+-------------+| 孙洪亮 | 13789098765 |+---------+-------------+1 row in set (0.01 sec)mysql&amp;gt; UPDATE emp_tel SET tel = &#39;13789091234&#39; WHERE ename = &#39;孙洪亮&#39;;Query OK, 1 row affected (0.01 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&amp;gt; SELECT ename,tel FROM t_employee WHERE ename = &#39;孙洪亮&#39;;+---------+-------------+| ename | tel |+---------+-------------+| 孙洪亮 | 13789091234 |+---------+-------------+1 row in set (0.00 sec)举例：DELETE操作mysql&amp;gt; SELECT ename,tel FROM emp_tel WHERE ename = &#39;孙洪亮&#39;;+---------+-------------+| ename | tel |+---------+-------------+| 孙洪亮 | 13789091234 |+---------+-------------+1 row in set (0.00 sec)mysql&amp;gt; DELETE FROM emp_tel WHERE ename = &#39;孙洪亮&#39;;Query OK, 1 row affected (0.01 sec)mysql&amp;gt; SELECT ename,tel FROM emp_tel WHERE ename = &#39;孙洪亮&#39;;Empty set (0.00 sec)mysql&amp;gt; SELECT ename,tel FROM t_employee WHERE ename = &#39;孙洪亮&#39;;Empty set (0.00 sec)5.2 不可更新的视图​ 要使视图可更新，视图中的行和底层基本表中的行之间必须存在 一对一 的关系。另外当视图定义出现如 下情况时，视图不支持更新操作： 在定义视图的时候指定了“ALGORITHM = TEMPTABLE”，视图将不支持INSERT和DELETE操作； 视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持INSERT操作； 在定义视图的SELECT语句中使用了 JOIN联合查询 ，视图将不支持INSERT和DELETE操作； 在定义视图的SELECT语句后的字段列表中使用了 数学表达式 或 子查询 ，视图将不支持INSERT，也 不支持UPDATE使用了数学表达式、子查询的字段值； 在定义视图的SELECT语句后的字段列表中使用 DISTINCT 、 聚合函数 、 GROUP BY 、 HAVING 、 UNION 等，视图将不支持INSERT、UPDATE、DELETE； 在定义视图的SELECT语句中包含了子查询，而子查询中引用了FROM后面的表，视图将不支持 INSERT、UPDATE、DELETE； 视图定义基于一个 不可更新视图 ； 常量视图。mysql&amp;gt; CREATE OR REPLACE VIEW emp_dept-&amp;gt; (ename,salary,birthday,tel,email,hiredate,dname)-&amp;gt; AS SELECT ename,salary,birthday,tel,email,hiredate,dname-&amp;gt; FROM t_employee INNER JOIN t_department-&amp;gt; ON t_employee.did = t_department.did ;Query OK, 0 rows affected (0.01 sec)mysql&amp;gt; INSERT INTO emp_dept(ename,salary,birthday,tel,email,hiredate,dname)-&amp;gt; VALUES(&#39;张三&#39;,15000,&#39;1995-01-08&#39;,&#39;18201587896&#39;,-&amp;gt; &#39;zs@atguigu.com&#39;,&#39;2022-02-14&#39;,&#39;新部门&#39;);#ERROR 1393 (HY000): Can not modify more than one base table through a join view&#39;atguigu_chapter9.emp_dept&#39;从上面的SQL执行结果可以看出，在定义视图的SELECT语句中使用了JOIN联合查询，视图将不支持更新 操作。虽然可以更新视图数据，但总的来说，视图作为 虚拟表 ，主要用于 方便查询 ，不建议更新视图的 数据。对视图数据的更改，都是通过对实际数据表里数据的操作来完成的。6. 修改、删除视图6.1 修改视图方式1：使用CREATE OR REPLACE VIEW 子句修改视图CREATE OR REPLACE VIEW empvu80(id_number, name, sal, department_id)ASSELECT employee_id, first_name || &#39; &#39; || last_name, salary, department_idFROM employeesWHERE department_id = 80;说明：CREATE VIEW 子句中各列的别名应和子查询中各列相对应。方式2：ALTER VIEW修改视图的语法是：ALTER VIEW 视图名称 AS 查询语句6.2 删除视图删除视图只是删除视图的定义，并不会删除基表的数据。删除视图的语法是：DROP VIEW IF EXISTS 视图名称DROP VIEW IF EXISTS 视图名称1,视图名称2,视图名称3,...;举例：DROP VIEW empvu80说明：基于视图a、b创建了新的视图c，如果将视图a或者视图b删除，会导致视图c的查询失败。这 样的视图c需要手动删除或修改，否则影响使用。7. 总结7.1 视图优点1.操作简单 将经常使用的查询操作定义为视图，可以使开发人员不需要关心视图对应的数据表的结构、表与表之间 的关联关系，也不需要关心数据表之间的业务逻辑和查询条件，而只需要简单地操作视图即可，极大简 化了开发人员对数据库的操作。2.减少数据冗余​ 视图跟实际数据表不一样，它存储的是查询语句。所以，在使用的时候，我们要通过定义视图的查询语 句来获取结果集。而视图本身不存储数据，不占用数据存储的资源，减少了数据冗余。3.数据安全​ MySQL将用户对数据的 访问限制 在某些数据的结果集上，而这些数据的结果集可以使用视图来实现。用 户不必直接查询或操作数据表。这也可以理解为视图具有 隔离性 。视图相当于在用户和实际的数据表之 间加了一层虚拟表。同时，MySQL可以根据权限将用户对数据的访问限制在某些视图上，用户不需要查询数据表，可以直接 通过视图获取数据表中的信息。这在一定程度上保障了数据表中数据的安全性。4.适应灵活多变的需求​ 当业务系统的需求发生变化后，如果需要改动数据表的结构，则工作量相对较 大，可以使用视图来减少改动的工作量。这种方式在实际工作中使用得比较多。5.能够分解复杂的查询逻辑​ 数据库中如果存在复杂的查询逻辑，则可以将问题进行分解，创建多个视图 获取数据，再将创建的多个视图结合起来，完成复杂的查询逻辑。7.2 视图不足​ 如果我们在实际数据表的基础上创建了视图，那么，如果实际数据表的结构变更了，我们就需要及时对相关的视图进行相应的维护。特别是嵌套的视图（就是在视图的基础上创建视图），维护会变得比较复 杂， 可读性不好 ，容易变成系统的潜在隐患。因为创建视图的 SQL 查询可能会对字段重命名，也可能包 含复杂的逻辑，这些都会增加维护的成本。​ 实际项目中，如果视图过多，会导致数据库维护成本的问题。 所以，在创建视图的时候，你要结合实际项目需求，综合考虑视图的优点和不足，这样才能正确使用视 图，使系统整体达到最优8.课后练习8.1 练习一1.使用表emps创建视图employee_vu，其中包括姓名（last_name、employee_id、dept_id)CREATE OR REPLACE VIEW employee_vu( lname,emp_id,dept_id)AS SELECT last_name,employee_id,department_idFROM emps;2.显示视图的结构DESC employee_vu;3.查询视图中的全部内容SELECT * FROM employee_vu;4.将视图中的数据限定在部门号为80的部门CREATE OR REPLACE VIEW employee_vu(lname,emp_id,dept_id)AS SELECT last_name,employee_id,department_idFROM empsWHERE department_id =80;8.2 练习21.创建视图emp_v1，要求查询电话号码以011开头的员工姓名和工资、邮箱CREATE OR REPLACE VIEW emp_v1ASSELECT last_name,salary,emailFROM empsWHERE phone_number LIKE &quot;011%&quot;;2.创建视图emp_v1要求查询电话号码以011开头的并且邮箱中包含e的字符CREATE OR REPLACE VIEW emp_v1AS SELECT last_name,email,phone_number,salaryFROM empsWHERE phone_number LIKE &quot;011%&quot;AND email LIKE &quot;%e%&quot;;SELECT * FROM emp_v1;3.向emps中插入一天记录，是否可行?DESC emps;INSERT INTO emp_v1VALUES(&#39;Tom&#39;,&#39;tom@126.com&#39;,&#39;01022523&#39;);# 结果错误，插入失败4.修改emp_v1中的员工工资，没人涨薪1000UPDATE emp_v1SET salary = salary + 1000;5.删除emp_v1中姓名为Olsen的员工DELETE FROM emp_v1WHERE last_name = &quot;Olsen&quot;;6.创建视图emp_v2，要求查询部门的最高工资高于12000的部门id和其最高工资CREATE OR REPLACE VIEW emp_v2(dept_id,max_sal)AS SELECT department_id,MAX(salary)FROM empsGROUP BY department_idHAVING MAX(salary)&amp;gt;12000;7.向emp_v2中插入一天记录，是否可以？INSERT INTO emp_v2(dept_id,max_sal)VALUES (4000,2000)# 这个操作有错误，是不可以的8.删除刚才的emp_v2和emp_v1DROP VIEW IF EXISTS emp_v1,emp_v2;" }, { "title": "MySQL约束", "url": "/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E7%BA%A6%E6%9D%9F/", "categories": "数据库", "tags": "MySQL", "date": "2021-06-13 00:00:00 +0800", "snippet": "1. 约束(constraint)概述1.1 为什么需要约束 数据完整性（Data Integrity）是指数据的精确性（Accuracy）和可靠性（Reliability）。它是防止数据库中 存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的。 为了保证数据的完整性，SQL规范以约束的方式对表数据进行额外的条件限制。从以下四个方面考虑： 实体完整性（Entity Integrity） ：例如，同一个表中，不能存在两条完全相同无法区分的记录 域完整性（Domain Integrity） ：例如：年龄范围0-120，性别范围“男/女” 引用完整性（Referential Integrity） ：例如：员工所在部门，在部门表中要能找到这个部门 用户自定义完整性（User-defined Integrity） ：例如：用户名唯一、密码不能为空等，本部门 经理的工资不得高于本部门职工的平均工资的5倍。1.2 什么是约束​ 约束是表级的强制规定。​ 可以在创建表时规定约束（通过 CREATE TABLE 语句），或者在表创建之后通过 ALTER TABLE 语句规定 约束。1.3 约束的分类根据约束数据列的限制，约束可分为： 单列约束：每个约束只约束一列 多列约束：每个约束可约束多列数据根据约束的作用范围，约束可分为： 列级约束：只能作用在一个列上，跟在列的定义后面 表级约束：可以作用在多个列上，不与列一起，而是单独定义   位置 支持的约束类型 是否可以起约束名 列级约束 列的后面 语法都支持，但外键没有效果 不可以 表级约束 所有列的下面 默认和非空不支持，其他支持 可以（主键没有效果） 根据约束起的作用，约束可分为： NOT NULL 非空约束，规定某个字段不能为空 UNIQUE 唯一约束，规定某个字段在整个表中是唯一的 PRIMARY KEY 主键(非空且唯一)约束 FOREIGN KEY 外键约束 CHECK 检查约束 DEFAULT 默认值约束 注意： MySQL不支持check约束，但可以使用check约束，而没有任何效果 查看某个表已有的约束#information_schema数据库名（系统库）#table_constraints表名称（专门存储各个表的约束）SELECT * FROM information_schema.table_constraintsWHERE table_name = &#39;表名称&#39;;2. 非空约束2.1 作用​ 限定某个字段/某列的值不允许为空2.2 关键字NOT NULL2.3 特点 默认，所有的类型的值都可以是NULL，包括INT、FLOAT等数据类型 非空约束只能出现在表对象的列上，只能某个列单独限定非空，不能组合非空 一个表可以有很多列都分别限定了非空 空字符串不等于NULL，0也不等于NULL2.4 添加非空约束（1）建表时CREATE TABLE 表名称( 字段名 数据类型, 字段名 数据类型 NOT NULL, 字段名 数据类型 NOT NULL);举例：CREATE TABLE emp( id INT(10) NOT NULL, NAME VARCHAR(20) NOT NULL, sex CHAR NULL);CREATE TABLE student( sid int, sname varchar(20) not null, tel char(11) , cardid char(18) not null);insert into student values(1,&#39;张三&#39;,&#39;13710011002&#39;,&#39;110222198912032545&#39;); #成功insert into student values(2,&#39;李四&#39;,&#39;13710011002&#39;,null);#身份证号为空ERROR 1048 (23000): Column &#39;cardid&#39; cannot be nullinsert into student values(2,&#39;李四&#39;,null,&#39;110222198912032546&#39;);#成功，tel允许为空insert into student values(3,null,null,&#39;110222198912032547&#39;);#失败ERROR 1048 (23000): Column &#39;sname&#39; cannot be null（2）建表后alter table 表名称 modify 字段名 数据类型 not null;举例：ALTER TABLE empMODIFY sex VARCHAR(30) NOT NULL;alter table student modify sname varchar(20) not null;2.5 删除非空约束alter table 表名称 modify 字段名 数据类型 NULL; #去掉not null，相当于修改某个非注解字段，该字段允许为空或alter table 表名称 modify 字段名 数据类型; #去掉not null，相当于修改某个非注解字段，该字段允许为空举例：ALTER TABLE empMODIFY sex VARCHAR(30) NULL;ALTER TABLE empMODIFY NAME VARCHAR(15) DEFAULT &#39;abc&#39; NULL;3. 唯一性约束3.1 作用 用来限制某个字段/某列的值不能重复。3.2 关键字UNIQUE3.3 特点 同一个表可以有多个唯一约束。 唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一。 唯一性约束允许列值为空。 在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。 MySQL会给唯一约束的列上默认创建一个唯一索引。3.4 添加唯一约束（1）建表时create table 表名称( 字段名 数据类型, 字段名 数据类型 unique, 字段名 数据类型 unique key, 字段名 数据类型);create table 表名称( 字段名 数据类型, 字段名 数据类型, 字段名 数据类型, [constraint 约束名] unique key(字段名));举例：create table student( sid int, sname varchar(20), tel char(11) unique, cardid char(18) unique key);CREATE TABLE t_course( cid INT UNIQUE, cname VARCHAR(100) UNIQUE, description VARCHAR(200));CREATE TABLE USER( id INT NOT NULL, NAME VARCHAR(25), PASSWORD VARCHAR(16), -- 使用表级约束语法 CONSTRAINT uk_name_pwd UNIQUE(NAME,PASSWORD));表示用户名和密码组合不能重复insert into student values(1,&#39;张三&#39;,&#39;13710011002&#39;,&#39;101223199012015623&#39;);insert into student values(2,&#39;李四&#39;,&#39;13710011003&#39;,&#39;101223199012015624&#39;);mysql&amp;gt; select * from student;+-----+-------+-------------+--------------------+| sid | sname | tel | cardid |+-----+-------+-------------+--------------------+| 1 | 张三 | 13710011002 | 101223199012015623 || 2 | 李四 | 13710011003 | 101223199012015624 |+-----+-------+-------------+--------------------+2 rows in set (0.00 sec)insert into student values(3,&#39;王五&#39;,&#39;13710011004&#39;,&#39;101223199012015624&#39;); #身份证号重复ERROR 1062 (23000): Duplicate entry &#39;101223199012015624&#39; for key &#39;cardid&#39;insert into student values(3,&#39;王五&#39;,&#39;13710011003&#39;,&#39;101223199012015625&#39;);ERROR 1062 (23000): Duplicate entry &#39;13710011003&#39; for key &#39;tel&#39;（2）建表后指定唯一键约束# 字段列表中如果是一个字段，表示该列的值唯一。如果是两个或更多个字段，那么复合唯一，即多个字段的组合是唯一的# 方式1：alter table 表名称 add unique key(字段列表);#方式2：alter table 表名称 modify 字段名 字段类型 unique;举例：ALTER TABLE USERADD CONSTRAINT uk_name_pwd UNIQUE(NAME,PASSWORD);ALTER TABLE USERMODIFY NAME VARCHAR(20) UNIQUE;create table student( sid int primary key, sname varchar(20), tel char(11) , cardid char(18));alter table student add unique key(tel);alter table student add unique key(cardid);3.5 关于复合唯一约束create table 表名称( 字段名 数据类型, 字段名 数据类型, 字段名 数据类型, unique key(字段列表) #字段列表中写的是多个字段名，多个字段名用逗号分隔，表示那么是复合唯一，即多 个字段的组合是唯一的);#学生表create table student( sid int, #学号 sname varchar(20), #姓名 tel char(11) unique key, #电话 cardid char(18) unique key #身份证号);#课程表create table course( cid int, #课程编号 cname varchar(20) #课程名称);#选课表create table student_course( id int, sid int, cid int, score int, unique key(sid,cid) #复合唯一);insert into student values(1,&#39;张三&#39;,&#39;13710011002&#39;,&#39;101223199012015623&#39;);#成功insert into student values(2,&#39;李四&#39;,&#39;13710011003&#39;,&#39;101223199012015624&#39;);#成功insert into course values(1001,&#39;Java&#39;),(1002,&#39;MySQL&#39;);#成功mysql&amp;gt; select * from student;+-----+-------+-------------+--------------------+| sid | sname | tel | cardid |+-----+-------+-------------+--------------------+| 1 | 张三 | 13710011002 | 101223199012015623 || 2 | 李四 | 13710011003 | 101223199012015624 |+-----+-------+-------------+--------------------+2 rows in set (0.00 sec)mysql&amp;gt; select * from course;+------+-------+| cid | cname |+------+-------+| 1001 | Java || 1002 | MySQL |+------+-------+2 rows in set (0.00 sec)insert into student_course values(1, 1, 1001, 89),(2, 1, 1002, 90),(3, 2, 1001, 88),(4, 2, 1002, 56);#成功mysql&amp;gt; select * from student_course;+----+------+------+-------+| id | sid | cid | score |+----+------+------+-------+| 1 | 1 | 1001 | 89 || 2 | 1 | 1002 | 90 || 3 | 2 | 1001 | 88 || 4 | 2 | 1002 | 56 |+----+------+------+-------+4 rows in set (0.00 sec)insert into student_course values (5, 1, 1001, 88);#失败#ERROR 1062 (23000): Duplicate entry &#39;1-1001&#39; for key &#39;sid&#39; 违反sid-cid的复合唯一3.6 删除唯一约束 添加唯一性约束的列上也会自动创建唯一索引。 删除唯一约束只能通过删除唯一索引的方式删除。 删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样。 如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；如果是组合列，那么默认和() 中排在第一个的列名相同。也可以自定义唯一性约束名。#查看都有哪些约束SELECT * FROM information_schema.table_constraints WHERE table_name = &#39;表名&#39;;ALTER TABLE USERDROP INDEX uk_name_pwd;注意：可以通过 show index from 表名称; 查看表的索引4. PRIMARY KEY 约束4.1 作用用来唯一标识表中的一行记录。4.2 关键字primary key4.3 特点主键约束相当于唯一约束+非空约束的组合，主键约束列不允许重复，也不允许出现空值。 一个表最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建。 主键约束对应着表中的一列或者多列（复合主键） 如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。 MySQL的主键名总是PRIMARY，就算自己命名了主键约束名也没用。 当创建主键约束时，系统默认会在所在的列或列组合上建立对应的主键索引（能够根据主键查询 的，就根据主键查询，效率更高）。如果删除主键约束了，主键约束对应的索引就自动删除了。 需要注意的一点是，不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的 值，就有可能会破坏数据的完整性。4.4 添加主键约束（1）建表时指定主键约束create table 表名称( 字段名 数据类型 primary key, #列级模式 字段名 数据类型, 字段名 数据类型);create table 表名称( 字段名 数据类型, 字段名 数据类型, 字段名 数据类型, [constraint 约束名] primary key(字段名) #表级模式);举例：create table temp( id int primary key, name varchar(20));mysql&amp;gt; desc temp;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(20) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+2 rows in set (0.00 sec)insert into temp values(1,&#39;张三&#39;);#成功insert into temp values(2,&#39;李四&#39;);#成功mysql&amp;gt; select * from temp;+----+------+| id | name |+----+------+| 1 | 张三 || 2 | 李四 |+----+------+2 rows in set (0.00 sec)insert into temp values(1,&#39;张三&#39;);#失败ERROR 1062 (23000): Duplicate（重复） entry（键入，输入） &#39;1&#39; for key &#39;PRIMARY&#39;insert into temp values(1,&#39;王五&#39;);#失败ERROR 1062 (23000): Duplicate entry &#39;1&#39; for key &#39;PRIMARY&#39;insert into temp values(3,&#39;张三&#39;);#成功mysql&amp;gt; select * from temp;+----+------+| id | name |+----+------+| 1 | 张三 || 2 | 李四 || 3 | 张三 |+----+------+3 rows in set (0.00 sec)insert into temp values(4,null);#成功insert into temp values(null,&#39;李琦&#39;);#失败ERROR 1048 (23000): Column &#39;id&#39; cannot be nullmysql&amp;gt; select * from temp;+----+------+| id | name |+----+------+| 1 | 张三 || 2 | 李四 || 3 | 张三 || 4 | NULL |+----+------+4 rows in set (0.00 sec)#演示一个表建立两个主键约束create table temp( id int primary key, name varchar(20) primary key);ERROR 1068 (42000): Multiple（多重的） primary key defined（定义）再举例：列级约束CREATE TABLE emp4( id INT PRIMARY KEY AUTO_INCREMENT , NAME VARCHAR(20));表级约束CREATE TABLE emp5( id INT NOT NULL AUTO_INCREMENT, NAME VARCHAR(20), pwd VARCHAR(15), CONSTRAINT emp5_id_pk PRIMARY KEY(id));（2）建表后增加主键约束ALTER TABLE 表名称 ADD PRIMARY KEY(字段列表); #字段列表可以是一个字段，也可以是多个字段，如果是多个字段的话，是复合主键ALTER TABLE student ADD PRIMARY KEY (sid);ALTER TABLE emp5 ADD PRIMARY KEY(NAME,pwd)4.5 关于复合主键create table 表名称( 字段名 数据类型, 字段名 数据类型, 字段名 数据类型, primary key(字段名1,字段名2) #表示字段1和字段2的组合是唯一的，也可以有更多个字段);#学生表create table student( sid int primary key, #学号 sname varchar(20) #学生姓名);#课程表create table course( cid int primary key, #课程编号 cname varchar(20) #课程名称);#选课表create table student_course( sid int, cid int, score int, primary key(sid,cid) #复合主键);insert into student values(1,&#39;张三&#39;),(2,&#39;李四&#39;);insert into course values(1001,&#39;Java&#39;),(1002,&#39;MySQL&#39;);mysql&amp;gt; select * from student;+-----+-------+| sid | sname |+-----+-------+| 1 | 张三 || 2 | 李四 |+-----+-------+2 rows in set (0.00 sec)mysql&amp;gt; select * from course;+------+-------+| cid | cname |+------+-------+| 1001 | Java || 1002 | MySQL |+------+-------+2 rows in set (0.00 sec)insert into student_course values(1, 1001, 89),(1,1002,90),(2,1001,88),(2,1002,56);mysql&amp;gt; select * from student_course;+-----+------+-------+| sid | cid | score |+-----+------+-------+| 1 | 1001 | 89 || 1 | 1002 | 90 | | 2 | 1001 | 88 || 2 | 1002 | 56 |+-----+------+-------+4 rows in set (0.00 sec)insert into student_course values(1, 1001, 100);ERROR 1062 (23000): Duplicate entry &#39;1-1001&#39; for key &#39;PRIMARY&#39;mysql&amp;gt; desc student_course;+-------+---------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| sid | int(11) | NO | PRI | NULL | || cid | int(11) | NO | PRI | NULL | || score | int(11) | YES | | NULL | |+-------+---------+------+-----+---------+-------+3 rows in set (0.00 sec)再举例CREATE TABLE emp6( id INT NOT NULL, NAME VARCHAR(20), pwd VARCHAR(15), CONSTRAINT emp7_pk PRIMARY KEY(NAME,pwd));4.6 删除主键约束alter table 表名称 drop primary key;举例ALTER TABLE student DROP PRIMARY KEY;ALTER TABLE emp5 DROP PRIMARY KEY;说明：删除主键约束，不需要指定主键名，因为一个表只有一个主键，删除主键约束后，非空还存在。5. 自增列：AUTO_INCREMENT5.1 作用某个字段的值自增5.2 关键字auto_increment5.3 特点和要求（1）一个表最多只能有一个自增长列（2）当需要产生唯一标识符或顺序值时，可设置自增长（3）自增长列约束的列必须是键列（主键列，唯一键列）（4）自增约束的列的数据类型必须是整数类型（5）如果自增列指定了 0 和 null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接 赋值为具体值。错误演示：create table employee( eid int auto_increment, ename varchar(20));# ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a keycreate table employee( eid int primary key, ename varchar(20) unique key auto_increment);# ERROR 1063 (42000): Incorrect column specifier for column &#39;ename&#39; 因为ename不是整数类型5.4 如何指定自增约束（1）建表时create table 表名称( 字段名 数据类型 primary key auto_increment, 字段名 数据类型 unique key not null, 字段名 数据类型 unique key, 字段名 数据类型 not null default 默认值,);create table 表名称( 字段名 数据类型 default 默认值 , 字段名 数据类型 unique key auto_increment, 字段名 数据类型 not null default 默认值,, primary key(字段名));create table employee( eid int primary key auto_increment, ename varchar(20));mysql&amp;gt; desc employee;+-------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+----------------+| eid | int(11) | NO | PRI | NULL | auto_increment || ename | varchar(20) | YES | | NULL | |+-------+-------------+------+-----+---------+----------------+2 rows in set (0.00 sec)（2）建表后alter table 表名称 modify 字段名 数据类型 auto_increment;例如：create table employee( eid int primary key , ename varchar(20));alter table employee modify eid int auto_increment;mysql&amp;gt; desc employee;+-------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+----------------+| eid | int(11) | NO | PRI | NULL | auto_increment || ename | varchar(20) | YES | | NULL | |+-------+-------------+------+-----+---------+----------------+2 rows in set (0.00 sec)5.5 如何删除自增约束#alter table 表名称 modify 字段名 数据类型 auto_increment;#给这个字段增加自增约束alter table 表名称 modify 字段名 数据类型; #去掉auto_increment相当于删除alter table employee modify eid int;mysql&amp;gt; desc employee;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| eid | int(11) | NO | PRI | NULL | || ename | varchar(20) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+2 rows in set (0.00 sec)5.6 MySQL 8.0新特性—自增变量的持久化​ 在MySQL 8.0之前，自增主键AUTO_INCREMENT的值如果大于max(primary key)+1，在MySQL重启后，会重置AUTO_INCREMENT=max(primary key)+1，这种现象在某些情况下会导致业务主键冲突或者其他难以发 现的问题。 下面通过案例来对比不同的版本中自增变量是否持久化。 在MySQL 5.7版本中，测试步骤如下： 创建的数据表中包含自增主键的id字段，语句如下：CREATE TABLE test1( id INT PRIMARY KEY AUTO_INCREMENT);插入4个空值，执行如下：INSERT INTO test1VALUES(0),(0),(0),(0);查询数据表test1中的数据，结果如下： mysql&amp;gt; SELECT * FROM test1; +----+ | id | +----+ | 1 | | 2 | | 3 | | 4 | +----+ 4 rows in set (0.00 sec)删除id为4的记录，语句如下：DELETE FROM test1 WHERE id = 4;再次插入一个空值，语句如下：INSERT INTO test1 VALUES(0);查询此时数据表test1中的数据，结果如下：mysql&amp;gt; SELECT * FROM test1;+----+| id |+----+| 1 || 2 || 3 || 5 |+----+4 rows in set (0.00 sec)从结果可以看出，虽然删除了id为4的记录，但是再次插入空值时，并没有重用被删除的4，而是分配了 5。 删除id为5的记录，结果如下：DELETE FROM test1 where id=5;重启数据库，重新插入一个空值。INSERT INTO test1 values(0);再次查询数据表test1中的数据，结果如下：mysql&amp;gt; SELECT * FROM test1;+----+| id |+----+| 1 || 2 || 3 || 4 |+----+4 rows in set (0.00 sec)​ 从结果可以看出，新插入的0值分配的是4，按照重启前的操作逻辑，此处应该分配6。出现上述结果的主 要原因是自增主键没有持久化。 在MySQL 5.7系统中，对于自增主键的分配规则，是由InnoDB数据字典 内部一个 计数器 来决定的，而该计数器只在 内存中维护 ，并不会持久化到磁盘中。当数据库重启时，该 计数器会被初始化。在MySQL 8.0版本中，上述测试步骤最后一步的结果如下： mysql&amp;gt; SELECT * FROM test1; +----+ | id | +----+ | 1 | | 2 | | 3 | | 6 | +----+ 4 rows in set (0.00 sec)​ 从结果可以看出，自增变量已经持久化了。​ MySQL 8.0将自增主键的计数器持久化到 重做日志 中。每次计数器发生改变，都会将其写入重做日志 中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值。6. FOREIGN KEY 约束6.1 作用限定某个表的某个字段的引用完整性。比如：员工表的员工所在部门的选择，必须在部门表能找到对应的部分。6.2 关键字FOREIGN KEY6.3 主表和从表/父表和子表主表（父表）：被引用的表，被参考的表从表（子表）：引用别人的表，参考别人的表例如：员工表的员工所在部门这个字段的值要参考部门表：部门表是主表，员工表是从表。例如：学生表、课程表、选课表：选课表的学生和课程要分别参考学生表和课程表，学生表和课程表是 主表，选课表是从表。6.4 特点（1）从表的外键列，必须引用/参考主表的主键或唯一约束的列 为什么？因为被依赖/被参考的值必须是唯一的 （2）在创建外键约束时，如果不给外键约束命名，默认名不是列名，而是自动产生一个外键名（例如 student_ibfk_1;），也可以指定外键约束名。（3）创建(CREATE)表时就指定外键约束的话，先创建主表，再创建从表（4）删表时，先删从表（或先删除外键约束），再删除主表（5）当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖 该记录的数据，然后才可以删除主表的数据（6）在“从表”中指定外键约束，并且一个表可以建立多个外键约束（7）从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样，逻辑意义一致。如果类 型不一样，创建子表时，就会出现错误“ERROR 1005 (HY000): Can&#39;t create table&#39;database.tablename&#39;(errno: 150)”。 例如：都是表示部门编号，都是int类型。（8）当创建外键约束时，系统默认会在所在的列上建立对应的普通索引。但是索引名是外键的约束 名。（根据外键查询效率很高）（9）删除外键约束后，必须 手动 删除对应的索引6.5 添加外键约束（1）建表时create table 主表名称( 字段1 数据类型 primary key, 字段2 数据类型);create table 从表名称( 字段1 数据类型 primary key, 字段2 数据类型, [CONSTRAINT &amp;lt;外键约束名称&amp;gt;] FOREIGN KEY（从表的某个字段) references 主表名(被参考字段));# (从表的某个字段)的数据类型必须与主表名(被参考字段)的数据类型一致，逻辑意义也一样# (从表的某个字段)的字段名可以与主表名(被参考字段)的字段名一样，也可以不一样-- FOREIGN KEY: 在表级指定子表中的列-- REFERENCES: 标示在父表中的列create table dept( #主表 did int primary key, #部门编号 dname varchar(50) #部门名称);create table emp(#从表 eid int primary key, #员工编号 ename varchar(5), #员工姓名 deptid int, #员工所在的部门 foreign key (deptid) references dept(did) #在从表中指定外键约束 #emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号);说明：（1）主表dept必须先创建成功，然后才能创建emp表，指定外键成功。（2）删除表时，先删除从表emp，再删除主表dept（2）建表后 一般情况下，表与表的关联都是提前设计好了的，因此，会在创建表的时候就把外键约束定义好。不 过，如果需要修改表的设计（比如添加新的字段，增加新的关联关系），但没有预先定义外键约束，那 么，就要用修改表的方式来补充定义。 格式：ALTER TABLE 从表名 ADD [CONSTRAINT 约束名] FOREIGN KEY (从表的字段) REFERENCES 主表名(被引用字段) [on update xx][on delete xx];举例：ALTER TABLE emp1 ADD [CONSTRAINT emp_dept_id_fk] FOREIGN KEY(dept_id) REFERENCES dept(dept_id);举例：create table dept( did int primary key, #部门编号 dname varchar(50) #部门名称);create table emp( eid int primary key, #员工编号 ename varchar(5), #员工姓名 deptid int #员工所在的部门);#这两个表创建时，没有指定外键的话，那么创建顺序是随意alter table emp add foreign key (deptid) references dept(did);6.6 演示问题（1）失败：不是键列create table dept( did int , #部门编号 dname varchar(50) #部门名称);create table emp( eid int primary key, #员工编号 ename varchar(5), #员工姓名 deptid int, #员工所在的部门 foreign key (deptid) references dept(did));#ERROR 1215 (HY000): Cannot add foreign key constraint 原因是dept的did不是键列（2）失败：数据类型不一致create table dept( did int primary key, #部门编号 dname varchar(50) #部门名称);create table emp( eid int primary key, #员工编号 ename varchar(5), #员工姓名 deptid char, #员工所在的部门 foreign key (deptid) references dept(did));#ERROR 1215 (HY000): Cannot add foreign key constraint 原因是从表的deptid字段和主表的did字段的数据类型不一致，并且要它俩的逻辑意义一致（3）成功，两个表字段名一样create table dept( did int primary key, #部门编号 dname varchar(50) #部门名称);create table emp( eid int primary key, #员工编号 ename varchar(5), #员工姓名 did int, #员工所在的部门 foreign key (did) references dept(did) #emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号 #是否重名没问题，因为两个did在不同的表中);（4）添加、删除、修改问题create table dept( did int primary key, #部门编号 dname varchar(50) #部门名称);create table emp( eid int primary key, #员工编号 ename varchar(5), #员工姓名 deptid int, #员工所在的部门 foreign key (deptid) references dept(did) #emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号);insert into dept values(1001,&#39;教学部&#39;);insert into dept values(1003, &#39;财务部&#39;);insert into emp values(1,&#39;张三&#39;,1001); #添加从表记录成功，在添加这条记录时，要求部门表有1001部门insert into emp values(2,&#39;李四&#39;,1005);#添加从表记录失败ERROR 1452 (23000): Cannot add（添加） or update（修改） a child row: a foreign keyconstraint fails (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1` FOREIGN KEY (`deptid`)REFERENCES `dept` (`did`)) # 从表emp添加记录失败，因为主表dept没有1005部门mysql&amp;gt; select * from dept;+------+--------+| did | dname |+------+--------+| 1001 | 教学部 || 1003 | 财务部 |+------+--------+2 rows in set (0.00 sec)mysql&amp;gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |+-----+-------+--------+| 1 | 张三 | 1001 |+-----+-------+--------+1 row in set (0.00 sec)update emp set deptid = 1002 where eid = 1;#修改从表失败ERROR 1452 (23000): Cannot add（添加） or update（修改） a child row（子表的记录）: aforeign key constraint fails（外键约束失败） (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1` FOREIGN KEY (`deptid`) REFERENCES `dept` (`did`)) #部门表did字段现在没有1002的值，所以员工表中不能修改员工所在部门deptid为1002update dept set did = 1002 where did = 1001;#修改主表失败ERROR 1451 (23000): Cannot delete（删除） or update（修改） a parent row（父表的记录）: aforeign key constraint fails (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1` FOREIGN KEY (`deptid`) REFERENCES `dept` (`did`)) #部门表did的1001字段已经被emp引用了，所以部门表的1001字段就不能修改了。update dept set did = 1002 where did = 1003;#修改主表成功 因为部门表的1003部门没有被emp表引用，所以可以修改delete from dept where did=1001; #删除主表失败ERROR 1451 (23000): Cannot delete（删除） or update（修改） a parent row（父表记录）: aforeign key constraint fails (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1` FOREIGN KEY (`deptid`) REFERENCES `dept` (`did`)) #因为部门表did的1001字段已经被emp引用了，所以部门表的1001字段对应的记录就不能被删除总结：约束关系是针对双方的 添加了外键约束后，主表的修改和删除数据受约束 添加了外键约束后，从表的添加和修改数据受约束 在从表上建立外键，要求主表必须存在 删除主表时，要求从表从表先删除，或将从表中外键引用该主表的关系先删除6.7 约束等级 Cascade方式 ：在父表上update/delete记录时，同步update/delete掉子表的匹配记录 Set null方式 ：在父表上update/delete记录时，将子表上匹配记录的列设为null，但是要注意子 表的外键列不能为 not null No action方式 ：如果子表中有匹配的记录，则不允许对父表对应候选键进行update/delete操作 Restrict方式 ：同no action， 都是立即检查外键约束 Set default方式 （在可视化工具SQLyog中可能显示空白）：父表有变更时，子表将外键列设置 成一个默认的值，但Innodb不能识别如果没有指定等级，就相当于Restrict方式。对于外键约束，最好是采用: ON UPDATE CASCADE ON DELETE RESTRICT 的方式。（1）演示1：on update cascade on delete set nullcreate table dept( did int primary key, #部门编号 dname varchar(50) #部门名称);create table emp( eid int primary key, #员工编号 ename varchar(5), #员工姓名 deptid int, #员工所在的部门 foreign key (deptid) references dept(did) on update cascade on delete set null #把修改操作设置为级联修改等级，把删除操作设置为set null等级);insert into dept values(1001,&#39;教学部&#39;);insert into dept values(1002, &#39;财务部&#39;);insert into dept values(1003, &#39;咨询部&#39;);insert into emp values(1,&#39;张三&#39;,1001); #在添加这条记录时，要求部门表有1001部门insert into emp values(2,&#39;李四&#39;,1001);insert into emp values(3,&#39;王五&#39;,1002);mysql&amp;gt; select * from dept;mysql&amp;gt; select * from emp;#修改主表成功，从表也跟着修改，修改了主表被引用的字段1002为1004，从表的引用字段就跟着修改为1004了mysql&amp;gt; update dept set did = 1004 where did = 1002;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&amp;gt; select * from dept;+------+--------+| did | dname |+------+--------+| 1001 | 教学部 || 1003 | 咨询部 || 1004 | 财务部 | #原来是1002，修改为1004+------+--------+3 rows in set (0.00 sec)mysql&amp;gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |+-----+-------+--------+| 1 | 张三 | 1001 || 2 | 李四 | 1001 || 3 | 王五 | 1004 | #原来是1002，跟着修改为1004+-----+-------+--------+3 rows in set (0.00 sec)#删除主表的记录成功，从表对应的字段的值被修改为nullmysql&amp;gt; delete from dept where did = 1001;Query OK, 1 row affected (0.01 sec)mysql&amp;gt; select * from dept;+------+--------+| did | dname | #记录1001部门被删除了+------+--------+| 1003 | 咨询部 || 1004 | 财务部 |+------+--------+2 rows in set (0.00 sec)mysql&amp;gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |+-----+-------+--------+| 1 | 张三 | NULL | #原来引用1001部门的员工，deptid字段变为null| 2 | 李四 | NULL || 3 | 王五 | 1004 |+-----+-------+--------+3 rows in set (0.00 sec)（2）演示2：on update set null on delete cascadecreate table dept( did int primary key, #部门编号 dname varchar(50) #部门名称);create table emp( eid int primary key, #员工编号 ename varchar(5), #员工姓名 deptid int, #员工所在的部门 foreign key (deptid) references dept(did) on update set null on delete cascade #把修改操作设置为set null等级，把删除操作设置为级联删除等级);insert into dept values(1001,&#39;教学部&#39;);insert into dept values(1002, &#39;财务部&#39;);insert into dept values(1003, &#39;咨询部&#39;);insert into emp values(1,&#39;张三&#39;,1001); #在添加这条记录时，要求部门表有1001部门insert into emp values(2,&#39;李四&#39;,1001);insert into emp values(3,&#39;王五&#39;,1002);mysql&amp;gt; select * from dept;+------+--------+| did | dname |+------+--------+| 1001 | 教学部 || 1002 | 财务部 || 1003 | 咨询部 |+------+--------+3 rows in set (0.00 sec)mysql&amp;gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |+-----+-------+--------+| 1 | 张三 | 1001 || 2 | 李四 | 1001 || 3 | 王五 | 1002 |+-----+-------+--------+3 rows in set (0.00 sec)#修改主表，从表对应的字段设置为nullmysql&amp;gt; update dept set did = 1004 where did = 1002;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&amp;gt; select * from dept;+------+--------+| did | dname |+------+--------+| 1001 | 教学部 || 1003 | 咨询部 || 1004 | 财务部 | #原来did是1002+------+--------+3 rows in set (0.00 sec)mysql&amp;gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |+-----+-------+--------+| 1 | 张三 | 1001 || 2 | 李四 | 1001 || 3 | 王五 | NULL | #原来deptid是1002，因为部门表1002被修改了，1002没有对应的了，就设置为null+-----+-------+--------+3 rows in set (0.00 sec)#删除主表的记录成功，主表的1001行被删除了，从表相应的记录也被删除了mysql&amp;gt; delete from dept where did=1001;Query OK, 1 row affected (0.00 sec)mysql&amp;gt; select * from dept;+------+--------+| did | dname | #部门表中1001部门被删除+------+--------+| 1003 | 咨询部 || 1004 | 财务部 |+------+--------+2 rows in set (0.00 sec)mysql&amp;gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |#原来1001部门的员工也被删除了+-----+-------+--------+| 3 | 王五 | NULL |+-----+-------+--------+1 row in set (0.00 sec)（3）演示：on update cascade on delete cascadecreate table dept( did int primary key, #部门编号 dname varchar(50) #部门名称);create table emp( eid int primary key, #员工编号 ename varchar(5), #员工姓名 deptid int, #员工所在的部门 foreign key (deptid) references dept(did) on update cascade on delete cascade #把修改操作设置为级联修改等级，把删除操作也设置为级联删除等级);insert into dept values(1001,&#39;教学部&#39;);insert into dept values(1002, &#39;财务部&#39;);insert into dept values(1003, &#39;咨询部&#39;);insert into emp values(1,&#39;张三&#39;,1001); #在添加这条记录时，要求部门表有1001部门insert into emp values(2,&#39;李四&#39;,1001);insert into emp values(3,&#39;王五&#39;,1002);mysql&amp;gt; select * from dept;+------+--------+| did | dname |+------+--------+| 1001 | 教学部 || 1002 | 财务部 || 1003 | 咨询部 |+------+--------+3 rows in set (0.00 sec)mysql&amp;gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |+-----+-------+--------+| 1 | 张三 | 1001 || 2 | 李四 | 1001 || 3 | 王五 | 1002 |+-----+-------+--------+3 rows in set (0.00 sec)#修改主表，从表对应的字段自动修改mysql&amp;gt; update dept set did = 1004 where did = 1002;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&amp;gt; select * from dept;+------+--------+| did | dname |+------+--------+| 1001 | 教学部 || 1003 | 咨询部 || 1004 | 财务部 | #部门1002修改为1004+------+--------+3 rows in set (0.00 sec)mysql&amp;gt; select * from emp;+-----+-------+--------+| eid | ename | deptid |+-----+-------+--------+| 1 | 张三 | 1001 || 2 | 李四 | 1001 || 3 | 王五 | 1004 | #级联修改+-----+-------+--------+3 rows in set (0.00 sec)#删除主表的记录成功，主表的1001行被删除了，从表相应的记录也被删除了mysql&amp;gt; delete from dept where did=1001;Query OK, 1 row affected (0.00 sec)mysql&amp;gt; select * from dept;+------+--------+| did | dname | #1001部门被删除了+------+--------+| 1003 | 咨询部 || 1004 | 财务部 |+------+--------+2 rows in set (0.00 sec)mysql&amp;gt; select * from emp;+-----+-------+--------+| eid | ename | deptid | #1001部门的员工也被删除了+-----+-------+--------+| 3 | 王五 | 1004 |+-----+-------+--------+1 row in set (0.00 sec)6.8 删除外键约束流程如下：(1)第一步先查看约束名和删除外键约束SELECT * FROM information_schema.table_constraints WHERE table_name = &#39;表名称&#39;;#查看某个表的约束名ALTER TABLE 从表名 DROP FOREIGN KEY 外键约束名;（2）第二步查看索引名和删除索引。（注意，只能手动删除）SHOW INDEX FROM 表名称; #查看某个表的索引名ALTER TABLE 从表名 DROP INDEX 索引名;举例：mysql&amp;gt; SELECT * FROM information_schema.table_constraints WHERE table_name = &#39;emp&#39;;mysql&amp;gt; alter table emp drop foreign key emp_ibfk_1;Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&amp;gt; show index from emp;mysql&amp;gt; alter table emp drop index deptid;Query OK, 0 rows affected (0.01 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&amp;gt; show index from emp;6.9 开发场景问题1：如果两个表之间有关系（一对一、一对多），比如：员工表和部门表（一对多），它们之间是否 一定要建外键约束？答：不是的问题2：建和不建外键约束有什么区别？答：建外键约束，你的操作（创建表、删除表、添加、修改、删除）会受到限制，从语法层面受到限 制。例如：在员工表中不可能添加一个员工信息，它的部门的值在部门表中找不到。不建外键约束，你的操作（创建表、删除表、添加、修改、删除）不受限制，要保证数据的 引用完整 性 ，只能依 靠程序员的自觉 ，或者是 在Java程序中进行限定 。例如：在员工表中，可以添加一个员工的 信息，它的部门指定为一个完全不存在的部门。问题3：那么建和不建外键约束和查询有没有关系？答：没有在 MySQL 里，外键约束是有成本的，需要消耗系统资源。对于大并发的 SQL 操作，有可能会不适 合。比如大型网站的中央数据库，可能会 因为外键约束的系统开销而变得非常慢 。所以， MySQL 允 许你不使用系统自带的外键约束，在 应用层面 完成检查数据一致性的逻辑。也就是说，即使你不 用外键约束，也要想办法通过应用层面的附加逻辑，来实现外键约束的功能，确保数据的一致性。6.10 阿里开发规范【 强制 】不得使用外键与级联，一切外键概念必须在应用层解决。说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学 生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于 单 机低并发 ，不适合 分布式 、 高并发集群 ；级联更新是强阻塞，存在数据库 更新风暴 的风险；外键影响 数据库的 插入速度 。7. CHECK 约束7.1 作用检查某个字段的值是否符号xx要求，一般指的是值的范围7.2 关键字CHECK7.3 说明：MySQL 5.7 不支持MySQL5.7 可以使用check约束，但check约束对数据验证没有任何作用。添加数据时，没有任何错误或警 告 但是MySQL 8.0中可以使用check约束了create table employee( eid int primary key, ename varchar(5), gender char check (&#39;男&#39; or &#39;女&#39;));insert into employee values(1,&#39;张三&#39;,&#39;妖&#39;);mysql&amp;gt; select * from employee;+-----+-------+--------+| eid | ename | gender |+-----+-------+--------+| 1 | 张三 | 妖 |+-----+-------+--------+1 row in set (0.00 sec)再举例CREATE TABLE temp( id INT AUTO_INCREMENT, NAME VARCHAR(20), age INT CHECK(age &amp;gt; 20), PRIMARY KEY(id));age tinyint check(age &amp;gt;20) 或 sex char(2) check(sex in(‘男’,’女’))CHECK(height&amp;gt;=0 AND height&amp;lt;38. DEFAULT约束8.1 作用给某个字段/某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默 认值。8.2 关键字DEFAULT8.3 如何给字段加默认值（1）建表时create table 表名称( 字段名 数据类型 primary key, 字段名 数据类型 unique key not null, 字段名 数据类型 unique key, 字段名 数据类型 not null default 默认值,);create table 表名称( 字段名 数据类型 default 默认值 , 字段名 数据类型 not null default 默认值, 字段名 数据类型 not null default 默认值, primary key(字段名), unique key(字段名));说明：默认值约束一般不在唯一键和主键列上加create table employee( eid int primary key, ename varchar(20) not null, gender char default &#39;男&#39;, tel char(11) not null default &#39;&#39; #默认是空字符串);mysql&amp;gt; desc employee;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| eid | int(11) | NO | PRI | NULL | || ename | varchar(20) | NO | | NULL | || gender| char(1) | YES | | 男 | || tel | char(11) | NO | | | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec)insert into employee values(1,&#39;汪飞&#39;,&#39;男&#39;,&#39;13700102535&#39;); #成功mysql&amp;gt; select * from employee;+-----+-------+--------+-------------+| eid | ename | gender | tel |+-----+-------+--------+-------------+| 1 | 汪飞 | 男 | 13700102535 |+-----+-------+--------+-------------+1 row in set (0.00 secinsert into employee(eid,ename) values(2,&#39;天琪&#39;); #成功mysql&amp;gt; select * from employee;+-----+-------+--------+-------------+| eid | ename | gender | tel |+-----+-------+--------+-------------+| 1 | 汪飞 | 男 | 13700102535 || 2 | 天琪 | 男 | |+-----+-------+--------+-------------+2 rows in set (0.00 sec)insert into employee(eid,ename) values(3,&#39;二虎&#39;);#ERROR 1062 (23000): Duplicate entry &#39;&#39; for key &#39;tel&#39;#如果tel有唯一性约束的话会报错，如果tel没有唯一性约束，可以添加成功CREATE TABLE myemp( id INT AUTO_INCREMENT PRIMARY KEY, NAME VARCHAR(15), salary DOUBLE(10,2) DEFAULT 2000);（2）建表后alter table 表名称 modify 字段名 数据类型 default 默认值;#如果这个字段原来有非空约束，你还保留非空约束，那么在加默认值约束时，还得保留非空约束，否则非空约束就被删除了#同理，在给某个字段加非空约束也一样，如果这个字段原来有默认值约束，你想保留，也要在modify语句中保留默认值约束，否则就删除了alter table 表名称 modify 字段名 数据类型 default 默认值 not null;create table employee( eid int primary key, ename varchar(20), gender char, tel char(11) not null);mysql&amp;gt; desc employee;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| eid | int(11) | NO | PRI | NULL | || ename | varchar(20) | YES | | NULL | || gender | char(1) | YES | | NULL | || tel | char(11) | NO | | NULL | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec)alter table employee modify gender char default &#39;男&#39;; #给gender字段增加默认值约束alter table employee modify tel char(11) default &#39;&#39;; #给tel字段增加默认值约束mysql&amp;gt; desc employee;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| eid | int(11) | NO | PRI | NULL | || ename | varchar(20) | YES | | NULL | || gender | char(1) | YES | | 男 | || tel | char(11) | YES | | | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec)alter table employee modify tel char(11) default &#39;&#39; not null;#给tel字段增加默认值约束，并保留非空约束mysql&amp;gt; desc employee;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| eid | int(11) | NO | PRI | NULL | || ename | varchar(20) | YES | | NULL | || gender | char(1) | YES | | 男 | || tel | char(11) | NO | | | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec)8.4 如何删除默认值约束alter table 表名称 modify 字段名 数据类型 ;#删除默认值约束，也不保留非空约束alter table 表名称 modify 字段名 数据类型 not null; #删除默认值约束，保留非空约束alter table employee modify gender char; #删除gender字段默认值约束，如果有非空约束，也一并删除alter table employee modify tel char(11) not null;#删除tel字段默认值约束，保留非空约束mysql&amp;gt; desc employee;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| eid | int(11) | NO | PRI | NULL | || ename | varchar(20) | YES | | NULL | || gender | char(1) | YES | | NULL | || tel | char(11) | NO | | NULL | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec)9. 面试面试1、为什么建表时，加 not null default ‘’ 或 default 0?答：不想让表中出现null值。面试2、为什么不想要 null 的值?答:（1）不好比较。null是一种特殊值，比较时只能用专门的is null 和 is not null来比较。碰到运算符，通常返回null。​ （2）效率不高。影响提高索引效果。因此，我们往往在建表时 not null default ‘’ 或 default 0面试3、带AUTO_INCREMENT约束的字段值是从1开始的吗？ 在MySQL中，默认AUTO_INCREMENT的初始 值是1，每新增一条记录，字段值自动加1。设置自增属性（AUTO_INCREMENT）的时候，还可以指定第 一条插入记录的自增字段的值，这样新插入的记录的自增字段值从初始值开始递增，如在表中插入第一 条记录，同时指定id值为5，则以后插入的记录的id值就会从6开始往上增加。添加主键约束时，往往需要设置字段自动增加属性。 面试4、并不是每个表都可以任意选择存储引擎？ 外键约束（FOREIGN KEY）不能跨引擎使用。 MySQL支持多种存储引擎，每一个表都可以指定一个不同的存储引擎，需要注意的是：外键约束是用来 保证数据的参照完整性的，如果表之间需要关联外键，却指定了不同的存储引擎，那么这些表之间是不能创建外键约束的。所以说，存储引擎的选择也不完全是随意的。10.课后练习 字段名 数据类型 主键 外键 非空 唯一 自增 officeCode INT(10) 是 否 是 是 否 city VARCHAR(50) 否 否 是 否 否 address VARCHAR(50) 否 否 否 否 否 country VARCHAR(50) 否 否 是 否 否 postalCode VARCHAR(15) 否 否 否 是 否 1.创建表officesCREATE TABLE IF NOT EXISTS offices(officeCode INT(10) ZEROFILL PRIMARY KEY, city VARCHAR(50) NOT NULL, address VARCHAR(50), country VARCHAR(50) NOT NULL, postalCode VARCHAR(15) UNIQUE,; 字段名 数据类型 主键 外键 非空 唯一 自增 employeeNumber INT(11) 是 否 是 是 是 lastName VARCHAR(50) 否 否 是 否 否 firstName VARCHAR(50) 否 否 是 否 否 mobile VARCHAR(25) 否 否 否 是 否 officeCode INT(10) 否 是 是 否 否 jobTitle VARCHAR(50) 否 否 是 否 否 birth DATETIME 否 否 是 否 否 note VARCHAR(255) 否 否 否 否 否 sex VARCHAR(5) 否 否 否 否 否 2.创建表employeesCREATE TABLE employees(employeeNumber INT PRIMARY KEY AUTO_INCREMENT, lastName VARCHAR(50) NOT NULL, firstName VARCHAR(50) NOT NULL, mobile VARCHAR(25) UNIQUE, officeCode INT(10) ZEROFILL NOT NULL, jobTitle VARCHAR(50) NOT NULL, birth DATETIME NOT NULL, sex VARCHAR(5), CONSTRAINT fk_emp_officecode FOREIGN KEY (officeCode) REFERENCES offices(officeCode))3.将表employees中的mobile字段修改到officeCode前面ALTER TABLE employeesMODIFY mobile VARCHAR(25) AFTER officeCode;4.将表employees的birth字段改名为employee_birthALTER TABLE employeesCHANGE birth employee_birth DATETIME;5.修改sex字段，数据类型为CHAR(1)，非空约束ALTER TABLE employees MODIFY sex CHAR(1) NOT NULL;6.删除字段ALTER TABLE employeesDROP COLUMN note;7.增加字段名favorite_activity，数据类型为VARCHAR(100)ALTER TABLE employeesADD favorite_activity VARCHAR(100);8.将表employees名称修改为employees_infoRENAME TABLE employeesTO employees_info;参考链接1.MySQL数据库教程天花板，mysql安装到mysql高级，强！硬！" }, { "title": "MySQL数据类型精讲", "url": "/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%B2%BE%E8%AE%B2/", "categories": "数据库", "tags": "MySQL", "date": "2021-06-12 00:00:00 +0800", "snippet": "1.MySQL中的数据类型 类型 类型举例 整数类型 TINYINT、SMALLINT、MEDIUMINT、INT(或INTEGER)、BIGINT 浮点类型 FLOAT、DOUBLE 定点数类型 DECIMAL 位类型 BIT 日期时间类型 YEAR、TIME、DATE、DATETIME、TIMESTAMP 文本字符串类型 CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT 枚举类型 ENUM 集合类型 SET 二进制字符串类型 BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB JSON类型 JSON对象、JSON数组 空间数据类型 单值类型：GEOMETRY、POINT、LINESTRING、POLYGON；集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、 GEOMETRYCOLLECTION 常见数据类型的属性，如下： MySQL关键字 含义 NULL 数据列可包含NULL值 NOT NULL 数据列不允许包含NULL值 DEFAULT 默认值 PRIMARY KEY 主键 AUTO_INCREMENT 自动递增，适用于整数类型 UNSIGNED 无符号 CHARACTER SET name 指定一个字符集 ，如utf8 2. 整数类型2.1 类型介绍​ 整数类型一共有 5 种，包括 TINYINT、SMALLINT、MEDIUMINT、INT（INTEGER）和 BIGINT。 它们的区别如下表所示： 整数类型 字节 有符号数取值范围 无符号数取值范围 TINYINT 1 -128~127 0~255 SMALLINT 2 -32768~32767 0~65535 MEDIUMINT 3 -8388608~8388607 0~16777215 INT、INTEGER 4 -2147483648~2147483647 0~4294967295 BIGINT 8 -9223372036854775808~9223372036854775807 0~18446744073709551615 2.2 可选属性整数类型的可选属性有三个：2.2.1 M​ M : 表示显示宽度，M的取值范围是(0, 255)。例如，int(5)：当数据宽度小于5位的时候在数字前面需要用 字符填满宽度。该项功能需要配合ZEROFILL使用，表示用“0”填满宽度，否则指定显示宽度无效。 如果设置了显示宽度，那么插入的数据宽度超过显示宽度限制，会不会截断或插入失败？ 答案：不会对插入的数据有任何影响，还是按照类型的实际宽度进行保存，即 显示宽度与类型可以存储的 值范围无关 。​ 从MySQL 8.0.17开始，整数数据类型不推荐使用显示宽度属性。 整型数据类型可以在定义表结构时指定所需要的显示宽度，如果不指定，则系统为每一种类型指定默认 的宽度值。举例：CREATE TABLE test_int1 ( x TINYINT, y SMALLINT, z MEDIUMINT, m INT, n BIGINT );查看表结构 （MySQL8中不再显式范围）mysql&amp;gt; desc test_int1;+-------+-----------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-----------+------+-----+---------+-------+| x | tinyint | YES | | NULL | || y | smallint | YES | | NULL | || z | mediumint | YES | | NULL | || m | int | YES | | NULL | || n | bigint | YES | | NULL | |+-------+-----------+------+-----+---------+-------+5 rows in set​ TINYINT有符号数和无符号数的取值范围分别为-128~127和0~255，由于负号占了一个数字位，因此 TINYINT默认的显示宽度为4。同理，其他整数类型的默认显示宽度与其有符号数的最小值的宽度相同。2.2.2 UNSIGNED​ UNSIGNED : 无符号类型（非负），所有的整数类型都有一个可选的属性UNSIGNED（无符号属性），无 符号整数类型的最小取值为0。所以，如果需要在MySQL数据库中保存非负整数值时，可以将整数类型设 置为无符号类型。​ int类型默认显示宽度为int(11)，无符号int类型默认显示宽度为int(10)。CREATE TABLE test_int3( f1 INT UNSIGNED);mysql&amp;gt; desc test_int3;+-------+--------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+--------------+------+-----+---------+-------+| f1 | int unsigned | YES | | NULL | |+-------+--------------+------+-----+---------+-------+1 row in set2.2.3 ZEROFILL​ ZEROFILL : 0填充,（如果某列是ZEROFILL，那么MySQL会自动为当前列添加UNSIGNED属性），如果指 定了ZEROFILL只是表示不够M位时，用0在左边填充，如果超过M位，只要不超过数据存储范围即可。​ 原来，在 int(M) 中，M 的值跟 int(M) 所占多少存储空间并无任何关系。 int(3)、int(4)、int(8) 在磁盘上都 是占用 4 bytes 的存储空间。也就是说，int(M)，必须和UNSIGNED ZEROFILL一起使用才有意义。如果整 数值超过M位，就按照实际位数存储。只是无须再用字符 0 进行填充。2.3 适用场景TINYINT ：一般用于枚举数据，比如系统设定取值范围很小且固定的场景。SMALLINT ：可以用于较小范围的统计数据，比如统计工厂的固定资产库存数量等。MEDIUMINT ：用于较大整数的计算，比如车站每日的客流量等。INT、INTEGER ：取值范围足够大，一般情况下不用考虑超限问题，用得最多。比如商品编号。BIGINT ：只有当你处理特别巨大的整数时才会用到。比如双十一的交易量、大型门户网站点击量、证 券公司衍生产品持仓等。2.4 如何选择？​ 在评估用哪种整数类型的时候，你需要考虑 存储空间 和 可靠性 的平衡问题：一方面，用占用字节数少 的整数类型可以节省存储空间；另一方面，要是为了节省存储空间， 使用的整数类型取值范围太小，一 旦遇到超出取值范围的情况，就可能引起 系统错误 ，影响可靠性。​ 举个例子，商品编号采用的数据类型是 INT。原因就在于，客户门店中流通的商品种类较多，而且，每天都有旧商品下架，新商品上架，这样不断迭代，日积月累。 如果使用 SMALLINT 类型，虽然占用字节数比 INT 类型的整数少，但是却不能保证数据不会超出范围 65535。相反，使用 INT，就能确保有足够大的取值范围，不用担心数据超出范围影响可靠性的问题。 你要注意的是，在实际工作中，系统故障产生的成本远远超过增加几个字段存储空间所产生的成本。因 此，我建议你首先确保数据不会超过取值范围，在这个前提之下，再去考虑如何节省存储空间。3. 浮点类型3.1 类型介绍​ 浮点数和定点数类型的特点是可以处理小数 ，你可以把整数看成小数的一个特例。因此，浮点数和定点 数的使用场景，比整数大多了。 MySQL支持的浮点数类型，分别是 FLOAT、DOUBLE、REAL。 FLOAT 表示单精度浮点数； DOUBLE 表示双精度浮点数； 类型 有符号数范围 无符号数取值范围 占用字节数 FLOAT (-3.40E+38，-1.17E-38)，0，(1.17E-38，3.40E+38) 0，(1.17E-38，3.40E+38) 4 DOUBLE (-1.79E+308，-2.25E-308)，0，(2.25E-308，1.79E+308) 0，(2.25E-308，1.79E+308) 8 ​ REAL默认就是 DOUBLE。如果你把 SQL 模式设定为启用“ REAL_AS_FLOAT ”，那么，MySQL 就认为 REAL 是 FLOAT。如果要启用“REAL_AS_FLOAT”，可以通过以下 SQL 语句实现：SET sql_mode = “REAL_AS_FLOAT”;问题1：FLOAT 和 DOUBLE 这两种数据类型的区别是啥呢？​ FLOAT 占用字节数少，取值范围小；DOUBLE 占用字节数多，取值范围也大。问题2：为什么浮点数类型的无符号数取值范围，只相当于有符号数取值范围的一半，也就是只相当于 有符号数取值范围大于等于零的部分呢？​ MySQL 存储浮点数的格式为： 符号(S) 、 尾数(M) 和 阶码(E) 。因此，无论有没有符号，MySQL 的浮 点数都会存储表示符号的部分。因此， 所谓的无符号数取值范围，其实就是有符号数取值范围大于等于 零的部分。3.2 数据精度说明对于浮点类型，在MySQL中单精度值使用 4 个字节，双精度值使用 8 个字节。 MySQL允许使用 非标准语法 （其他数据库未必支持，因此如果涉及到数据迁移，则最好不要这么 用）： FLOAT(M,D) 或 DOUBLE(M,D) 。这里，M称为 精度 ，D称为标度 。(M,D)中 M=整数位+小数 位，D=小数位。 D&amp;lt;=M&amp;lt;=255，0&amp;lt;=D&amp;lt;=30。 例如，定义为FLOAT(5,2)的一个列可以显示为-999.99-999.99。如果超过这个范围会报错。 FLOAT和DOUBLE类型在不指定(M,D)时，默认会按照实际的精度（由实际的硬件和操作系统决定） 来显示。 说明：浮点类型，也可以加 UNSIGNED ，但是不会改变数据范围，例如：FLOAT(3,2) UNSIGNED仍然 只能表示0-9.99的范围。 不管是否显式设置了精度(M,D)，这里MySQL的处理方案如下： 如果存储时，整数部分超出了范围，MySQL就会报错，不允许存这样的值 如果存储时，小数点部分若超出范围，就分以下情况： 若四舍五入后，整数部分没有超出范围，则只警告，但能成功操作并四舍五入删除多余 的小数位后保存。例如在FLOAT(5,2)列内插入999.009，近似结果是999.01。 若四舍五入后，整数部分超出范围，则MySQL报错，并拒绝处理。如FLOAT(5,2)列内插入 999.995和-999.995都会报错。 从MySQL 8.0.17开始，FLOAT(M,D) 和DOUBLE(M,D)用法在官方文档中已经明确不推荐使用，将来可能被移除。另外，关于浮点型FLOAT和DOUBLE的UNSIGNED也不推荐使用了，将来也可能被移除。CREATE TABLE test_double1(f1 FLOAT,f2 FLOAT(5,2),f3 DOUBLE,f4 DOUBLE(5,2));DESC test_double1;INSERT INTO test_double1VALUES(123.456,123.456,123.4567,123.45);#Out of range value for column &#39;f2&#39; at row 1INSERT INTO test_double1VALUES(123.456,1234.456,123.4567,123.45);SELECT * FROM test_double1;3.3 精度误差说明​ 浮点数类型有个缺陷，就是不精准。下面我来重点解释一下为什么 MySQL 的浮点数不够精准。比如，我 们设计一个表，有f1这个字段，插入值分别为0.47,0.44,0.19，我们期待的运行结果是：0.47 + 0.44 + 0.19 = 1.1。而使用sum之后查询：CREATE TABLE test_double2( f1 DOUBLE);INSERT INTO test_double2VALUES(0.47),(0.44),(0.19);SELECT SUM(f1) FROM test_double2;+--------------------+| SUM(f1) |+--------------------+| 1.0999999999999999 |+--------------------+1 row in setSELECT SUM(f1) = 1.1,1.1 = 1.1 FROM test_double2;+---------------+-----------+| SUM(f1) = 1.1 | 1.1 = 1.1 |+---------------+-----------+| 0 | 1 |+---------------+-----------+1 row in set​ 查询结果是 1.0999999999999999。看到了吗？虽然误差很小，但确实有误差。 你也可以尝试把数据类型 改成 FLOAT，然后运行求和查询，得到的是， 1.0999999940395355。显然，误差更大了。​ 那么，为什么会存在这样的误差呢？问题还是出在 MySQL 对浮点类型数据的存储方式上。​ MySQL 用 4 个字节存储 FLOAT 类型数据，用 8 个字节来存储 DOUBLE 类型数据。无论哪个，都是采用二进制的方式来进行存储的。比如 9.625，用二进制来表达，就是 1001.101，或者表达成 1.001101×2^3。如果尾数不是 0 或 5（比如 9.624），你就无法用一个二进制数来精确表达。进而，就只好在取值允许的范 围内进行四舍五入。​ 在编程中，如果用到浮点数，要特别注意误差问题，因为浮点数是不准确的，所以我们要避免使用“=”来 判断两个数是否相等。同时，在一些对精确度要求较高的项目中，千万不要使用浮点数，不然会导致结 果错误，甚至是造成不可挽回的损失。那么，MySQL 有没有精准的数据类型呢？当然有，这就是定点数类型： DECIMAL 。4. 定点数类型4.1 类型介绍​ MySQL中的定点数类型只有 DECIMAL 一种类型。 数据类型 字节数 含义 DECIMAL(M,D),DEC,NUMERIC M+2字节 有效范围由M和D决定 ​ 使用 DECIMAL(M,D) 的方式表示高精度小数。其中，M被称为精度，D被称为标度。0&amp;lt;=M&amp;lt;=65， 0&amp;lt;=D&amp;lt;=30，D被称为标度。0&amp;lt;=M&amp;lt;=65，0&amp;lt;=D&amp;lt;=30，D&amp;lt;M。例如，定义DECIMAL（5,2）的类型，表示该列取值范围是-999.99~999.99。​ DECIMAL(M,D)的最大取值范围与DOUBLE类型一样，但是有效的数据范围是由M和D决定的。 DECIMAL 的存储空间并不是固定的，由精度值M决定，总共占用的存储空间为M+2个字节。也就是 说，在一些对精度要求不高的场景下，比起占用同样字节长度的定点数，浮点数表达的数值范围可 以更大一些。​ 定点数在MySQL内部是以 字符串 的形式进行存储，这就决定了它一定是精准的。​ 当DECIMAL类型不指定精度和标度时，其默认为DECIMAL(10,0)。当数据的精度超出了定点数类型的 精度范围时，则MySQL同样会进行四舍五入处理。浮点数 vs 定点数​ 浮点数相对于定点数的优点是在长度一定的情况下，浮点类型取值范围大，但是不精准，适用于需要取值范围大，又可以容忍微小误差的科学计算场景（比如计算化学、分子建模、流体动 力学等） 定点数类型取值范围相对小，但是精准，没有误差，适合于对精度要求极高的场景 （比如涉 及金额计算的场景）CREATE TABLE test_decimal1( f1 DECIMAL, f2 DECIMAL(5,2));DESC test_decimal1;INSERT INTO test_decimal1(f1,f2)VALUES(123.123,123.456);#Out of range value for column &#39;f2&#39; at row 1INSERT INTO test_decimal1(f2)VALUES(1234.34);mysql&amp;gt; SELECT * FROM test_decimal1;+-----+--------+| f1 | f2 |+-----+--------+| 123 | 123.46 |+-----+--------+1 row in set举例:​ 我们运行下面的语句，把test_double2表中字段“f1”的数据类型修改为 DECIMAL(5,2)：ALTER TABLE test_double2MODIFY f1 DECIMAL(5,2);然后，我们再一次运行求和语句：mysql&amp;gt; SELECT SUM(f1) FROM test_double2;+---------+| SUM(f1) |+---------+| 1.10 |+---------+1 row in set (0.00 sec)mysql&amp;gt; SELECT SUM(f1) = 1.1 FROM test_double2;+---------------+| SUM(f1) = 1.1 |+---------------+| 1 |+---------------+1 row in set (0.00 sec)4.2 开发中经验“由于 DECIMAL 数据类型的精准性，在我们的项目中，除了极少数（比如商品编号）用到整数类型外，其他的数值都用的是 DECIMAL，原因就是这个项目所处的零售行业，要求精准，一分钱也不能差。 ” ——来自某项目经理5. 位类型：BITBIT类型中存储的是二进制值，类似010110。 二进制字符串类型 长度 长度范围 占用空间 BIT(M) M 1 &amp;lt;= M &amp;lt;= 64 约为(M + 7)/8个字节 BIT类型，如果没有指定(M)，默认是1位。这个1位，表示只能存1位的二进制值。这里(M)是表示二进制的 位数，位数最小值为1，最大值为64。CREATE TABLE test_bit1( f1 BIT, f2 BIT(5), f3 BIT(64));INSERT INTO test_bit1(f1)VALUES(1);#Data too long for column &#39;f1&#39; at row 1INSERT INTO test_bit1(f1)VALUES(2);INSERT INTO test_bit1(f2)VALUES(23);注意：在向BIT类型的字段中插入数据时，一定要确保插入的数据在BIT类型支持的范围内。使用SELECT命令查询位字段时，可以用 BIN() 或 HEX() 函数进行读取。mysql&amp;gt; SELECT * FROM test_bit1;+------------+------------+------------+| f1 | f2 | f3 |+------------+------------+------------+| 0x01 | NULL | NULL || NULL | 0x17 | NULL |+------------+------------+------------+2 rows in set (0.00 sec)mysql&amp;gt; SELECT BIN(f2),HEX(f2) FROM test_bit1;+---------+---------+| BIN(f2) | HEX(f2) |+---------+---------+| NULL | NULL || 10111 | 17 |+---------+---------+2 rows in set (0.00 sec)mysql&amp;gt; SELECT f2 + 0 FROM test_bit1;+--------+| f2 + 0 |+--------+| NULL || 23 |+--------+2 rows in set (0.00 sec)可以看到，使用b+0查询数据时，可以直接查询出存储的十进制数据的值。6. 日期与时间类型​ 日期与时间是重要的信息，在我们的系统中，几乎所有的数据表都用得到。原因是客户需要知道数据的 时间标签，从而进行数据查询、统计和处理。​ MySQL有多种表示日期和时间的数据类型，不同的版本可能有所差异，MySQL8.0版本支持的日期和时间 类型主要有：YEAR类型、TIME类型、DATE类型、DATETIME类型和TIMESTAMP类型。YEAR 类型通常用来表示年DATE 类型通常用来表示年、月、日TIME 类型通常用来表示时、分、秒DATETIME 类型通常用来表示年、月、日、时、分、秒TIMESTAMP 类型通常用来表示带时区的年、月、日、时、分、秒 类型 名称 字节 日期格式 最小值 最大值 YEAR 年 1 YYYY或YY 1901 2155 TIME 时间 3 HH:MM:SS -838:59:59 838:59:59 DATE 日期 3 YYYY-MM-DD 1000-01-01 9999-12-03 DATETIME 日期 时间 8 YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00 9999-12-31 23:59:59 TIMESTAMP 日期 时间 4 YYYY-MM-DD HH:MM:SS 1970-01-01 00:00:00 UTC 2038-01-19 03:14:07UTC ​ 可以看到，不同数据类型表示的时间内容不同、取值范围不同，而且占用的字节数也不一样，你要根据 实际需要灵活选取。为什么时间类型 TIME 的取值范围不是 -23:59:59～23:59:59 呢？​ 原因是 MySQL 设计的 TIME 类型，不光表 示一天之内的时间，而且可以用来表示一个时间间隔，这个时间间隔可以超过 24 小时。6.1 YEAR类型​ YEAR类型用来表示年份，在所有的日期时间类型中所占用的存储空间最小，只需要 1个字节 的存储空间。 在MySQL中，YEAR有以下几种存储格式： 以4位字符串或数字格式表示YEAR类型，其格式为YYYY，最小值为1901，最大值为2155。 以2位字符串格式表示YEAR类型，最小值为00，最大值为99。 当取值为01到69时，表示2001到2069； 当取值为70到99时，表示1970到1999； 当取值整数的0或00添加的话，那么是0000年； 当取值是日期/字符串的’0’添加的话，是2000年。 从MySQL5.5.27开始，2位格式的YEAR已经不推荐使用。YEAR默认格式就是“YYYY”，没必要写成YEAR(4)， 从MySQL 8.0.19开始，不推荐使用指定显示宽度的YEAR(4)数据类型。CREATE TABLE test_year( f1 YEAR, f2 YEAR(4));mysql&amp;gt; DESC test_year;+-------+---------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| f1 | year(4) | YES | | NULL | || f2 | year(4) | YES | | NULL | |+-------+---------+------+-----+---------+-------+2 rows in set (0.00 sec)INSERT INTO test_yearVALUES(&#39;2020&#39;,&#39;2021&#39;);mysql&amp;gt; SELECT * FROM test_year;+------+------+| f1 | f2 |+------+------+| 2020 | 2021 |+------+------+1 rows in set (0.00 sec)INSERT INTO test_yearVALUES(&#39;45&#39;,&#39;71&#39;);INSERT INTO test_yearVALUES(0,&#39;0&#39;);mysql&amp;gt; SELECT * FROM test_year;+------+------+| f1 | f2 |+------+------+| 2020 | 2021 || 2045 | 1971 || 0000 | 2000 |+------+------+3 rows in set (0.00 sec)6.2 DATE类型​ DATE类型表示日期，没有时间部分，格式为 YYYY-MM-DD ，其中，YYYY表示年份，MM表示月份，DD表示 日期。需要 3个字节 的存储空间。在向DATE类型的字段插入数据时，同样需要满足一定的格式条件。 以 YYYY-MM-DD 格式或者 YYYYMMDD 格式表示的字符串日期，其最小取值为1000-01-01，最大取值为 9999-12-03。YYYYMMDD格式会被转化为YYYY-MM-DD格式。 以 YY-MM-DD 格式或者 YYMMDD 格式表示的字符串日期，此格式中，年份为两位数值或字符串满足 YEAR类型的格式条件为：当年份取值为00到69时，会被转化为2000到2069；当年份取值为70到99 时，会被转化为1970到1999。 使用 CURRENT_DATE() 或者 NOW() 函数，会插入当前系统的日期。举例： 创建数据表，表中只包含一个DATE类型的字段f1CREATE TABLE test_date1( f1 DATE);Query OK, 0 rows affected (0.13 sec)插入数据INSERT INTO test_date1VALUES (&#39;2020-10-01&#39;), (&#39;20201001&#39;),(20201001);INSERT INTO test_date1VALUES (&#39;00-01-01&#39;), (&#39;000101&#39;), (&#39;69-10-01&#39;), (&#39;691001&#39;), (&#39;70-01-01&#39;), (&#39;700101&#39;),(&#39;99-01-01&#39;), (&#39;990101&#39;);INSERT INTO test_date1VALUES (000301), (690301), (700301), (990301);INSERT INTO test_date1VALUES (CURRENT_DATE()), (NOW());SELECT *FROM test_date1;+------------+| f1 |+------------+| 2020-10-01 || 2020-10-01 || 2020-10-01 || 2000-01-01 || 2000-01-01 || 2069-10-01 || 2069-10-01 || 1970-01-01 || 1970-01-01 || 1999-01-01 || 1999-01-01 || 2000-03-01 || 2069-03-01 || 1970-03-01 || 1999-03-01 || 2022-05-25 || 2022-05-25 |+------------+17 rows in set6.3 TIME类型​ TIME类型用来表示时间，不包含日期部分。在MySQL中，需要 3个字节 的存储空间来存储TIME类型的数 据，可以使用“HH:MM:SS”格式来表示TIME类型，其中，HH表示小时，MM表示分钟，SS表示秒。 在MySQL中，向TIME类型的字段插入数据时，也可以使用几种不同的格式。（1）可以使用带有冒号的 字符串，比如&#39; D HH:MM:SS&#39; 、&#39; HH:MM:SS &#39;、&#39; HH:MM &#39;、&#39; D HH:MM &#39;、&#39; D HH &#39;或&#39; SS &#39;格式，都能被正 确地插入TIME类型的字段中。其中D表示天，其最小值为0，最大值为34。如果使用带有D格式的字符串 插入TIME类型的字段时，D会被转化为小时，计算格式为D*24+HH。当使用带有冒号并且不带D的字符串 表示时间时，表示当天的时间，比如12:10表示12:10:00，而不是00:12:10。（2）可以使用不带有冒号的 字符串或者数字，格式为&#39; HHMMSS &#39;或者 HHMMSS 。如果插入一个不合法的字符串或者数字，MySQL在存 储数据时，会将其自动转化为00:00:00进行存储。比如1210，MySQL会将最右边的两位解析成秒，表示 00:12:10，而不是12:10:00。（3）使用 CURRENT_TIME() 或者 NOW() ，会插入当前系统的时间。举例： 创建数据表，表中包含一个TIME类型的字段f1。CREATE TABLE test_time1( f1 TIME);Query OK, 0 rows affected (0.02 sec)INSERT INTO test_time1VALUES(&#39;2 12:30:29&#39;), (&#39;12:35:29&#39;), (&#39;12:40&#39;), (&#39;2 12:40&#39;),(&#39;1 05&#39;), (&#39;45&#39;);INSERT INTO test_time1VALUES (&#39;123520&#39;), (124011),(1210);INSERT INTO test_time1VALUES (NOW()), (CURRENT_TIME());SELECT * FROM test_time1;6.4 DATETIME类型DATETIME类型在所有的日期时间类型中占用的存储空间最大，总共需要 8 个字节的存储空间。在格式上 为DATE类型和TIME类型的组合，可以表示为 YYYY-MM-DD HH:MM:SS ，其中YYYY表示年份，MM表示月 份，DD表示日期，HH表示小时，MM表示分钟，SS表示秒。在向DATETIME类型的字段插入数据时，同样需要满足一定的格式条件。 以 YYYY-MM-DD HH:MM:SS 格式或者 YYYYMMDDHHMMSS 格式的字符串插入DATETIME类型的字段时， 最小值为1000-01-01 00:00:00，最大值为9999-12-03 23:59:59。 以YYYYMMDDHHMMSS格式的数字插入DATETIME类型的字段时，会被转化为YYYY-MM-DD HH:MM:SS格式。 以 YY-MM-DD HH:MM:SS 格式或者 YYMMDDHHMMSS 格式的字符串插入DATETIME类型的字段时，两位数的年份规则符合YEAR类型的规则，00到69表示2000到2069；70到99表示1970到1999。 使用函数 CURRENT_TIMESTAMP() 和 NOW() ，可以向DATETIME类型的字段插入系统的当前日期和 时间。 举例： 创建数据表，表中包含一个DATETIME类型的字段dt。CREATE TABLE test_datetime1(dt DATETIME);Query OK, 0 rows affected (0.02 sec)插入数据INSERT INTO test_datetime1VALUES (&#39;2021-01-01 06:50:30&#39;), (&#39;20210101065030&#39;);INSERT INTO test_datetime1VALUES (&#39;99-01-01 00:00:00&#39;), (&#39;990101000000&#39;), (&#39;20-01-01 00:00:00&#39;),(&#39;200101000000&#39;);INSERT INTO test_datetime1VALUES (20200101000000), (200101000000), (19990101000000), (990101000000);INSERT INTO test_datetime1VALUES (CURRENT_TIMESTAMP()), (NOW());6.5 TIMESTAMP类型​ TIMESTAMP类型也可以表示日期时间，其显示格式与DATETIME类型相同，都是 YYYY-MM-DD HH:MM:SS ，需要4个字节的存储空间。但是TIMESTAMP存储的时间范围比DATETIME要小很多，只能存储 “1970-01-01 00:00:01 UTC”到“2038-01-19 03:14:07 UTC”之间的时间。其中，UTC表示世界统一时间，也叫 作世界标准时间。​ 存储数据的时候需要对当前时间所在的时区进行转换，查询数据的时候再将时间转换回当前的时 区。因此，使用TIMESTAMP存储的同一个时间值，在不同的时区查询时会显示不同的时间。​ 向TIMESTAMP类型的字段插入数据时，当插入的数据格式满足YY-MM-DD HH:MM:SS和YYMMDDHHMMSS 时，两位数值的年份同样符合YEAR类型的规则条件，只不过表示的时间范围要小很多。 如果向TIMESTAMP类型的字段插入的时间超出了TIMESTAMP类型的范围，则MySQL会抛出错误信息。举例： 创建数据表，表中包含一个TIMESTAMP类型的字段ts。CREATE TABLE test_timestamp1( ts TIMESTAMP);插入数据：INSERT INTO test_timestamp1VALUES (&#39;1999-01-01 03:04:50&#39;), (&#39;19990101030405&#39;), (&#39;99-01-01 03:04:05&#39;),(&#39;990101030405&#39;);INSERT INTO test_timestamp1VALUES (&#39;2020@01@01@00@00@00&#39;), (&#39;20@01@01@00@00@00&#39;);INSERT INTO test_timestamp1VALUES (CURRENT_TIMESTAMP()), (NOW());#Incorrect datetime valueINSERT INTO test_timestamp1VALUES (&#39;2038-01-20 03:14:07&#39;);TIMESTAMP和DATETIME的区别： TIMESTAMP存储空间比较小，表示的日期时间范围也比较小 底层存储方式不同，TIMESTAMP底层存储的是毫秒值，距离1970-1-1 0:0:0 0毫秒的毫秒值。 两个日期比较大小或日期计算时，TIMESTAMP更方便、更快。 TIMESTAMP和时区有关。TIMESTAMP会根据用户的时区不同，显示不同的结果。而DATETIME则只能 反映出插入时当地的时区，其他时区的人查看数据必然会有误差的。CREATE TABLE temp_time( d1 DATETIME, d2 TIMESTAMP);INSERT INTO temp_time VALUES(&#39;2021-9-2 14:45:52&#39;,&#39;2021-9-2 14:45:52&#39;);INSERT INTO temp_time VALUES(NOW(),NOW());mysql&amp;gt; SELECT * FROM temp_time;+---------------------+---------------------+| d1 | d2 |+---------------------+---------------------+| 2021-09-02 14:45:52 | 2021-09-02 14:45:52 || 2021-11-03 17:38:17 | 2021-11-03 17:38:17 |+---------------------+---------------------+2 rows in set (0.00 sec)#修改当前的时区SET time_zone = &#39;+9:00&#39;;mysql&amp;gt; SELECT * FROM temp_time;+---------------------+---------------------+| d1 | d2 |+---------------------+---------------------+| 2021-09-02 14:45:52 | 2021-09-02 15:45:52 || 2021-11-03 17:38:17 | 2021-11-03 18:38:17 |+---------------------+---------------------+2 rows in set (0.00 sec6.6 开发中经验​ 用得最多的日期时间类型，就是 DATETIME 。虽然 MySQL 也支持 YEAR（年）、 TIME（时间）、 DATE（日期），以及 TIMESTAMP 类型，但是在实际项目中，尽量用 DATETIME 类型。因为这个数据类型 包括了完整的日期和时间信息，取值范围也最大，使用起来比较方便。毕竟，如果日期时间信息分散在 好几个字段，很不容易记，而且查询的时候，SQL 语句也会更加复杂。​ 此外，一般存注册时间、商品发布时间等，不建议使用DATETIME存储，而是使用 时间戳 ，因为 DATETIME虽然直观，但不便于计算。mysql&amp;gt; SELECT UNIX_TIMESTAMP();+------------------+| UNIX_TIMESTAMP() |+------------------+| 1635932762 |+------------------+1 row in set (0.00 sec)7. 文本字符串类型​ 在实际的项目中，我们还经常遇到一种数据，就是字符串数据。 MySQL中，文本字符串总体上分为 CHAR 、 VARCHAR 、 TINYTEXT 、 TEXT 、 MEDIUMTEXT 、 LONGTEXT 、 ENUM 、 SET 等类型。 文本字符串类型 值的长度 长度范围 占用的存储空间 CHAR(M) M 0&amp;lt;=M&amp;lt;=255 M个字节 VARCHAR(M) M 0&amp;lt;=M&amp;lt;=65535 M+1个字节 TINYTEXT L 0&amp;lt;=L&amp;lt;=255 L+2个字节 TEXT L 0&amp;lt;=L&amp;lt;=65535 L+2个字节 MEDIUMTEXT L 0&amp;lt;=L&amp;lt;=16777215 L+3个字节 LONGTEXT L 0&amp;lt;=L&amp;lt;=4294967295 L+4个字节 ENUM L 1&amp;lt;=L&amp;lt;=65535 1或2个字节 SET L 0&amp;lt;=L&amp;lt;=64 1,2,3,4或8个字节 7.1 CHAR与VARCHAR类型CHAR类型： CHAR(M) 类型一般需要预先定义字符串长度。如果不指定(M)，则表示长度默认是1个字符。 如果保存时，数据的实际长度比CHAR类型声明的长度小，则会在 右侧填充 空格以达到指定的长 度。当MySQL检索CHAR类型的数据时，CHAR类型的字段会去除尾部的空格。 定义CHAR类型字段时，声明的字段长度即为CHAR类型字段所占的存储空间的字节数。CREATE TABLE test_char1( c1 CHAR, c2 CHAR(5));DESC test_char1;INSERT INTO test_char1VALUES(&#39;a&#39;,&#39;Tom&#39;);SELECT c1,CONCAT(c2,&#39;***&#39;) FROM test_char1;INSERT INTO test_char1(c2)VALUES(&#39;a &#39;);SELECT CHAR_LENGTH(c2)FROM test_char1;VARCHAR类型： VARCHAR(M) 定义时， 必须指定 长度M，否则报错。 MySQL4.0版本以下，varchar(20)：指的是20字节，如果存放UTF8汉字时，只能存6个（每个汉字3字 节） ；MySQL5.0版本以上，varchar(20)：指的是20字符。 检索VARCHAR类型的字段数据时，会保留数据尾部的空格。VARCHAR类型的字段所占用的存储空间 为字符串实际长度加1个字节。CREATE TABLE test_varchar1( NAME VARCHAR #错误);#Column length too big for column &#39;NAME&#39; (max = 21845);CREATE TABLE test_varchar2( NAME VARCHAR(65535) #错误);CREATE TABLE test_varchar3( NAME VARCHAR(5));INSERT INTO test_varchar3VALUES(&#39;尚硅谷&#39;),(&#39;尚硅谷教育&#39;);#Data too long for column &#39;NAME&#39; at row 1INSERT INTO test_varchar3VALUES(&#39;尚硅谷IT教育&#39;);哪些情况使用 CHAR 或 VARCHAR 更好 类型 特点 空间上 时间上 适用场景 CHAR(M) 固定长度 浪费存储空间 效率高 存储不大，速度要求高 VARCHAR(M) 可变长度 节省存储空间 效率低 非CHAR的情况 情况1：存储很短的信息。比如门牌号码101，201……这样很短的信息应该用char，因为varchar还要占个 byte用于存储信息长度，本来打算节约存储的，结果得不偿失。情况2：固定长度的。比如使用uuid作为主键，那用char应该更合适。因为他固定长度，varchar动态根据 长度的特性就消失了，而且还要占个长度信息。情况3：十分频繁改变的column。因为varchar每次存储都要有额外的计算，得到长度等工作，如果一个 非常频繁改变的，那就要有很多的精力用于计算，而这些对于char来说是不需要的。情况4：具体存储引擎中的情况： MyISAM 数据存储引擎和数据列：MyISAM数据表，最好使用固定长度(CHAR)的数据列代替可变长度(VARCHAR)的数据列。这样使得整个表静态化，从而使 数据检索更快 ，用空间换时间。 MEMORY 存储引擎和数据列：MEMORY数据表目前都使用固定长度的数据行存储，因此无论使用 CHAR或VARCHAR列都没有关系，两者都是作为CHAR类型处理的。 InnoDB 存储引擎，建议使用VARCHAR类型。因为对于InnoDB数据表，内部的行存储格式并没有区 分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），而且主要影响性能的因素 是数据行使用的存储总量，由于char平均占用的空间多于varchar，所以除了简短并且固定长度的， 其他考虑varchar。这样节省空间，对磁盘I/O和数据存储总量比较好。7.2 TEXT类型​ 在MySQL中，TEXT用来保存文本类型的字符串，总共包含4种类型，分别为TINYTEXT、TEXT、 MEDIUMTEXT 和 LONGTEXT 类型。 在向TEXT类型的字段保存和查询数据时，系统自动按照实际长度存储，不需要预先定义长度。这一点和 VARCHAR类型相同。 每种TEXT类型保存的数据长度和所占用的存储空间不同，如下： 文本字符串类型 值的长度 长度范围 占用的存储空间 TINYTEXT L 0&amp;lt;=L&amp;lt;=255 L+2个字节 TEXT L 0&amp;lt;=L&amp;lt;=65535 L+2个字节 MEDIUMTEXT L 0&amp;lt;=L&amp;lt;=16777215 L+3个字节 LONGTEXT L 0&amp;lt;=L&amp;lt;=4294967295 L+4个字节 由于实际存储的长度不确定，MySQL 不允许 TEXT 类型的字段做主键。遇到这种情况，你只能采用 CHAR(M)，或者 VARCHAR(M)。创建数据表：CREATE TABLE test_text( tx TEXT);INSERT INTO test_textVALUES(&#39;atguigu &#39;);SELECT CHAR_LENGTH(tx)FROM test_text; #10说明在保存和查询数据时，并没有删除TEXT类型的数据尾部的空格。开发中经验：​ TEXT文本类型，可以存比较大的文本段，搜索速度稍慢，因此如果不是特别大的内容，建议使用CHAR， VARCHAR来代替。还有TEXT类型不用加默认值，加了也没用。而且text和blob类型的数据删除后容易导致 “空洞”，使得文件碎片比较多，所以频繁使用的表不建议包含TEXT类型字段，建议单独分出去，单独用 一个表。8. ENUM类型​ ENUM类型也叫作枚举类型，ENUM类型的取值范围需要在定义字段时进行指定。设置字段值时，ENUM 类型只允许从成员中选取单个值，不能一次选取多个值。 其所需要的存储空间由定义ENUM类型时指定的成员个数决定。 文本字符串类型 值的长度 长度范围 占用的存储空间 ENUM L 1&amp;lt;=L&amp;lt;=65535 1或2个字节 当ENUM类型包含1～255个成员时，需要1个字节的存储空间； 当ENUM类型包含256～65535个成员时，需要2个字节的存储空间。 ENUM类型的成员个数的上限为65535个。举例：创建表如下：CREATE TABLE test_enum( season ENUM(&#39;春&#39;,&#39;夏&#39;,&#39;秋&#39;,&#39;冬&#39;,&#39;unknow&#39;));添加数据：INSERT INTO test_enumVALUES(&#39;春&#39;),(&#39;秋&#39;);# 忽略大小写INSERT INTO test_enumVALUES(&#39;UNKNOW&#39;);# 允许按照角标的方式获取指定索引位置的枚举值INSERT INTO test_enumVALUES(&#39;1&#39;),(3);# Data truncated for column &#39;season&#39; at row 1INSERT INTO test_enumVALUES(&#39;ab&#39;);# 当ENUM类型的字段没有声明为NOT NULL时，插入NULL也是有效的INSERT INTO test_enumVALUES(NULL);9. SET类型​ SET表示一个字符串对象，可以包含0个或多个成员，但成员个数的上限为 64 。设置字段值时，可以取 取值范围内的 0 个或多个值。 当SET类型包含的成员个数不同时，其所占用的存储空间也是不同的，具体如下： 成员个数范围（L表示实际成员个数） 占用的存储空间 1 &amp;lt;= L &amp;lt;= 8 1个字节 9 &amp;lt;= L &amp;lt;= 16 2个字节 17 &amp;lt;= L &amp;lt;= 24 3个字节 25 &amp;lt;= L &amp;lt;= 32 4个字节 33 &amp;lt;= L &amp;lt;= 64 8个字节 SET类型在存储数据时成员个数越多，其占用的存储空间越大。注意：SET类型在选取成员时，可以一次 选择多个成员，这一点与ENUM类型不同。举例： 创建表： CREATE TABLE test_set( s SET (&#39;A&#39;, &#39;B&#39;, &#39;C&#39;) );INSERT INTO test_set (s) VALUES (&#39;A&#39;), (&#39;A,B&#39;);#插入重复的SET类型成员时，MySQL会自动删除重复的成员INSERT INTO test_set (s) VALUES (&#39;A,B,C,A&#39;);#向SET类型的字段插入SET成员中不存在的值时，MySQL会抛出错误。INSERT INTO test_set (s) VALUES (&#39;A,B,C,D&#39;);SELECT *FROM test_set;10. 二进制字符串类型MySQL中的二进制字符串类型主要存储一些二进制数据，比如可以存储图片、音频和视频等二进制数据。MySQL中支持的二进制字符串类型主要包括BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB类型。BINARY与VARBINARY类型​ BINARY和VARBINARY类似于CHAR和VARCHAR，只是它们存储的是二进制字符串。​ BINARY (M)为固定长度的二进制字符串，M表示最多能存储的字节数，取值范围是0~255个字符。如果未 指定(M)，表示只能存储 1个字节 。例如BINARY (8)，表示最多能存储8个字节，如果字段值不足(M)个字 节，将在右边填充’\\0’以补齐指定长度。​ VARBINARY (M)为可变长度的二进制字符串，M表示最多能存储的字节数，总字节数不能超过行的字节长 度限制65535，另外还要考虑额外字节开销，VARBINARY类型的数据除了存储数据本身外，还需要1或2个 字节来存储数据的字节数。VARBINARY类型 必须指定(M) ，否则报错。 二进制字符串类型 特点 值的长度 占用空间 BINARY(M) 固定长度 M （0 &amp;lt;= M &amp;lt;= 255） M个字节 VARBINARY(M) 可变长度 M（0 &amp;lt;= M &amp;lt;= 65535） M+1个字节 CREATE TABLE test_binary1( f1 BINARY, f2 BINARY(3), # f3 VARBINARY, f4 VARBINARY(10));INSERT INTO test_binary1(f1,f2)VALUES(&#39;a&#39;,&#39;a&#39;);INSERT INTO test_binary1(f1,f2)VALUES(&#39;尚&#39;,&#39;尚&#39;);#失败INSERT INTO test_binary1(f2,f4)VALUES(&#39;ab&#39;,&#39;ab&#39;);mysql&amp;gt; SELECT LENGTH(f2),LENGTH(f4)-&amp;gt; FROM test_binary1;+------------+------------+| LENGTH(f2) | LENGTH(f4) |+------------+------------+| 3 | NULL || 3 | 2 |+------------+------------+2 rows in set (0.00 sec)**BLOB类型 **​ BLOB是一个 二进制大对象 ，可以容纳可变数量的数据。 MySQL中的BLOB类型包括TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB 4种类型，它们可容纳值的最大 长度不同。可以存储一个二进制的大对象，比如 图片 、 音频 和 视频 等。 需要注意的是，在实际工作中，往往不会在MySQL数据库中使用BLOB类型存储大对象数据，通常会将图 片、音频和视频文件存储到 服务器的磁盘上 ，并将图片、音频和视频的访问路径存储到MySQL中。 二进制字符串类型 值的长度 长度范围 占用空间 TINYBLOB L 0=&amp;lt;L&amp;lt;=255 L+1个字节 BLOB L 0=&amp;lt;L&amp;lt;=65535(相当于64kb) L+2个字节 MEDIUMBLOB L 0=&amp;lt;L&amp;lt;=16777215(相当于16MB) L+3个字节 TINYBLOB L 0=&amp;lt;L&amp;lt;=4294967295(相当于4GB) L+4个字节 CREATE TABLE test_blob1( id INT, img MEDIUMBLOB);TEXT和BLOB的使用注意事项：在使用text和blob字段类型时要注意以下几点，以便更好的发挥数据库的性能。① BLOB和TEXT值也会引起自己的一些问题，特别是执行了大量的删除或更新操作的时候。删除这种值 会在数据表中留下很大的” 空洞 “，以后填入这些”空洞”的记录可能长度不同。为了提高性能，建议定期 使用 OPTIMIZE TABLE 功能对这类表进行 碎片整理 。② 如果需要对大文本字段进行模糊查询，MySQL 提供了 前缀索引 。但是仍然要在不必要的时候避免检 索大型的BLOB或TEXT值。例如，SELECT * 查询就不是很好的想法，除非你能够确定作为约束条件的 WHERE子句只会找到所需要的数据行。否则，你可能毫无目的地在网络上传输大量的值。③ 把BLOB或TEXT列 分离到单独的表 中。在某些环境中，如果把这些数据列移动到第二张数据表中，可 以让你把原数据表中的数据列转换为固定长度的数据行格式，那么它就是有意义的。这会 减少主表中的 碎片 ，使你得到固定长度数据行的性能优势。它还使你在主数据表上运行 SELECT * 查询的时候不会通过 网络传输大量的BLOB或TEXT值。11. JSON 类型​ JSON（JavaScript Object Notation）是一种轻量级的数据交换格式 。简洁和清晰的层次结构使得 JSON 成 为理想的数据交换语言。它易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效 率。JSON 可以将 JavaScript 对象中表示的一组数据转换为字符串，然后就可以在网络或者程序之间轻 松地传递这个字符串，并在需要的时候将它还原为各编程语言所支持的数据格式。​ 在MySQL 5.7中，就已经支持JSON数据类型。在MySQL 8.x版本中，JSON类型提供了可以进行自动验证的 JSON文档和优化的存储结构，使得在MySQL中存储和读取JSON类型的数据更加方便和高效。 创建数据 表，表中包含一个JSON类型的字段 js 。CREATE TABLE test_json( js json);向表中插入JSON数据。INSERT INTO test_json (js)VALUES (&#39;{&quot;name&quot;:&quot;songhk&quot;, &quot;age&quot;:18, &quot;address&quot;:{&quot;province&quot;:&quot;beijing&quot;, &quot;city&quot;:&quot;beijing&quot;}}&#39;);查询t19表中的数据。mysql&amp;gt; SELECT * FROM test_json;mysql&amp;gt; SELECT js -&amp;gt; &#39;$.name&#39; AS NAME,js -&amp;gt; &#39;$.age&#39; AS age ,js -&amp;gt; &#39;$.address.province&#39;AS province, js -&amp;gt; &#39;$.address.city&#39; AS city-&amp;gt; FROM test_json;+----------+------+-----------+-----------+| NAME | age | province | city |+----------+------+-----------+-----------+| &quot;songhk&quot; | 18 | &quot;beijing&quot; | &quot;beijing&quot; |+----------+------+-----------+-----------+1 row in set (0.00 sec)通过-&amp;gt;和-&amp;gt;&amp;gt;符号，从JSON字段中正确查询出了指定的JSON数据的值。12. 空间类型​ MySQL 空间类型扩展支持地理特征的生成、存储和分析。​ 这里的地理特征表示世界上具有位置的任何东 西，可以是一个实体，例如一座山；可以是空间，例如一座办公楼；也可以是一个可定义的位置，例如 一个十字路口等等。MySQL中使用 Geometry（几何） 来表示所有地理特征。Geometry指一个点或点的 集合，代表世界上任何具有位置的事物。 MySQL的空间数据类型（Spatial Data Type）对应于OpenGIS类，包括单值类型：GEOMETRY、POINT、 LINESTRING、POLYGON以及集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、 GEOMETRYCOLLECTION 。 Geometry是所有空间集合类型的基类，其他类型如POINT、LINESTRING、POLYGON都是Geometry的 子类。 Point，顾名思义就是点，有一个坐标值。例如POINT(121.213342 31.234532)，POINT(30 10)， 坐标值支持DECIMAL类型，经度（longitude）在前，维度（latitude）在后，用空格分隔。 LineString，线，由一系列点连接而成。如果线从头至尾没有交叉，那就是简单的 （simple）；如果起点和终点重叠，那就是封闭的（closed）。例如LINESTRING(30 10,10 30,40 40)，点与点之间用逗号分隔，一个点中的经纬度用空格分隔，与POINT格式一致。 Polygon，多边形。可以是一个实心平面形，即没有内部边界，也可以有空洞，类似纽扣。最 简单的就是只有一个外边界的情况，例如POLYGON((0 0,10 0,10 10, 0 10))。 下面展示几种常见的几何图形元素：MultiPoint、MultiLineString、MultiPolygon、GeometryCollection 这4种类型都是集合类，是多个 Point、LineString或Polygon组合而成。下面展示的是多个同类或异类几何图形元素的组合：13. 小结及选择建议​ 在定义数据类型时，1. 如果确定是 整数 ，就用 INT ； 2. 如果是 小数 ，一定用定点数类型 DECIMAL(M,D) ； 3. 如果是日期与时间，就用 DATETIME 。 这样做的好处是，首先确保你的系统不会因为数据类型定义出错。不过，凡事都是有两面的，可靠性 好，并不意味着高效。比如，TEXT 虽然使用方便，但是效率不如 CHAR(M) 和 VARCHAR(M)。 关于字符串的选择，建议参考如下阿里巴巴的《Java开发手册》规范：阿里巴巴《Java开发手册》之MySQL数据库： 任何字段如果为非负数，必须是 UNSIGNED 【 强制 】小数类型为 DECIMAL，禁止使用 FLOAT 和 DOUBLE。 说明：在存储的时候，FLOAT 和 DOUBLE 都存在精度损失的问题，很可能在比较值的时候，得 到不正确的结果。如果存储的数据范围超过 DECIMAL 的范围，建议将数据拆成整数和小数并 分开存储。 【 强制 】如果存储的字符串长度几乎相等，使用 CHAR 定长字符串类型。 【 强制 】VARCHAR 是可变长字符串，不预先分配存储空间，长度不要超过 5000。如果存储长度大 于此值，定义字段类型为 TEXT，独立出来一张表，用主键来对应，避免影响其它字段索引效率" }, { "title": "MySQL数据处理之增删改", "url": "/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8B%E5%A2%9E%E5%88%A0%E6%94%B9/", "categories": "数据库", "tags": "MySQL", "date": "2021-06-11 00:00:00 +0800", "snippet": "1.插入数据1.1 插入数据解决方式：使用 INSERT 语句向表中插入数据。1.2 插入方式方式1：VALUES的方式添加使用这种语法一次只能向表中插入一条数据。情况1：为表的所有字段按默认顺序插入数据INSERT INTO 表名VALUES (value1,value2,....);值列表中需要为表的每一个字段指定值，并且值的顺序必须和数据表中字段定义时的顺序相同。INSERT INTO departmentsVALUES (70, &#39;Pub&#39;, 100, 1700);INSERT INTO departmentsVALUES (100, &#39;Finance&#39;, NULL, NULL);INSERT INTO 表名(column1 [, column2, …, columnn])VALUES (value1 [,value2, …, valuen]);情况2 ：为指定列添加数据为表的指定字段插入数据，就是在INSERT语句中只向部分字段中插入值，而其他字段的值为表定义时的默认值。​ 在 INSERT 子句中随意列出列名，但是一旦列出，VALUES中要插入的value1,….valuen需要与 column1,…columnn列一一对应。如果类型不同，将无法插入，并且MySQL会产生错误。INSERT INTO departments(department_id, department_name)VALUES (80, &#39;IT&#39;);情况3：同时插入多条记录INSERT语句可以同时向数据表中插入多条记录，插入时指定多个值列表，每个值列表之间用逗号分隔 开，基本语法格式如下：INSERT INTO table_nameVALUES(value1 [,value2, …, valuen]),(value1 [,value2, …, valuen]),……(value1 [,value2, …, valuen]);或者INSERT INTO table_name(column1 [, column2, …, columnn])VALUES(value1 [,value2, …, valuen]),(value1 [,value2, …, valuen]),……(value1 [,value2, …, valuen]);举例：mysql&amp;gt; INSERT INTO emp(emp_id,emp_name)VALUES (1001,&#39;shkstart&#39;), (1002,&#39;atguigu&#39;), (1003,&#39;Tom&#39;);Query OK, 3 rows affected (0.00 sec)Records: 3 Duplicates: 0 Warnings: 0使用INSERT同时插入多条记录时，MySQL会返回一些在执行单行插入时没有的额外信息，这些信息的含 义如下：●　Records：表明插入的记录条数。●　Duplicates：表明插入时被忽略的记录，原因可能是这 些记录包含了重复的主键值。●　Warnings：表明有问题的数据值，例如发生数据类型转换。一个同时插入多行记录的INSERT语句等同于多个单行插入的INSERT语句，但是多行的INSERT语句 在处理过程中 效率更高 。因为MySQL执行单条INSERT语句插入多行数据比使用多条INSERT语句 快，所以在插入多条记录时最好选择使用单条INSERT语句的方式插入。小结： VALUES 也可以写成 VALUE ，但是VALUES是标准写法。INSERT还可以将SELECT语句查询的结果插入到表中，此时不需要把每一条记录的值一个一个输入，只需 要使用一条INSERT语句和一条SELECT语句组成的组合语句即可快速地从一个或多个表中向一个表中插入 多行。基本语法格式如下：INSERT INTO 目标表名(tar_column1 [, tar_column2, …, tar_columnn])SELECT(src_column1 [, src_column2, …, src_columnn])FROM 源表名[WHERE condition] 在 INSERT 语句中加入子查询。 不必书写 VALUES 子句。 子查询中的值列表应与 INSERT 子句中的列名对应。举例：INSERT INTO emp2SELECT *FROM employeesWHERE department_id = 90;INSERT INTO sales_reps(id, name, salary, commission_pct)SELECT employee_id, last_name, salary, commission_pctFROM employeesWHERE job_id LIKE &#39;%REP%&#39;2. 更新数据使用 UPDATE 语句更新数据。语法如下：[WHERE condition] 可以一次更新多条数据。 如果需要回滚数据，需要保证在DML前，进行设置：SET AUTOCOMMIT = FALSE;使用 WHERE 子句指定需要更新的数据。UPDATE employeesSET department_id = 70WHERE employee_id = 113;如果省略 WHERE 子句，则表中的所有数据都将被更新。UPDATE copy_empSET department_id = 110;更新中的数据完整性错误UPDATE employeesSET department_id = 55WHERE department_id = 110;说明：不存在 55 号部门，导致删除失败3. 删除数据DELETE FROM table_name [WHERE &amp;lt;condition&amp;gt;];table_name指定要执行删除操作的表；“[WHERE ]”为可选参数，指定删除条件，如果没有WHERE子句， DELETE语句将删除表中的所有记录。使用 WHERE 子句删除指定的记录。DELETE FROM departmentsWHERE department_name = &#39;Finance&#39;;如果省略 WHERE 子句，则表中的全部数据将被删除DELETE FROM copy_emp;DELETE FROM departmentsWHERE department_id = 60;说明：You cannot delete a row that contains a primary key that is used as a foreign key in another table.4. MySQL8新特性：计算列​ 什么叫计算列呢？简单来说就是某一列的值是通过别的列计算得来的。例如，a列值为1、b列值为2，c列 不需要手动插入，定义a+b的结果为c的值，那么c就是计算列，是通过别的列计算得来的。​ 在MySQL 8.0中，CREATE TABLE 和 ALTER TABLE 中都支持增加计算列。下面以CREATE TABLE为例进行讲 解。举例：定义数据表tb1，然后定义字段id、字段a、字段b和字段c，其中字段c为计算列，用于计算a+b的 值。 首先创建测试表tb1，语句如下：CREATE TABLE tb1( id INT, a INT, b INT, c INT GENERATED ALWAYS AS (a + b) VIRTUAL);查询数据表tb1中的数据，结果如下：mysql&amp;gt; SELECT * FROM tb1;+------+------+------+------+| id | a | b | c |+------+------+------+------+| NULL | 100 | 200 | 300 |+------+------+------+------+1 row in set (0.00 sec)更新数据中的数据，语句如下：mysql&amp;gt; UPDATE tb1 SET a = 500;Query OK, 0 rows affected (0.00 sec)Rows matched: 1 Changed: 0 Warnings: 05.综合案例# 1、创建数据库test01_libraryCREATE DATABASE `test01_library` IF NOT EXISTS CHARACTER SET &#39;utf8&#39;;USE test01_library;# 2、创建表 books，表结构如下：CREATE TABLE IF NOT EXISTS books( id INT, name VARCHAR(50), `authors` VARCHAR(100) , price FLOAT, pubdate YEAR , note VARCHAR(100), num INT);# 3、向books表中插入记录# 1）不指定字段名称，插入第一条记录INSERT INTO booksVALUES(1,&#39;Tal of AAA&#39;,&#39;Dickes&#39;,23,1995,&#39;novel&#39;,11);# 2）指定所有字段名称，插入第二记录INSERT INTO booksVALUES(1,&#39;Tal of AAA&#39;,&#39;Dickes&#39;,23,1995,&#39;novel&#39;,11);# 3）同时插入多条记录（剩下的所有记录）INSERT INTO books (id,name,`authors`,price,pubdate,note,num) VALUES(3,&#39;Story of Jane&#39;,&#39;Jane Tim&#39;,40,2001,&#39;novel&#39;,0),(4,&#39;Lovey Day&#39;,&#39;George Byron&#39;,20,2005,&#39;novel&#39;,30),(5,&#39;Old land&#39;,&#39;Honore Blade&#39;,30,2010,&#39;Law&#39;,0),(6,&#39;The Battle&#39;,&#39;Upton Sara&#39;,30,1999,&#39;medicine&#39;,40),(7,&#39;Rose Hood&#39;,&#39;Richard haggard&#39;,28,2008,&#39;cartoon&#39;,28);# 4、将小说类型(novel)的书的价格都增加5。UPDATE books SET price=price+5 WHERE note = &#39;novel&#39;;# 5、将名称为EmmaT的书的价格改为40，并将说明改为drama。UPDATE books SET price=40,note=&#39;drama&#39; WHERE name=&#39;EmmaT&#39;;# 6、删除库存为0的记录。DELETE FROM books WHERE num=0;# 7、统计书名中包含a字母的书SELECT * FROM books WHERE name LIKE &#39;%a%&#39;;# 8、统计书名中包含a字母的书的数量和库存总量SELECT COUNT(*),SUM(num) FROM books WHERE name LIKE &#39;%a%&#39;;# 9、找出“novel”类型的书，按照价格降序排列SELECT * FROM books WHERE note = &#39;novel&#39; ORDER BY price DESC;# 10、查询图书信息，按照库存量降序排列，如果库存量相同的按照note升序排列SELECT * FROM books ORDER BY num DESC,note ASC;# 11、按照note分类统计书的数量SELECT note,COUNT(*) FROM books GROUP BY note;# 12、按照note分类统计书的库存量，显示库存量超过30本的SELECT note,count(*)FROM booksGROUP BY note HAVING sum(num)&amp;gt;30;# 13、查询所有图书，每页显示5本，显示第二页SELECT * FROM books LIMIT 5,5;# 14、按照note分类统计书的库存量，显示库存量最多的SELECT note,SUM(num) sum_num FROM books GROUP BY note ORDER BY sum_num DESC LIMIT 0,1;# 15、查询书名达到10个字符的书，不包括里面的空格SELECT * FROM books WHERE CHAR_LENGTH(REPLACE(name,&#39; &#39;,&#39;&#39;))&amp;gt;=10;/*16、查询书名和类型，其中note值为 novel显示小说，law显示法律，medicine显示医药，cartoon显示卡通，joke显示笑话*/SELECT name AS &quot;书名&quot; ,note, CASE noteWHEN &#39;novel&#39; THEN &#39;小说&#39;WHEN &#39;law&#39; THEN &#39;法律&#39;WHEN &#39;medicine&#39; THEN &#39;医药&#39;WHEN &#39;cartoon&#39; THEN &#39;卡通&#39;WHEN &#39;joke&#39; THEN &#39;笑话&#39;END AS &quot;类型&quot;FROM books;# 17、查询书名、库存，其中num值超过30本的，显示滞销，大于0并低于10的，显示畅销，为0的显示需要无货SELECT name,num,CASEWHEN num&amp;gt;30 THEN &#39;滞销&#39;WHEN num&amp;gt;0 AND num&amp;lt;10 THEN &#39;畅销&#39;WHEN num=0 THEN &#39;无货&#39;ELSE &#39;正常&#39;END AS &quot;库存状态&quot;FROM books;# 18、统计每一种note的库存量，并合计总量SELECT IFNULL(note,&#39;合计总库存量&#39;) AS note,SUM(num) FROM books GROUP BY note WITHROLLUP;# 19、统计每一种note的数量，并合计总量(这个用到了rollup)SELECT IFNULL(note,&#39;合计总数&#39;) AS note,COUNT(*) FROM books GROUP BY note WITH ROLLUP;# 20、统计库存量前三名的图书SELECT * FROM books ORDER BY num DESC LIMIT 0,3;# 21、找出最早出版的一本书SELECT * FROM books ORDER BY pubdate ASC LIMIT 0,1;# 22、找出novel中价格最高的一本书SELECT * FROM books WHERE note = &#39;novel&#39; ORDER BY price DESC LIMIT 0,1;# 23、找出书名中字数最多的一本书，不含空格SELECT * FROM books ORDER BY CHAR_LENGTH(REPLACE(name,&#39; &#39;,&#39;&#39;)) DESC LIMIT 0,1;6.课后练习# 1.创建数据库dbtest11CREATE DATABASE IF NOT EXISTS dbtest11 CHARACTER SET &#39;utf8&#39;;# 2.创建my_employees表USE(dbtest11)CREATE TABLE my_employees( id INT(10), first_name VARCHAR(10), last_name VARCHAR(10), userid VARCHAR(10), salary DOUBLE(10,2));CREATE TABLE users( id INT, userid VARCHAR(10), department_id INT);# 3. 显示表my_employees结构DESC my_employees;# 4. 向my_employees表中插入数据INSERT INTO my_employees VALUES(1,&#39;Rpatel&#39;,&#39;Ralph&#39;,&#39;Rpatel&#39;,895),(2,&#39;Dancs&#39;,&#39;Betty&#39;,&#39;Bancs&#39;,860),(3,&#39;Biri&#39;,&#39;Ben&#39;,&#39;Bbiri&#39;,1100),(4,&#39;Newman&#39;,&#39;Chad&#39;,&#39;Cnewman&#39;,750),(5,&#39;Ropeburn&#39;,&#39;Audery&#39;,&#39;Aropebur&#39;,1100);#5.向user表中插入数据INSERT INTO users VALUES (1,&#39;Rpatel&#39;,10),(2,&#39;Bdancs&#39;,10),(3,&#39;Bbiri&#39;,20),(4,&#39;Cnewman&#39;,30),(5,&#39;Aropebur&#39;,40);# 6.将3号员工的last_name修改为&#39;drelxer&#39;UPDATE my_employees SET last_name = &quot;drelxer&quot;WHERE id = 3;# 7. 将所有工资少于900的员工工资修改为1000UPDATE my_employeesSET salary = 1000WHERE salary &amp;lt; 900；# 8.将userid为Bbiri的users表和my_employees表的记录全部删除DELETE FROM my_employeesWHERE userid = &#39;Bbiri&#39;;DELETE FROM userid WHERE userid = &#39;Bbiri&#39;;# 9.删除my_employees、users表中的所有数据DELETE FROM my_employees;DELETE FROM users;# 10. 检查是否已经删除SELECT * FROM my_employees;SELECT * FROM users;# 11.清空表my_employeesTRUNCATE TABLE my_employees;# 1. 使用现有数据库dbtest11USE dbtest11;# 2. 创建表格petCREATE TABLE pet( NAME VARCHAR(20), OWNER VARCHAR(20), species VARCHAR(20), sex CHAR(1), birth YEAR, death YEAR);DESC pet;# 3. 添加记录INSERT INTO pet VALUES(&#39;Fuffy&#39;,&#39;harold&#39;,&#39;Cat&#39;,&#39;f&#39;,&#39;2003&#39;,&#39;2010&#39;),(&#39;Claws&#39;,&#39;gwen&#39;,&#39;Cat&#39;,&#39;f&#39;,&#39;2009&#39;,NULL),(&#39;Buffy&#39;,NULL,&#39;Dog&#39;,&#39;m&#39;,&#39;2000&#39;,NULL),(&#39;Fang&#39;,&#39;benny&#39;,&#39;Dog&#39;,&#39;m&#39;,&#39;2009&#39;,NULL),(&#39;bowser&#39;,&#39;dianen&#39;,&#39;Dog&#39;,&#39;m&#39;,&#39;2003&#39;,&#39;2009&#39;);# 4.添加字段：主人生日 own_birth DATE 类型ALTER TABLE petADD own_birth DATE;# 5. 将名称为Claws的猫的主人修改为KevinUPDATE petSET OWNER = &#39;Kevin&#39;WHERE NAME = &#39;Claws&#39; AND species = &#39;Cat&#39;;# 6.将没有死的狗的主人改为duckUPDATE petSET OWNER = &#39;duck&#39;WHERE death IS NOT NULL AND species = &#39;Dog&#39;;# 7.查询没有主人的宠物的名字SELECT NAME FROM petWHERE OWNER IS NULL;# 8.查询已经死了的cat的姓名、主人、去世时间SELECT NAME,OWNER,deathFROM petWHERE death IS NOT NULL AND species IS &#39;Dog&#39;;# 9.删除已经死亡的狗DELETE FROM petWHERE death IS NOT NULLAND species IS &#39;Dog&#39;;# 10. 查询所有宠物信息SELECT * FROM pet;# 1. 使用dbtest11数据库USE dbtest11;# 2.创建表employee，并添加记录CREATE TABLE employee( id INT, sex CHAR(1), tel VARCHAR(35), addr VARCHAR(34), salary DOUBLE(10,2));INSERT INTO employee VALUES(10001,&#39;张一一&#39;,&#39;男&#39;,&#39;13522262227&#39;,&#39;山东青岛&#39;，1000.25),(10002,&#39;刘晓红&#39;,&#39;女&#39;,&#39;13533262223&#39;,&#39;河北保定&#39;，1201.25),(10003,&#39;李四&#39;,&#39;男&#39;,&#39;0760-21251255&#39;,&#39;广东中山&#39;，2000.25),(10001,&#39;刘小强&#39;,&#39;男&#39;,&#39;0755-5555555&#39;,&#39;广东深圳&#39;，5000.25);# 3.查询处薪资在1200-1300之间的员工信息SELECT * FROM employeeWHERE salary BETWEEN 1200 AND 1300;# 4. 查询处姓&quot;刘&quot;的员工的姓名、工号、家庭地址SELECT NAME,id,addrFROM employeeWHERE NAME LIKE &quot;刘%&quot;;# 5.将“李四”的家庭住址改为“广东韶关”UPDATE employeeSET addr=&quot;广东韶关&quot;WHERE NAME = &quot;李四&quot;;# 6.查询名字中带有“小”的员工信息SELECT * FROM employeeWHERE NAME LIKE &quot;%小%&quot;;" }, { "title": "MySQL创建、修改与删除", "url": "/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E5%88%9B%E5%BB%BA-%E4%BF%AE%E6%94%B9%E4%B8%8E%E5%88%A0%E9%99%A4/", "categories": "数据库", "tags": "MySQL", "date": "2021-06-10 00:00:00 +0800", "snippet": "1. 基础知识1.1 一条数据存储的过程​ 存储数据是处理数据的第一步 。只有正确地把数据存储起来，我们才能进行有效的处理和分析。否则，只 能是一团乱麻，无从下手。 那么，怎样才能把用户各种经营相关的、纷繁复杂的数据，有序、高效地存储起来呢？ 在 MySQL 中， 一个完整的数据存储过程总共有 4 步，分别是创建数据库、确认字段、创建数据表、插入数据我们要先创建一个数据库，而不是直接创建数据表呢？​ 因为从系统架构的层次上看，MySQL 数据库系统从大到小依次是 数据库服务器 、 数据库 、 数据表 、数 据表的 行与列 。 MySQL 数据库服务器之前已经安装。所以，我们就从创建数据库开始。1.2 标识符命名规则 数据库名、表名不得超过30个字符，变量名限制为29个 必须只能包含 A–Z, a–z, 0–9, _共63个字符 数据库名、表名、字段名等对象名中间不要包含空格 同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名 必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使用`（着重号）引起来 保持字段名和类型的一致性：在命名字段并为其指定数据类型的时候一定要保证一致性，假如数据 类型在一个表里是整数，那在另一个表里可就别变成字符型了1.3 MySQL中的数据类型其中，常用的几类类型介绍如下：2. 创建和管理数据库2.1 创建数据库方式1：创建数据库CREATE DATABASE 数据库名;方式2：创建数据库并指定字符集CREATE DATABASE 数据库名 CHARACTER SET 字符集;方式3：判断数据库是否已经存在，不存在则创建数据库（ 推荐 ）CREATE DATABASE IF NOT EXISTS 数据库名;如果MySQL中已经存在相关的数据库，则忽略创建语句，不再创建数据库。注意：DATABASE 不能改名。一些可视化工具可以改名，它是建新库，把所有表复制到新库，再删 旧库完成的。2.2 使用数据库查看当前所有的数据库SHOW DATABASES; #有一个S，代表多个数据库查看当前正在使用的数据库SELECT DATABASE(); #使用的一个 mysql 中的全局函数查看指定库下所有的表SHOW TABLES FROM 数据库名;查看数据库的创建信息SHOW CREATE DATABASE 数据库名;或者：SHOW CREATE DATABASE 数据库名\\G使用/切换数据库USE 数据库名;2.3 修改数据库更改数据库字符集ALTER DATABASE 数据库名 CHARACTER SET 字符集; #比如：gbk、utf8等2.4 删除数据库方式1：删除指定的数据库DROP DATABASE 数据库名;方式2：删除指定的数据库（ 推荐 ）DROP DATABASE IF EXISTS 数据库名;3. 创建表3.1 创建方式1必须具备： CREATE TABLE权限 存储空间CREATE TABLE [IF NOT EXISTS] 表名( 字段1, 数据类型 [约束条件] [默认值], 字段2, 数据类型 [约束条件] [默认值], 字段3, 数据类型 [约束条件] [默认值], …… [表约束条件]);加上了IF NOT EXISTS关键字，则表示：如果当前数据库中不存在要创建的数据表，则创建数据表； 如果当前数据库中已经存在要创建的数据表，则忽略建表语句，不再创建数据表。必须指定： 表名 列名(或字段名)，数据类型，长度可选指定： 约束条件 默认值 创建表举例1：-- 创建表CREATE TABLE emp ( -- int类型 emp_id INT, -- 最多保存20个中英文字符 emp_name VARCHAR(20), -- 总位数不超过15位 salary DOUBLE, -- 日期类型 birthday DATE);​ MySQL在执行建表语句时，将id字段的类型设置为int(11)，这里的11实际上是int类型指定的显示宽度，默认的显示宽度为11。也可以在创建数据表的时候指定数据的显示宽度。举例2：CREATE TABLE dept( -- int类型，自增 deptno INT(2) AUTO_INCREMENT, dname VARCHAR(14), loc VARCHAR(13), -- 主键 PRIMARY KEY (deptno));在MySQL 8.x版本中，不再推荐为INT类型指定显示长度，并在未来的版本中可能去掉这样的语法3.2 创建方式2使用 AS subquery 选项，将创建表和插入数据结合起来 指定的列和子查询中的列要一一对应 通过列名和默认值定义列CREATE TABLE emp1 AS SELECT * FROM employees;CREATE TABLE emp2 AS SELECT * FROM employees WHERE 1=2; -- 创建的emp2是空表,这个就可以复制表结构CREATE TABLE dept80ASSELECT employee_id, last_name, salary*12 ANNSAL, hire_dateFROM employeesWHERE department_id = 80;3.3 查看数据表结构​ 在MySQL中创建好数据表之后，可以查看数据表的结构。MySQL支持使用 DESCRIBE/DESC 语句查看数据 表结构，也支持使用 SHOW CREATE TABLE 语句查看数据表结构。语法格式如下：SHOW CREATE TABLE 表名\\G使用SHOW CREATE TABLE语句不仅可以查看表创建时的详细语句，还可以查看存储引擎和字符编码。4. 修改表修改表指的是修改数据库中已经存在的数据表的结构。使用 ALTER TABLE 语句可以实现： 向已有的表中添加列 修改现有表中的列 删除现有表中的列 重命名现有表中的列4.1 追加一个列语法格式如下：ALTER TABLE 表名 ADD 【COLUMN】 字段名 字段类型 【FIRST|AFTER 字段名】;举例：ALTER TABLE dept80ADD job_id varchar(15)4.2 修改一个列 可以修改列的数据类型，长度、默认值和位置 修改字段数据类型、长度、默认值、位置的语法格式如下：ALTER TABLE 表名 MODIFY 【COLUMN】 字段名1 字段类型 【DEFAULT 默认值】【FIRST|AFTER 字段名2】;ALTER TABLE dept80MODIFY last_name VARCHAR(30);ALTER TABLE dept80MODIFY salary double(9,2) default 1000; 对默认值的修改只影响今后对表的修改 此外，还可以通过此种方式修改列的约束。这里暂先不讲。4.3 重命名一个列使用 CHANGE old_column new_column dataType子句重命名列。语法格式如下：ALTER TABLE 表名 CHANGE 【column】 列名 新列名 新数据类型;ALTER TABLE dept80CHANGE department_name dept_name varchar(15);4.4 删除一个列删除表中某个字段的语法格式如下：ALTER TABLE 表名 DROP 【COLUMN】字段名举例：ALTER TABLE dept80DROP COLUMN job_id;5. 重命名表方式一：使用RENAMERENAME TABLE empTO myemp;方式二：ALTER TABLE deptRENAME [TO] detail_dept; -- [TO]可以省略必须是对象的拥有者6. 删除表 在MySQL中，当一张数据表 没有与其他任何数据表形成关联关系时，可以将当前数据表直接删除。 数据和结构都被删除 所有正在运行的相关事务被提交 所有相关索引被删除语法格式：DROP TABLE [IF EXISTS] 数据表1 [, 数据表2, …, 数据表n];IF EXISTS 的含义为：如果当前数据库中存在相应的数据表，则删除数据表；如果当前数据库中不存 在相应的数据表，则忽略删除语句，不再执行删除数据表的操作。举例：DROP TABLE dept80;DROP TABLE 语句不能回滚7. 清空表TRUNCATE TABLE语句： 删除表中所有的数据 释放表的存储空间举例：TRUNCATE TABLE detail_dept;TRUNCATE语句不能回滚，而使用 DELETE 语句删除数据，可以回滚SET autocommit = FALSE;DELETE FROM emp2;#TRUNCATE TABLE emp2;SELECT * FROM emp2;ROLLBACK;SELECT * FROM emp2;阿里开发规范： 【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无 事务且不触发 TRIGGER，有可能造成事故，故不建议在开发代码中使用此语句。 说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。8. commit和rollbackCOMMIT：数据一旦提交，数据就永久的保存到了数据库中，即不能回滚。ROLLBACK：一旦执行ROLLBACK，则可以实现数据的回滚，回滚到最后一次commit之后。 DDL的操作一旦执行，就不可回滚【因为在执行完DDL之后，会自动执行commit操作，所以不能回滚】 DDL操作默认情况，一旦执行，也是不可以回滚的。但是如果在执行DML之前，执行了set autocommit = False，则执行的DML就可以实现回滚9. 内容拓展**拓展1：阿里巴巴《Java开发手册》之MySQL字段命名 **【 强制 】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出 现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。​ 正例：aliyun_admin，rdc_config，level3_name ​ 反例：AliyunAdmin，rdcConfig，level_3_name 【 强制 】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。【 强制 】表必备三字段：id, gmt_create, gmt_modified。​ 说明：其中 id 必为主键，类型为BIGINT UNSIGNED、单表时自增、步长为 1。gmt_create, gmt_modified 的类型均为 DATETIME 类型，前者现在时表示主动式创建，后者过去分词表示被 动式更新【 推荐 】表的命名最好是遵循 “业务名称_表的作用”。​ ` 正例：alipay_task 、 force_project、 trade_config `【 推荐 】库名与应用名称尽量一致。【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。**拓展2：如何理解清空表、删除表等操作需谨慎？！ **​ 表删除 操作将把表的定义和表中的数据一起删除，并且MySQL在执行删除操作时，不会有任何的确认信 息提示，因此执行删除操时应当慎重。在删除表前，最好对表中的数据进行 备份 ，这样当操作失误时可 以对数据进行恢复，以免造成无法挽回的后果。​ 同样的，在使用 ALTER TABLE 进行表的基本修改操作时，在执行操作过程之前，也应该确保对数据进 行完整的 备份，因为数据库的改变是 无法撤销 的，如果添加了一个不需要的字段，可以将其删除；相同的，如果删除了一个需要的列，该列下面的所有数据都将会丢失。拓展3：MySQL8新特性—DDL的原子化​ 在MySQL 8.0版本中，InnoDB表的DDL支持事务完整性，即 DDL操作要么成功，要么回滚 。DDL操作回滚日志 写入到data dictionary数据字典表mysql.innodb_ddl_log（该表是隐藏的表，通过show tables无法看到） 中，用于回滚操作。通过设置参数，可将DDL操作日志打印输出到MySQL错误日志中。分别在MySQL 5.7版本和MySQL 8.0版本中创建数据库和数据表，结果如下：CREATE DATABASE mytest;USE mytest;CREATE TABLE book1( book_id INT , book_name VARCHAR(255));SHOW TABLES;（1）在MySQL 5.7版本中，测试步骤如下： 删除数据表book1和数据表book2，结果如下：mysql&amp;gt; DROP TABLE book1,book2;ERROR 1051 (42S02): Unknown table &#39;mytest.book2&#39;再次查询数据库中的数据表名称，结果如下：mysql&amp;gt; SHOW TABLES;Empty set (0.00 sec)从结果可以看出，虽然删除操作时报错了，但是仍然删除了数据表book1。（2）在MySQL 8.0版本中，测试步骤如下： 删除数据表book1和数据表book2，结果如下：mysql&amp;gt; DROP TABLE book1,book2;ERROR 1051 (42S02): Unknown table &#39;mytest.book2&#39;再次查询数据库中的数据表名称，结果如下：mysql&amp;gt; show tables;+------------------+| Tables_in_mytest |+------------------+| book1 |+------------------+1 row in set (0.00 sec)从结果可以看出，数据表book1并没有被删除。10.课后练习 创建数据库test01_office，指明字符集为utf-8，并在此数据库下使用CREATE DATABASE IF NOT EXISTS test01_office CHARACTER SET&#39;utf8&#39;; 创建表dept01，字段类型分别为 id （ INT（7））、 NAME(VARCHAR(25))CREATE TABLE dept01 IF NOT EXISTS dept01 ( id INT(7),`NAME` VARCHAR(25)); 将表的department中的数据插入到新表dept02中CREATE TABLE dept02AS SELECT * FROM atguigudb.departments; 创建表emp01，字段类型为：id— INT(7)、first_name—VARCHAR(25)、last_name—VARCHAR(25)、dept_id— INT(7)CREATE TABLE emp01( id INT(7), first_name VARCHAR(25), last_name VARCHAR(25), dept_id INT(7)); 将列last_name的长度增加到50ALTER TABLE emp01 MODIFY last_name VARCHAR(50); 根据表employees创建emp02CREATE TABLE emp02AS SELECT * FROM atguigudb.`employees`; 删除表emp01DROP TABLE emp01; 将表emp02重命名为emp01RENAME TABLE emp02 TO emp01; 在dept02和emp01中添加新列test_column，并检查所有操作ALTER TABLE emp01 ADD test_column VARCHAR(10);DESC emp01;ALTER TABLE dept02 ADD test_column VARCHAR(10);DESC dept02; 直接删除表emp01中的列department_idALTER TABLE emp01DROP COLUMN department_id;11.创建数据库 test02_marketCREATE DATABASE IF NOT EXISTS test02_market CHARACTER SET &#39;utf8&#39;;USE test02_market;SHOW CREATE DATABASE test02_market; 创建数据表CREATE TABLE IF NOT EXISTS customers ( c_num INT, c_name VARCHAR(50), c_contact VARCHAR(50), c_city VARCHAR(50), c_birth DATE);SHOW TABLES; 将customers表中c_name字段移动到c_birth字段后面ALTER TABLE customersMODIFY c_contact VARCHAR(50) AFTER c_birth; 将c_name字段数据类型改为VARCHAR(70)ALTER TABLE customersMODIFY c_name VARCHAR(70); 将c_contact字段改名为c_phoneALTER TABLE customers CHANGE c_contact c_phone VARCHAR(50); 增加c_gender字段到c_name后面，数据类型为char(1)ALTER TABLE customersADD c_gender CHAR(1)AFTER c_name; 将表名改为customers_infoRENAME customers TO customers_info 删除字段c_cityALTER TABLE customers_info DROP COLUMN c_city; 创建数据库test03_companyCREATE DATABASE IF NOT EXISTS test03_company CHARACTER SET &#39;UTF8&#39;;USE test03_company; 创建表officesCREATE TABLE IF NOT EXISTS offices( officeCode INT, city VARCHAR(30), address VARCHAR(50), country VARCHAR(50), postalCode VARCHAR(25));DESC offices; 创建表employeesCREATE TABLE IF NOT EXISTS employees(empNum INT, last_name VARCHAR(50), first_name VARCHAR(50), mobile VARCHAR(25), `code` INT, jobTitle VARCHAR(50), birth DATE, note VARCHAR(255), sex VARCHAR(5)); 将表employees的mobile字段修改到code字段后面ALTER TABLE employeesMODIFY mobile VARCHAR(20) AFTER `code`; 将表employees的birth字段改名为birthdayALTER TABLE employeesCHANGE birth birthday DATE; 修改sex字段，数据类型为CHAR(1)ALTER TABLE employeesMODIFY sex CHAR(1); 删除字段noteALTER TABLE employeesDROP COLUMN note; 增加字段名favorite_activity，数据类型为VARCHAR(100)ALTER TABLE employeesADD favorite_activity VARCHAR(100);参考链接 MySQL数据库教程天花板，mysql安装到mysql高级，强！硬！参考链接 MySQL数据库教程天花板，mysql安装到mysql高级，强！硬！" }, { "title": "MySQL子查询", "url": "/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E5%AD%90%E6%9F%A5%E8%AF%A2/", "categories": "数据库", "tags": "MySQL", "date": "2021-06-09 00:00:00 +0800", "snippet": "​ 子查询指一个查询语句嵌套在另一个查询语句内部的查询，这个特性从MySQL 4.1开始引入。 SQL 中子查询的使用大大增强了 SELECT 查询的能力，因为很多时候查询需要从结果集中获取数据，或者 需要从同一个表中先计算得出一个数据结果，然后与这个数据结果（可能是某个标量，也可能是某个集合）进行比较。1. 需求分析与问题解决1.1 查询谁的工资比Abel高？# 子查询SELECT last_name,salaryFROM employeesWHERE salary &amp;gt; (SELECT salaryFROM employeesWHERE last_name = &#39;Abel&#39;);1.2 子查询的基本使用子查询的基本语法结构： 子查询（内查询）在主查询之前一次执行完成。 子查询的结果被主查询（外查询）使用 。 注意事项 : 子查询要包含在括号内 将子查询放在比较条件的右侧 单行操作符对应单行子查询，多行操作符对应多行子查询 1.3 子查询的分类​ 分类方式1： 我们按内查询的结果返回一条还是多条记录，将子查询分为 单行子查询 、 多行子查询 。​ 分类方式2： 我们按内查询是否被执行多次，将子查询划分为 相关(或关联)子查询 和 不相关(或非关联)子查询 。​ 子查询从数据表中查询了数据结果，如果这个数据结果只执行一次，然后这个数据结果作为主查询的条 件进行执行，那么这样的子查询叫做不相关子查询。​ 同样，如果子查询需要执行多次，即采用循环的方式，先从外部查询开始，每次都传入子查询进行查 询，然后再将结果反馈给外部，这种嵌套的执行方式就称为相关子查询。2. 单行子查询2.1 单行比较操作符 操作符 含义 = equal to &amp;gt; greater than &amp;gt;= greater than or equal to &amp;lt; less than &amp;lt;= less than or equal to &amp;lt;&amp;gt; not equal to 2.2 代码示例题目：查询工资大于149号员工工资的员工的信息题目：返回job_id与141号员工相同，salary比143号员工多的员工姓名，job_id和工资SELECT last_name, job_id, salaryFROM employeesWHERE job_id = (SELECT job_id FROM employees WHERE employee_id = 141)AND salary &amp;gt; (SELECT salary FROM employees WHERE employee_id = 143);题目：返回公司工资最少的员工的last_name,job_id和salarySELECT last_name, job_id, salaryFROM employeesWHERE salary = (SELECT MIN(salary) FROM employees);题目：查询与141号或174号员工的manager_id和department_id相同的其他员工的employee_id， manager_id，department_id实现方式1：不成对比较SELECT employee_id, manager_id, department_idFROM employeesWHERE manager_id IN (SELECT manager_id FROM employees WHERE employee_id IN (174,141))AND department_id IN (SELECT department_id FROM employees WHERE employee_id IN (174,141)) AND employee_id NOT IN(174,141);实现方式2：成对比较SELECT employee_id, manager_id, department_idFROM employeesWHERE (manager_id, department_id) IN (SELECT manager_id, department_id FROM employees WHERE employee_id IN (141,174)) AND employee_id NOT IN (141,174);2.3 HAVING 中的子查询首先执行子查询。 向主查询中的HAVING 子句返回结果。题目：查询最低工资大于110号部门最低工资的部门id和其最低工资SELECT department_id, MIN(salary)FROM employeesGROUP BY department_idHAVING MIN(salary) &amp;gt; (SELECT MIN(salary) FROM employees WHERE department_id = 110);2.4 CASE中的子查询在CASE表达式中使用单列子查询：题目：显式员工的employee_id,last_name和location。其中，若员工department_id与location_id为1800 的department_id相同，则location为’Canada’，其余则为’USA’。SELECT employee_id, last_name,(CASE department_idWHEN(SELECT department_id FROM departmentsWHERE location_id = 1800)THEN &#39;Canada&#39; ELSE &#39;USA&#39; END) locationFROM employees;2.5 子查询中的空值问题SELECT last_name, job_idFROM employeesWHERE job_id = (SELECT job_id FROM employees WHERE last_name = &#39;Haas&#39;); Empty set子查询不返回任何行2.6 非法使用子查询SELECT employee_id, last_nameFROM employeesWHERE salary = (SELECT MIN(salary) FROM employees GROUP BY department_id);多行子查询使用单行比较符3. 多行子查询也称为集合比较子查询 内查询返回多行 使用多行比较操作符3.1 多行比较操作符 操作符 说明 IN 等于列表中任意一个 ANY 需要和单行比较操作符一起使用，和子查询返回的某一个值比较 ALL 需要和单行比较操作符一起使用，和子查询返回的所有值比较 SOME 实际上是ANY的别名，作用相同，一般常使用ANY 体会 ANY 和 ALL 的区别3.2 代码示例题目：返回其它job_id中比job_id为IT_PROG部门任一工资低的员工的员工号、姓名、job_id 以及salarySELECT employee_id,last_name,job_id,salaryFROM employeesWHERE salary &amp;lt;ANY( SELECT salary FROM employees WHERE job_id = &#39;IT_PROG&#39;)AND job_id &amp;lt;&amp;gt; &#39;IT_PROG&#39;;+-------------+-------------+------------+--------+| employee_id | last_name | job_id | salary |+-------------+-------------+------------+--------+| 110 | Chen | FI_ACCOUNT | 8200 || 111 | Sciarra | FI_ACCOUNT | 7700 || 112 | Urman | FI_ACCOUNT | 7800 || 113 | Popp | FI_ACCOUNT | 6900 || 115 | Khoo | PU_CLERK | 3100 || 116 | Baida | PU_CLERK | 2900 || 117 | Tobias | PU_CLERK | 2800 || 118 | Himuro | PU_CLERK | 2600 || 119 | Colmenares | PU_CLERK | 2500 || 120 | Weiss | ST_MAN | 8000 || 121 | Fripp | ST_MAN | 8200 || 122 | Kaufling | ST_MAN | 7900 || 123 | Vollman | ST_MAN | 6500 || 124 | Mourgos | ST_MAN | 5800 || 125 | Nayer | ST_CLERK | 3200 || 126 | Mikkilineni | ST_CLERK | 2700 || 127 | Landry | ST_CLERK | 2400 || 128 | Markle | ST_CLERK | 2200 || 129 | Bissot | ST_CLERK | 3300 || 130 | Atkinson | ST_CLERK | 2800 || 131 | Marlow | ST_CLERK | 2500 || 132 | Olson | ST_CLERK | 2100 || 133 | Mallin | ST_CLERK | 3300 || 134 | Rogers | ST_CLERK | 2900 || 135 | Gee | ST_CLERK | 2400 || 136 | Philtanker | ST_CLERK | 2200 || 137 | Ladwig | ST_CLERK | 3600 || 138 | Stiles | ST_CLERK | 3200 || 139 | Seo | ST_CLERK | 2700 || 140 | Patel | ST_CLERK | 2500 || 141 | Rajs | ST_CLERK | 3500 || 142 | Davies | ST_CLERK | 3100 || 143 | Matos | ST_CLERK | 2600 || 144 | Vargas | ST_CLERK | 2500 || 153 | Olsen | SA_REP | 8000 || 154 | Cambrault | SA_REP | 7500 || 155 | Tuvault | SA_REP | 7000 || 159 | Smith | SA_REP | 8000 || 160 | Doran | SA_REP | 7500 || 161 | Sewall | SA_REP | 7000 || 164 | Marvins | SA_REP | 7200 || 165 | Lee | SA_REP | 6800 || 166 | Ande | SA_REP | 6400 || 167 | Banda | SA_REP | 6200 || 171 | Smith | SA_REP | 7400 || 172 | Bates | SA_REP | 7300 || 173 | Kumar | SA_REP | 6100 || 175 | Hutton | SA_REP | 8800 || 176 | Taylor | SA_REP | 8600 || 177 | Livingston | SA_REP | 8400 || 178 | Grant | SA_REP | 7000 || 179 | Johnson | SA_REP | 6200 || 180 | Taylor | SH_CLERK | 3200 || 181 | Fleaur | SH_CLERK | 3100 || 182 | Sullivan | SH_CLERK | 2500 || 183 | Geoni | SH_CLERK | 2800 || 184 | Sarchand | SH_CLERK | 4200 || 185 | Bull | SH_CLERK | 4100 || 186 | Dellinger | SH_CLERK | 3400 || 187 | Cabrio | SH_CLERK | 3000 || 188 | Chung | SH_CLERK | 3800 || 189 | Dilly | SH_CLERK | 3600 || 190 | Gates | SH_CLERK | 2900 || 191 | Perkins | SH_CLERK | 2500 || 192 | Bell | SH_CLERK | 4000 || 193 | Everett | SH_CLERK | 3900 || 194 | McCain | SH_CLERK | 3200 || 195 | Jones | SH_CLERK | 2800 || 196 | Walsh | SH_CLERK | 3100 || 197 | Feeney | SH_CLERK | 3000 || 198 | OConnell | SH_CLERK | 2600 || 199 | Grant | SH_CLERK | 2600 || 200 | Whalen | AD_ASST | 4400 || 202 | Fay | MK_REP | 6000 || 203 | Mavris | HR_REP | 6500 || 206 | Gietz | AC_ACCOUNT | 8300 |+-------------+-------------+------------+--------+76 rows in set题目：返回其它job_id中比job_id为‘IT_PROG’部门所有工资都低的员工的员工号、姓名、job_id以及 salarySELECT employee_id ,last_name,job_id,salaryFROM employees WHERE salary &amp;lt;ALL (SELECT salary FROM employees WHERE job_id = &#39;IT_PROG&#39;) AND job_id &amp;lt;&amp;gt; &#39;IT_PROG&#39;; +-------------+-------------+----------+--------+| employee_id | last_name | job_id | salary |+-------------+-------------+----------+--------+| 115 | Khoo | PU_CLERK | 3100 || 116 | Baida | PU_CLERK | 2900 || 117 | Tobias | PU_CLERK | 2800 || 118 | Himuro | PU_CLERK | 2600 || 119 | Colmenares | PU_CLERK | 2500 || 125 | Nayer | ST_CLERK | 3200 || 126 | Mikkilineni | ST_CLERK | 2700 || 127 | Landry | ST_CLERK | 2400 || 128 | Markle | ST_CLERK | 2200 || 129 | Bissot | ST_CLERK | 3300 || 130 | Atkinson | ST_CLERK | 2800 || 131 | Marlow | ST_CLERK | 2500 || 132 | Olson | ST_CLERK | 2100 || 133 | Mallin | ST_CLERK | 3300 || 134 | Rogers | ST_CLERK | 2900 || 135 | Gee | ST_CLERK | 2400 || 136 | Philtanker | ST_CLERK | 2200 || 137 | Ladwig | ST_CLERK | 3600 || 138 | Stiles | ST_CLERK | 3200 || 139 | Seo | ST_CLERK | 2700 || 140 | Patel | ST_CLERK | 2500 || 141 | Rajs | ST_CLERK | 3500 || 142 | Davies | ST_CLERK | 3100 || 143 | Matos | ST_CLERK | 2600 || 144 | Vargas | ST_CLERK | 2500 || 180 | Taylor | SH_CLERK | 3200 || 181 | Fleaur | SH_CLERK | 3100 || 182 | Sullivan | SH_CLERK | 2500 || 183 | Geoni | SH_CLERK | 2800 || 185 | Bull | SH_CLERK | 4100 || 186 | Dellinger | SH_CLERK | 3400 || 187 | Cabrio | SH_CLERK | 3000 || 188 | Chung | SH_CLERK | 3800 || 189 | Dilly | SH_CLERK | 3600 || 190 | Gates | SH_CLERK | 2900 || 191 | Perkins | SH_CLERK | 2500 || 192 | Bell | SH_CLERK | 4000 || 193 | Everett | SH_CLERK | 3900 || 194 | McCain | SH_CLERK | 3200 || 195 | Jones | SH_CLERK | 2800 || 196 | Walsh | SH_CLERK | 3100 || 197 | Feeney | SH_CLERK | 3000 || 198 | OConnell | SH_CLERK | 2600 || 199 | Grant | SH_CLERK | 2600 |+-------------+-------------+----------+--------+44 rows in set题目：查询平均工资最低的部门id#方式1：SELECT department_idFROM employeesGROUP BY department_idHAVING AVG(salary) = (SELECT MIN(avg_sal)FROM ( SELECT AVG(salary) avg_sal FROM employees GROUP BY department_id ) dept_avg_sal)#方式2：SELECT department_idFROM employeesGROUP BY department_idHAVING AVG(salary) &amp;lt;= ALL ( SELECT AVG(salary) avg_sal FROM employees GROUP BY department_id);+---------------+| department_id |+---------------+| 50 |+---------------+1 row in set3.3 空值问题SELECT last_nameFROM employeesWHERE employee_id NOT IN ( SELECT manager_id FROM employees);Empty set4. 相关子查询4.1 相关子查询执行流程​ 如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为 关联子查询 。​ 相关子查询按照一行接一行的顺序执行，主查询的每一行都执行一次子查询。说明：子查询中使用主查询中的列4.2 代码示例题目：查询员工中，工资大于本部门平均工资的员工的last_name,salary和其department_id 方式一：相关子查询方式二：在 FROM 中使用子查询SELECT last_name,salary,e1.department_idFROM employees e1,( SELECT department_id,AVG(salary) dept_avg_sal FROM employees GROUP BY department_id) e2WHERE e1.`department_id` = e2.department_idAND e2.dept_avg_sal &amp;lt; e1.`salary`;from型的子查询：子查询是作为from的一部分，子查询要用()引起来，并且要给这个子查询取别名， 把它当成一张“临时的虚拟的表”来使用。在ORDER BY 中使用子查询：题目：查询员工的id,salary,按照department_name 排序SELECT employee_id,salaryFROM employees eORDER BY ( SELECT department_name FROM departments d WHERE e.`department_id` = d.`department_id`) ASC;题目：若employees表中employee_id与job_history表中employee_id相同的数目不小于2，输出这些相同 id的员工的employee_id,last_name和其job_idSELECT e.employee_id, last_name,e.job_idFROM employees eWHERE 2 &amp;lt;= (SELECT COUNT(*) FROM job_history WHERE employee_id = e.employee_id); +-------------+-----------+---------+| employee_id | last_name | job_id |+-------------+-----------+---------+| 101 | Kochhar | AD_VP || 176 | Taylor | SA_REP || 200 | Whalen | AD_ASST |+-------------+-----------+---------+3 rows in set4.3 EXISTS 与 NOT EXISTS关键字 关联子查询通常也会和 EXISTS操作符一起来使用，用来检查在子查询中是否存在满足条件的行。 如果在子查询中不存在满足条件的行： 条件返回 FALSE 继续在子查询中查找 如果在子查询中存在满足条件的行： 不在子查询中继续查找 条件返回 TRUE NOT EXISTS关键字表示如果不存在某种条件，则返回TRUE，否则返回FALSE。 题目：查询公司管理者的employee_id，last_name，job_id，department_id信息方法一：SELECT employee_id, last_name, job_id, department_idFROM employees e1WHERE EXISTS ( SELECT * FROM employees e2 WHERE e2.manager_id = e1.employee_id);方式二：自连接SELECT DISTINCT e1.employee_id, e1.last_name, e1.job_id, e1.department_idFROM employees e1 JOIN employees e2WHERE e1.employee_id = e2.manager_id;方式三：SELECT employee_id,last_name,job_id,department_idFROM employees WHERE employee_id IN ( SELECT DISTINCT manager_id FROM employees);题目：查询departments表中，不存在于employees表中的部门的department_id和department_nameSELECT department_id, department_nameFROM departments dWHERE NOT EXISTS (SELECT &#39;X&#39; FROM employees WHERE department_id = d.department_id);5.课后习题 查询和Zlotkey相同部门的员工姓名和工资SELECT last_name ,salary,department_idFROM employees eWHERE e.department_id IN (SELECT department_id FROM employees WHERE last_name = &#39;Zlotkey&#39;); +------------+--------+---------------+| last_name | salary | department_id |+------------+--------+---------------+| Russell | 14000 | 80 || Partners | 13500 | 80 || Errazuriz | 12000 | 80 || Cambrault | 11000 | 80 || Zlotkey | 10500 | 80 || Tucker | 10000 | 80 || Bernstein | 9500 | 80 || Hall | 9000 | 80 || Olsen | 8000 | 80 || Cambrault | 7500 | 80 || Tuvault | 7000 | 80 || King | 10000 | 80 || Sully | 9500 | 80 || McEwen | 9000 | 80 || Smith | 8000 | 80 || Doran | 7500 | 80 || Sewall | 7000 | 80 || Vishney | 10500 | 80 || Greene | 9500 | 80 || Marvins | 7200 | 80 || Lee | 6800 | 80 || Ande | 6400 | 80 || Banda | 6200 | 80 || Ozer | 11500 | 80 || Bloom | 10000 | 80 || Fox | 9600 | 80 || Smith | 7400 | 80 || Bates | 7300 | 80 || Kumar | 6100 | 80 || Abel | 11000 | 80 || Hutton | 8800 | 80 || Taylor | 8600 | 80 || Livingston | 8400 | 80 || Johnson | 6200 | 80 |+------------+--------+---------------+ 查询工资比公司平均工资高的员工的员工号、姓名和工资SELECT employee_id ,last_name,salaryFROM employeesWHERE salary &amp;gt;( SELECT AVG(salary) FROM employees);+-------------+------------+--------+| employee_id | last_name | salary |+-------------+------------+--------+| 100 | King | 24000 || 101 | Kochhar | 17000 || 102 | De Haan | 17000 || 103 | Hunold | 9000 || 108 | Greenberg | 12000 || 109 | Faviet | 9000 || 110 | Chen | 8200 || 111 | Sciarra | 7700 || 112 | Urman | 7800 || 113 | Popp | 6900 || 114 | Raphaely | 11000 || 120 | Weiss | 8000 || 121 | Fripp | 8200 || 122 | Kaufling | 7900 || 123 | Vollman | 6500 || 145 | Russell | 14000 || 146 | Partners | 13500 || 147 | Errazuriz | 12000 || 148 | Cambrault | 11000 || 149 | Zlotkey | 10500 || 150 | Tucker | 10000 || 151 | Bernstein | 9500 || 152 | Hall | 9000 || 153 | Olsen | 8000 || 154 | Cambrault | 7500 || 155 | Tuvault | 7000 || 156 | King | 10000 || 157 | Sully | 9500 || 158 | McEwen | 9000 || 159 | Smith | 8000 || 160 | Doran | 7500 || 161 | Sewall | 7000 || 162 | Vishney | 10500 || 163 | Greene | 9500 || 164 | Marvins | 7200 || 165 | Lee | 6800 || 168 | Ozer | 11500 || 169 | Bloom | 10000 || 170 | Fox | 9600 || 171 | Smith | 7400 || 172 | Bates | 7300 || 174 | Abel | 11000 || 175 | Hutton | 8800 || 176 | Taylor | 8600 || 177 | Livingston | 8400 || 178 | Grant | 7000 || 201 | Hartstein | 13000 || 203 | Mavris | 6500 || 204 | Baer | 10000 || 205 | Higgins | 12000 || 206 | Gietz | 8300 |+-------------+------------+--------+51 rows in set 选择工资大于所有JOB_ID = &#39;SA_MAN&#39;的员工工资的员工的last_name，job_id，salarySELECT last_name,job_id,salaryFROM employeesWHERE salary &amp;gt; ALL ( SELECT salary FROM employees WHERE job_id = &#39;SA_MAN&#39;)+-----------+---------+--------+| last_name | job_id | salary |+-----------+---------+--------+| King | AD_PRES | 24000 || Kochhar | AD_VP | 17000 || De Haan | AD_VP | 17000 |+-----------+---------+--------+3 rows in set 查询和姓名中包含字母u的员工在相同部门的员工的员工号、姓名SELECT employee_id,last_nameFROM employees WHERE department_id IN ( SELECT department_id FROM employees WHERE last_name LIKE &quot;%u%&quot;) ;+-------------+-------------+| employee_id | last_name |+-------------+-------------+| 103 | Hunold || 104 | Ernst || 105 | Austin || 106 | Pataballa || 107 | Lorentz || 108 | Greenberg || 109 | Faviet || 110 | Chen || 111 | Sciarra || 112 | Urman || 113 | Popp || 114 | Raphaely || 115 | Khoo || 116 | Baida || 117 | Tobias || 118 | Himuro || 119 | Colmenares || 120 | Weiss || 121 | Fripp || 122 | Kaufling || 123 | Vollman || 124 | Mourgos || 125 | Nayer || 126 | Mikkilineni || 127 | Landry || 128 | Markle || 129 | Bissot || 130 | Atkinson || 131 | Marlow || 132 | Olson || 133 | Mallin || 134 | Rogers || 135 | Gee || 136 | Philtanker || 137 | Ladwig || 138 | Stiles || 139 | Seo || 140 | Patel || 141 | Rajs || 142 | Davies || 143 | Matos || 144 | Vargas || 180 | Taylor || 181 | Fleaur || 182 | Sullivan || 183 | Geoni || 184 | Sarchand || 185 | Bull || 186 | Dellinger || 187 | Cabrio || 188 | Chung || 189 | Dilly || 190 | Gates || 191 | Perkins || 192 | Bell || 193 | Everett || 194 | McCain || 195 | Jones || 196 | Walsh || 197 | Feeney || 198 | OConnell || 199 | Grant || 145 | Russell || 146 | Partners || 147 | Errazuriz || 148 | Cambrault || 149 | Zlotkey || 150 | Tucker || 151 | Bernstein || 152 | Hall || 153 | Olsen || 154 | Cambrault || 155 | Tuvault || 156 | King || 157 | Sully || 158 | McEwen || 159 | Smith || 160 | Doran || 161 | Sewall || 162 | Vishney || 163 | Greene || 164 | Marvins || 165 | Lee || 166 | Ande || 167 | Banda || 168 | Ozer || 169 | Bloom || 170 | Fox || 171 | Smith || 172 | Bates || 173 | Kumar || 174 | Abel || 175 | Hutton || 176 | Taylor || 177 | Livingston || 179 | Johnson |+-------------+-------------+96 rows in set 查询在部门的location_id为1700的部门工作的员工的员工号SELECT employee_idFROM employeesWHERE department_id IN ( SELECT department_id FROM departments WHERE location_id =1700);+-------------+| employee_id |+-------------+| 200 || 114 || 115 || 116 || 117 || 118 || 119 || 100 || 101 || 102 || 108 || 109 || 110 || 111 || 112 || 113 || 205 || 206 |+-------------+18 rows in set 查询管理者为King的手下员工的员工姓名和工资SELECT last_name,salaryFROM employeesWHERE manager_id IN ( SELECT employee_id FROM employees WHERE last_name = &#39;King&#39;);+-----------+--------+| last_name | salary |+-----------+--------+| Kochhar | 17000 || De Haan | 17000 || Raphaely | 11000 || Weiss | 8000 || Fripp | 8200 || Kaufling | 7900 || Vollman | 6500 || Mourgos | 5800 || Russell | 14000 || Partners | 13500 || Errazuriz | 12000 || Cambrault | 11000 || Zlotkey | 10500 || Hartstein | 13000 |+-----------+--------+14 rows in set 查询工资最低的员工信息：last_name，salarySELECT last_name,salaryFROM employeesWHERE salary =( SELECT MIN(salary) FROM employees);+-----------+--------+| last_name | salary |+-----------+--------+| Olson | 2100 |+-----------+--------+1 row in set 查询平均工资最低的部门信息SELECT * FROM departmentsWHERE department_id = (SELECT department_id FROM employees GROUP BY department_id HAVING AVG(salary)&amp;lt;= ALL (SELECT AVG(salary) FROM employees GROUP BY department_id)); +---------------+-----------------+------------+-------------+| department_id | department_name | manager_id | location_id |+---------------+-----------------+------------+-------------+| 50 | Shipping | 121 | 1500 |+---------------+-----------------+------------+-------------+1 row in set 查询平均工资最低的部门信息和该部门的平均工资SELECT d.*,(SELECT AVG(salary) FROM employees WHERE department_id = d.`department_id`) avg_salFROM departments dWHERE department_id = (SELECT department_id FROM employees GROUP BY department_id HAVING AVG(salary)&amp;lt;= ALL (SELECT AVG(salary) FROM employees GROUP BY department_id)); +---------------+-----------------+------------+-------------+-------------+| department_id | department_name | manager_id | location_id | avg_sal |+---------------+-----------------+------------+-------------+-------------+| 50 | Shipping | 121 | 1500 | 3475.555556 |+---------------+-----------------+------------+-------------+-------------+1 row in set10.查询平均工资最高的job信息SELECT * FROM jobsWHERE job_id = ( SELECT job_id FROM employees GROUP BY job_id HAVING AVG(salary) = (SELECT MAX(avg_sal) FROM (SELECT AVG(salary) avg_sal FROM employees GROUP BY (job_id)) t ));+---------+-----------+------------+------------+| job_id | job_title | min_salary | max_salary |+---------+-----------+------------+------------+| AD_PRES | President | 20000 | 40000 |+---------+-----------+------------+------------+1 row in set 查询平均工资高于公司平均工资的部门有哪些？SELECT department_id FROM employees WHERE department_id IS NOT NULLGROUP BY department_idHAVING AVG(salary) &amp;gt; (SELECT AVG(salary) FROM employees );+---------------+| department_id |+---------------+| 20 || 40 || 70 || 80 || 90 || 100 || 110 |+---------------+7 rows in set 查询公司中所有manager的详细信息SELECT last_name,employee_id,job_id,department_id FROM employeesWHERE employee_id IN (SELECT DISTINCT manager_id FROM employees);+-----------+-------------+---------+---------------+| last_name | employee_id | job_id | department_id |+-----------+-------------+---------+---------------+| King | 100 | AD_PRES | 90 || Kochhar | 101 | AD_VP | 90 || De Haan | 102 | AD_VP | 90 || Hunold | 103 | IT_PROG | 60 || Greenberg | 108 | FI_MGR | 100 || Raphaely | 114 | PU_MAN | 30 || Weiss | 120 | ST_MAN | 50 || Fripp | 121 | ST_MAN | 50 || Kaufling | 122 | ST_MAN | 50 || Vollman | 123 | ST_MAN | 50 || Mourgos | 124 | ST_MAN | 50 || Russell | 145 | SA_MAN | 80 || Partners | 146 | SA_MAN | 80 || Errazuriz | 147 | SA_MAN | 80 || Cambrault | 148 | SA_MAN | 80 || Zlotkey | 149 | SA_MAN | 80 || Hartstein | 201 | MK_MAN | 20 || Higgins | 205 | AC_MGR | 110 |+-----------+-------------+---------+---------------+18 rows in set 比较每个部门的最高工资，找出其中的最低工资是多少?SELECT department_idFROM employees GROUP BY department_id HAVING MAX(salary) = (SELECT MIN(max_sal) FROM (SELECT MAX(salary) max_sal FROM employees GROUP BY department_id) t); 查询平均工资最高的部门，其manager的详细信息：last_name，department_id，email，salarySELECT last_name,department_id,email,salaryFROM employeesWHERE employee_id IN ( SELECT DISTINCT manager_id FROM employees WHERE department_id = ( SELECT department_id FROM employees GROUP BY department_id HAVING AVG(salary) = (SELECT MAX(avg_sal) FROM ( SELECT AVG(salary) avg_sal FROM employees e GROUP BY department_id ) t)));+-----------+---------------+-------+--------+| last_name | department_id | email | salary |+-----------+---------------+-------+--------+| King | 90 | SKING | 24000 |+-----------+---------------+-------+--------+1 row in set 查询部门的部门号，其中不包括job_id为ST_CLERK的部门号SELECT department_idFROM departmentsWHERE department_id NOT IN ( SELECT DISTINCT department_id FROM employees WHERE job_id = &quot;ST_CLERK&quot;); +---------------+| department_id |+---------------+| 10 || 20 || 30 || 40 || 60 || 70 || 80 || 90 || 100 || 110 || 120 || 130 || 140 || 150 || 160 || 170 || 180 || 190 || 200 || 210 || 220 || 230 || 240 || 250 || 260 || 270 |+---------------+26 rows in set 选择所有没有管理者员工的last_nameSELECT last_name FROM employeesWHERE manager_id IS NULL;+-----------+| last_name |+-----------+| King |+-----------+1 row in set 查询员工号、姓名、雇佣时间、工资，其中员工的管理者为De HaanSELECT employee_id ,last_name,hire_date,salaryFROM employees WHERE manager_id IN( SELECT employee_id FROM employees WHERE last_name = &quot;De Haan&quot;);+-------------+-----------+------------+--------+| employee_id | last_name | hire_date | salary |+-------------+-----------+------------+--------+| 103 | Hunold | 1990-01-03 | 9000 |+-------------+-----------+------------+--------+1 row in set 查询工资比本部门平均工资高的员工的员工号、姓名、工资（相关子查询）SELECT employee_id ,last_name,salaryFROM employees e1WHERE salary &amp;gt;(SELECT AVG(salary) FROM employees e2 WHERE e1.`department_id` = e2.`department_id` ); +-------------+-----------+--------+| employee_id | last_name | salary |+-------------+-----------+--------+| 100 | King | 24000 || 103 | Hunold | 9000 || 104 | Ernst | 6000 || 108 | Greenberg | 12000 || 109 | Faviet | 9000 || 114 | Raphaely | 11000 || 120 | Weiss | 8000 || 121 | Fripp | 8200 || 122 | Kaufling | 7900 || 123 | Vollman | 6500 || 124 | Mourgos | 5800 || 137 | Ladwig | 3600 || 141 | Rajs | 3500 || 145 | Russell | 14000 || 146 | Partners | 13500 || 147 | Errazuriz | 12000 || 148 | Cambrault | 11000 || 149 | Zlotkey | 10500 || 150 | Tucker | 10000 || 151 | Bernstein | 9500 || 152 | Hall | 9000 || 156 | King | 10000 || 157 | Sully | 9500 || 158 | McEwen | 9000 || 162 | Vishney | 10500 || 163 | Greene | 9500 || 168 | Ozer | 11500 || 169 | Bloom | 10000 || 170 | Fox | 9600 || 174 | Abel | 11000 || 184 | Sarchand | 4200 || 185 | Bull | 4100 || 188 | Chung | 3800 || 189 | Dilly | 3600 || 192 | Bell | 4000 || 193 | Everett | 3900 || 201 | Hartstein | 13000 || 205 | Higgins | 12000 |+-------------+-----------+--------+38 rows in set 查询部门人数大于5的部门名称SELECT department_nameFROM departments dWHERE 5 &amp;lt;( SELECT COUNT(*) FROM employees e WHERE d.department_id = e.department_id);+-----------------+| department_name |+-----------------+| Purchasing || Shipping || Sales || Finance |+-----------------+4 rows in set 查询每个国家下的部门个数大于2的国家编号（相关子查询）SELECT country_idFROM locations lWHERE 2 &amp;lt;( SELECT COUNT(*) FROM departments d WHERE l.location_id = d.location_id);+------------+| country_id |+------------+| US |+------------+1 row in set参考链接1MySQL数据库教程天花板，mysql安装到mysql高级，强！硬！" }, { "title": "MySQL聚合函数", "url": "/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/", "categories": "数据库", "tags": "MySQL", "date": "2021-06-08 00:00:00 +0800", "snippet": "​ 我们上一章讲到了 SQL 单行函数。实际上 SQL 函数还有一类，叫做聚合（或聚集、分组）函数，它是对 一组数据进行汇总的函数，输入的是一组数据的集合，输出的是单个值。1. 聚合函数介绍1.1 什么是聚合函数​ 聚合函数作用于一组数据，并对一组数据返回一个值。1.2 AVG和SUM函数​ 可以对数值型数据使用AVG 和 SUM 函数。SELECT AVG(salary), MAX(salary),MIN(salary), SUM(salary)FROM employeesWHERE job_id LIKE &#39;%REP%&#39;;+-------------+-------------+-------------+-------------+| AVG(salary) | MAX(salary) | MIN(salary) | SUM(salary) |+-------------+-------------+-------------+-------------+| 8272.727273 | 11500 | 6000 | 273000.00 |+-------------+-------------+-------------+-------------+1 row in set1.3 MIN和MAX函数可以对任意数据类型的数据使用 MIN 和 MAX 函数。SELECT MIN(hire_date), MAX(hire_date)FROM employees;+----------------+----------------+| MIN(hire_date) | MAX(hire_date) |+----------------+----------------+| 1987-06-17 | 2000-04-21 |+----------------+----------------+1 row in set1.4 COUNT函数COUNT(*)返回表中记录总数，适用于任意数据类型。SELECT COUNT(*)FROM employeesWHERE department_id = 50;+----------+| COUNT(*) |+----------+| 45 |+----------+1 row in set 问题：用count(*)，count(1)，count(列名)谁好呢?​ 其实，对于MyISAM引擎的表是没有区别的。这种引擎内部有一计数器在维护着行数。​ Innodb引擎的表用count(*),count(1)直接读行数，复杂度是O(n)，因为innodb真的要去数一遍。但好于具体的count(列名)。 问题：能不能使用count(列名)替换count(*)?​ 不要使用 count(列名)来替代 count(*) ， count(*) 是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。 说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。举例：计算平均奖金率# 考虑空值的情况SELECT SUM(commission_pct)/COUNT(IFNULL(commission_pct,1))FROM employees;2. GROUP BY2.1 基本使用可以使用GROUP BY子句将表中的数据分成若干组SELECT column, group_function(column)FROM table[WHERE condition][GROUP BY group_by_expression][ORDER BY column];明确：WHERE一定放在FROM后面在SELECT列表中所有未包含在组函数中的列都应该包含在 GROUP BY子句中SELECT department_id, AVG(salary)FROM employeesGROUP BY department_id ;+---------------+--------------+| department_id | AVG(salary) |+---------------+--------------+| NULL | 7000.000000 || 10 | 4400.000000 || 20 | 9500.000000 || 30 | 4150.000000 || 40 | 6500.000000 || 50 | 3475.555556 || 60 | 5760.000000 || 70 | 10000.000000 || 80 | 8955.882353 || 90 | 19333.333333 || 100 | 8600.000000 || 110 | 10150.000000 |+---------------+--------------+12 rows in set包含在 GROUP BY 子句中的列不必包含在SELECT 列表中SELECT AVG(salary)FROM employeesGROUP BY department_id ;+--------------+| AVG(salary) |+--------------+| 7000.000000 || 4400.000000 || 9500.000000 || 4150.000000 || 6500.000000 || 3475.555556 || 5760.000000 || 10000.000000 || 8955.882353 || 19333.333333 || 8600.000000 || 10150.000000 |+--------------+12 rows in set2.2 使用多个列分组SELECT department_id dept_id, job_id, SUM(salary)FROM employeesGROUP BY department_id, job_id ;+---------+------------+-------------+| dept_id | job_id | SUM(salary) |+---------+------------+-------------+| 90 | AD_PRES | 24000.00 || 90 | AD_VP | 34000.00 || 60 | IT_PROG | 28800.00 || 100 | FI_MGR | 12000.00 || 100 | FI_ACCOUNT | 39600.00 || 30 | PU_MAN | 11000.00 || 30 | PU_CLERK | 13900.00 || 50 | ST_MAN | 36400.00 || 50 | ST_CLERK | 55700.00 || 80 | SA_MAN | 61000.00 || 80 | SA_REP | 243500.00 || NULL | SA_REP | 7000.00 || 50 | SH_CLERK | 64300.00 || 10 | AD_ASST | 4400.00 || 20 | MK_MAN | 13000.00 || 20 | MK_REP | 6000.00 || 40 | HR_REP | 6500.00 || 70 | PR_REP | 10000.00 || 110 | AC_MGR | 12000.00 || 110 | AC_ACCOUNT | 8300.00 |+---------+------------+-------------+20 rows in set2.3 GROUP BY中使用WITH ROLLUP​ 使用 WITH ROLLUP 关键字之后，在所有查询出的分组记录之后增加一条记录，该记录计算查询出的所 有记录的总和，即统计记录数量。SELECT department_id,AVG(salary)FROM employeesWHERE department_id &amp;gt; 80GROUP BY department_id WITH ROLLUP;+---------------+--------------+| department_id | AVG(salary) |+---------------+--------------+| 90 | 19333.333333 || 100 | 8600.000000 || 110 | 10150.000000 || NULL | 11809.090909 |+---------------+--------------+4 rows in set注意： 当使用ROLLUP时，不能同时使用ORDER BY子句进行结果排序，即ROLLUP和ORDER BY是互相排斥 的。3. HAVING3.1 基本使用过滤分组：HAVING子句 行已经被分组。 使用了聚合函数。 满足HAVING 子句中条件的分组将被显示。 HAVING 不能单独使用，必须要跟 GROUP BY 一起使用。 mysql&amp;gt; SELECT department_id, MAX(salary)FROM employeesGROUP BY department_idHAVING MAX(salary)&amp;gt;10000 ;+---------------+-------------+| department_id | MAX(salary) |+---------------+-------------+| 20 | 13000 || 30 | 11000 || 80 | 14000 || 90 | 24000 || 100 | 12000 || 110 | 12000 |+---------------+-------------+6 rows in set3.2 WHERE和HAVING的对比区别1：​ **WHERE 可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算函数作为筛选条件； **​ HAVING 必须要与 GROUP BY 配合使用，可以把分组计算的函数和分组字段作为筛选条件。​ 这决定了，在需要对数据进行分组统计的时候，HAVING 可以完成 WHERE 不能完成的任务。这是因为， 在查询语法结构中，WHERE 在 GROUP BY 之前，所以无法对分组结果进行筛选。HAVING 在 GROUP BY 之 后，可以使用分组字段和分组中的计算函数，对分组的结果集进行筛选，这个功能是 WHERE 无法完成 的。另外，WHERE排除的记录不再包括在分组中。区别2：​ **如果需要通过连接从关联表中获取需要的数据，WHERE 是先筛选后连接，而 HAVING 是先连接 后筛选。 **​ 这一点，就决定了在关联查询中，WHERE 比 HAVING 更高效。因为 WHERE 可以先筛选，用一 个筛选后的较小数据集和关联表进行连接，这样占用的资源比较少，执行效率也比较高。HAVING 则需要 先把结果集准备好，也就是用未被筛选的数据集进行关联，然后对这个大的数据集进行筛选，这样占用 的资源就比较多，执行效率也较低。开发中的选择： WHERE 和 HAVING 也不是互相排斥的，我们可以在一个查询里面同时使用 WHERE 和 HAVING。包含分组 统计函数的条件用 HAVING，普通条件用 WHERE。这样，我们就既利用了 WHERE 条件的高效快速，又发挥了 HAVING 可以使用包含分组统计函数的查询条件的优点。当数据量特别大的时候，运行效率会有很大的差别。4. SELECT的执行过程4.1 查询的结构#方式1：SELECT ...,....,...FROM ...,...,....WHERE 多表的连接条件AND 不包含组函数的过滤条件GROUP BY ...,...HAVING 包含组函数的过滤条件ORDER BY ... ASC/DESCLIMIT ...,...#方式2：SELECT ...,....,...FROM ... JOIN ...ON 多表的连接条件JOIN ...ON ...WHERE 不包含组函数的过滤条件AND/OR 不包含组函数的过滤条件GROUP BY ...,...HAVING 包含组函数的过滤条件ORDER BY ... ASC/DESCLIMIT ...,...#其中：#（1）from：从哪些表中筛选#（2）on：关联多表查询时，去除笛卡尔积#（3）where：从表中筛选的条件#（4）group by：分组依据#（5）having：在统计结果中再次筛选#（6）order by：排序#（7）limit：分页4.2 SELECT执行顺序你需要记住 SELECT 查询时的两个顺序：1. 关键字的顺序是不能颠倒的SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... LIMIT...2.SELECT 语句的执行顺序（在 MySQL 和 Oracle 中，SELECT 执行顺序基本相同）：FROM -&amp;gt; WHERE -&amp;gt; GROUP BY -&amp;gt; HAVING -&amp;gt; SELECT 的字段 -&amp;gt; DISTINCT -&amp;gt; ORDER BY -&amp;gt; LIMIT比如你写了一个 SQL 语句，那么它的关键字顺序和执行顺序是下面这样的：SELECT DISTINCT player_id, player_name, count(*) as num # 顺序 5FROM player JOIN team ON player.team_id = team.team_id # 顺序 1WHERE height &amp;gt; 1.80 # 顺序 2GROUP BY player.team_id # 顺序 3HAVING num &amp;gt; 2 # 顺序 4ORDER BY num DESC # 顺序 6LIMIT 2 # 顺序 7​ 在 SELECT 语句执行这些步骤的时候，每个步骤都会产生一个 虚拟表 ，然后将这个虚拟表传入下一个步骤中作为输入。需要注意的是，这些步骤隐含在 SQL 的执行过程中，对于我们来说是不可见的。4.3 SQL 的执行原理SELECT 是先执行 FROM 这一步的。在这个阶段，如果是多张表联查，还会经历下面的几个步骤： 首先先通过 CROSS JOIN 求笛卡尔积，相当于得到虚拟表 vt（virtual table）1-1； 通过 ON 进行筛选，在虚拟表 vt1-1 的基础上进行筛选，得到虚拟表 vt1-2； 添加外部行。如果我们使用的是左连接、右链接或者全连接，就会涉及到外部行，也就是在虚拟 表 vt1-2 的基础上增加外部行，得到虚拟表vt1-3。当然如果我们操作的是两张以上的表，还会重复上面的步骤，直到所有表都被处理完为止。这个过程得 到是我们的原始数据。​ 当我们拿到了查询数据表的原始数据，也就是最终的虚拟表 vt1 ，就可以在此基础上再进行 WHERE 阶段 。在这个阶段中，会根据 vt1 表的结果进行筛选过滤，得到虚拟表 vt2 。​ 然后进入第三步和第四步，也就是 GROUP 和 HAVING 阶段 。在这个阶段中，实际上是在虚拟表 vt2 的 基础上进行分组和分组过滤，得到中间的虚拟表 vt3 和 vt4 。 当我们完成了条件筛选部分之后，就可以筛选表中提取的字段，也就是进入到 SELECT 和 DISTINCT 阶段 。​ 首先在 SELECT 阶段会提取想要的字段，然后在 DISTINCT 阶段过滤掉重复的行，分别得到中间的虚拟表 vt5-1 和 vt5-2 。 当我们提取了想要的字段数据之后，就可以按照指定的字段进行排序，也就是 ORDER BY 阶段 ，得到 虚拟表 vt6 。​ 最后在 vt6 的基础上，取出指定行的记录，也就是 LIMIT 阶段 ，得到最终的结果，对应的是虚拟表 vt7 。 当然我们在写 SELECT 语句的时候，不一定存在所有的关键字，相应的阶段就会省略。 同时因为 SQL 是一门类似英语的结构化查询语言，所以我们在写 SELECT 语句的时候，还要注意相应的 关键字顺序，所谓底层运行的原理，就是我们刚才讲到的执行顺序5.课后练习 where字句可否使用组函数进行过滤? No! 查询公司员工的工资最大值、最小值、平均值和总和 SELECT MAX(salary) max_sal,MIN(salary) min_sal,AVG(salary) avg_sal,SUM(salary) sum_salFROM employees;+---------+---------+-------------+-----------+| max_sal | min_sal | avg_sal | sum_sal |+---------+---------+-------------+-----------+| 24000 | 2100 | 6461.682243 | 691400.00 |+---------+---------+-------------+-----------+1 row in set 查询各job_id的员工工资的最大值、最小值、平均值和总和SELECT job_id,MAX(salary) max_sal,MIN(salary) min_sal,AVG(salary) avg_sal,SUM(salary) sum_salFROM employeesGROUP BY job_id;+------------+---------+---------+--------------+-----------+| job_id | max_sal | min_sal | avg_sal | sum_sal |+------------+---------+---------+--------------+-----------+| AC_ACCOUNT | 8300 | 8300 | 8300.000000 | 8300.00 || AC_MGR | 12000 | 12000 | 12000.000000 | 12000.00 || AD_ASST | 4400 | 4400 | 4400.000000 | 4400.00 || AD_PRES | 24000 | 24000 | 24000.000000 | 24000.00 || AD_VP | 17000 | 17000 | 17000.000000 | 34000.00 || FI_ACCOUNT | 9000 | 6900 | 7920.000000 | 39600.00 || FI_MGR | 12000 | 12000 | 12000.000000 | 12000.00 || HR_REP | 6500 | 6500 | 6500.000000 | 6500.00 || IT_PROG | 9000 | 4200 | 5760.000000 | 28800.00 || MK_MAN | 13000 | 13000 | 13000.000000 | 13000.00 || MK_REP | 6000 | 6000 | 6000.000000 | 6000.00 || PR_REP | 10000 | 10000 | 10000.000000 | 10000.00 || PU_CLERK | 3100 | 2500 | 2780.000000 | 13900.00 || PU_MAN | 11000 | 11000 | 11000.000000 | 11000.00 || SA_MAN | 14000 | 10500 | 12200.000000 | 61000.00 || SA_REP | 11500 | 6100 | 8350.000000 | 250500.00 || SH_CLERK | 4200 | 2500 | 3215.000000 | 64300.00 || ST_CLERK | 3600 | 2100 | 2785.000000 | 55700.00 || ST_MAN | 8200 | 5800 | 7280.000000 | 36400.00 |+------------+---------+---------+--------------+-----------+19 rows in set 选择各个job_id的员工人数SELECT job_id,COUNT(*)FROM employeesGROUP BY job_id;+------------+----------+| job_id | COUNT(*) |+------------+----------+| AC_ACCOUNT | 1 || AC_MGR | 1 || AD_ASST | 1 || AD_PRES | 1 || AD_VP | 2 || FI_ACCOUNT | 5 || FI_MGR | 1 || HR_REP | 1 || IT_PROG | 5 || MK_MAN | 1 || MK_REP | 1 || PR_REP | 1 || PU_CLERK | 5 || PU_MAN | 1 || SA_MAN | 5 || SA_REP | 30 || SH_CLERK | 20 || ST_CLERK | 20 || ST_MAN | 5 |+------------+----------+19 rows in set 查询员工最高工资和最低工资的差距（DIFFERENCE)SELECT MAX(salary) - MIN(salary) &quot;DIFFERENCE&quot;FROM employees;+------------+| DIFFERENCE |+------------+| 21900.00 |+------------+1 row in set 查询各个管理者手下员工的最低工资，其中最低工资不能低于6000，没有管理者的员工不计算在内SELECT manager_id,MIN(salary)FROM employeesWHERE manager_id IS NOT NULLGROUP BY manager_idHAVING MIN(salary) &amp;gt;= 6000;+------------+-------------+| manager_id | MIN(salary) |+------------+-------------+| 102 | 9000 || 108 | 6900 || 145 | 7000 || 146 | 7000 || 147 | 6200 || 148 | 6100 || 149 | 6200 || 201 | 6000 || 205 | 8300 |+------------+-------------+9 rows in set 查询所有部门的名字、location_id、部门数量和平均工资，并按平均工资降序SELECT department_name,d.location_id,COUNT(employee_id),AVG(salary)FROM departments d LEFT JOIN employees eON d.`department_id` = e.`department_id`GROUP BY department_name,location_id+----------------------+-------------+--------------------+--------------+| department_name | location_id | COUNT(employee_id) | AVG(salary) |+----------------------+-------------+--------------------+--------------+| Administration | 1700 | 1 | 4400.000000 || Marketing | 1800 | 2 | 9500.000000 || Purchasing | 1700 | 6 | 4150.000000 || Human Resources | 2400 | 1 | 6500.000000 || Shipping | 1500 | 45 | 3475.555556 || IT | 1400 | 5 | 5760.000000 || Public Relations | 2700 | 1 | 10000.000000 || Sales | 2500 | 34 | 8955.882353 || Executive | 1700 | 3 | 19333.333333 || Finance | 1700 | 6 | 8600.000000 || Accounting | 1700 | 2 | 10150.000000 || Treasury | 1700 | 0 | NULL || Corporate Tax | 1700 | 0 | NULL || Control And Credit | 1700 | 0 | NULL || Shareholder Services | 1700 | 0 | NULL || Benefits | 1700 | 0 | NULL || Manufacturing | 1700 | 0 | NULL || Construction | 1700 | 0 | NULL || Contracting | 1700 | 0 | NULL || Operations | 1700 | 0 | NULL || IT Support | 1700 | 0 | NULL || NOC | 1700 | 0 | NULL || IT Helpdesk | 1700 | 0 | NULL || Government Sales | 1700 | 0 | NULL || Retail Sales | 1700 | 0 | NULL || Recruiting | 1700 | 0 | NULL || Payroll | 1700 | 0 | NULL |+----------------------+-------------+--------------------+--------------+27 rows in set 查询每个工种、每个部门的部门名，工种名和最低工资SELECT d.department_name,e.job_id,MIN(salary)FROM departments d LEFT JOIN employees eON d.`department_id` = e.`department_id`GROUP BY job_id;+------------------+------------+-------------+| department_name | job_id | MIN(salary) |+------------------+------------+-------------+| Administration | AD_ASST | 4400 || Marketing | MK_MAN | 13000 || Marketing | MK_REP | 6000 || Purchasing | PU_MAN | 11000 || Purchasing | PU_CLERK | 2500 || Human Resources | HR_REP | 6500 || Shipping | ST_MAN | 5800 || Shipping | ST_CLERK | 2100 || Shipping | SH_CLERK | 2500 || IT | IT_PROG | 4200 || Public Relations | PR_REP | 10000 || Sales | SA_MAN | 10500 || Sales | SA_REP | 6100 || Executive | AD_PRES | 24000 || Executive | AD_VP | 17000 || Finance | FI_MGR | 12000 || Finance | FI_ACCOUNT | 6900 || Accounting | AC_MGR | 12000 || Accounting | AC_ACCOUNT | 8300 || Treasury | NULL | NULL |+------------------+------------+-------------+20 rows in set参考链接1.MySQL数据库教程天花板，mysql安装到mysql高级，强！硬！" }, { "title": "MySQL函数", "url": "/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-Mysql%E5%87%BD%E6%95%B0/", "categories": "数据库", "tags": "MySQL", "date": "2021-06-07 00:00:00 +0800", "snippet": "1. 函数的理解1.1 什么是函数​ 函数在计算机语言的使用中贯穿始终，函数的作用是什么呢？它可以把我们经常使用的代码封装起来， 需要的时候直接调用即可。这样既 提高了代码效率 ，又 提高了可维护性 。在 SQL 中我们也可以使用函数 对检索出来的数据进行函数操作。使用这些函数，可以极大地 提高用户对数据库的管理效率 。​ 从函数定义的角度出发，我们可以将函数分成 内置函数 和 自定义函数 。在 SQL 语言中，同样也包括了 内置函数和自定义函数。内置函数是系统内置的通用函数，而自定义函数是我们根据自己的需要编写 的，本章及下一章讲解的是 SQL 的内置函数。1.2 不同DBMS函数的差异 我们在使用 SQL 语言的时候，不是直接和这门语言打交道，而是通过它使用不同的数据库软件，即 DBMS。DBMS 之间的差异性很大，远大于同一个语言不同版本之间的差异。实际上，只有很少的函数是 被 DBMS 同时支持的。比如，大多数 DBMS 使用（||）或者（+）来做拼接符，而在 MySQL 中的字符串拼 接函数为concat()。大部分 DBMS 会有自己特定的函数，这就意味着采用 SQL 函数的代码可移植性是很 差的，因此在使用函数的时候需要特别注意。1.3 MySQL的内置函数及分类​ MySQL提供了丰富的内置函数，这些函数使得数据的维护与管理更加方便，能够更好地提供数据的分析 与统计功能，在一定程度上提高了开发人员进行数据分析与统计的效率。 MySQL提供的内置函数从 实现的功能角度 可以分为数值函数、字符串函数、日期和时间函数、流程控制 函数、加密与解密函数、获取MySQL信息函数、聚合函数等。这里，我将这些丰富的内置函数再分为两 类： 单行函数 、 聚合函数（或分组函数） 。单行函数 ： 操作数据对象 接受参数返回一个结果 只对一行进行变换 每行返回一个结果 可以嵌套 参数可以是一列或一个值2. 数值函数2.1 基本函数 函数 用法 ABS(x) 返回x绝对值 SIGN(x) 返回x的符号，正数为1、负数为-1、0返回0 PI() 返回圆周率的值 CEIL(x) 返回大于或等于某个值的最小整数 FLOOR(x) 地板函数 LEAST(x,y,z) 返回最小值 GREATEST(x,y,z) 返回最大值 MOD(x,y) 返回x除以y后的余数 RAND() 返回0~1的随机值 RAND(x) 返回0~1之间的伪随机数，x为种子数 ROUND(x) x四舍五入 ROUND(x,y) x四舍五入，保留y位小数 TRUNCATE(x,y) 返回数字x截断为y小数的结果 SQRT(x) x开根号 举例SELECTABS(-123),ABS(32),SIGN(-23),SIGN(43),PI(),CEIL(32.32),CEILING(-43.23),FLOOR(32.32),FLOOR(-43.23),MOD(12,5)FROM DUAL;SELECT RAND(),RAND(),RAND(10),RAND(10),RAND(-1),RAND(-1)FROM DUAL;SELECTROUND(12.33),ROUND(12.343,2),ROUND(12.324,-1),TRUNCATE(12.66,1),TRUNCATE(12.66,-1)FROM DUAL;2.2 角度与弧度互换函数 函数 用法 RADIANS(x) 将角度转化为弧度，其中x为角度值 DEGREES(x) 将弧度转化为角度，其中x为弧度值 SELECT RADIANS(30),RADIANS(60),RADIANS(90),DEGREES(2*PI()),DEGREES(RADIANS(90))FROM DUAL;2.3 三角函数 函数 用法 SIN(x) 返回x的正弦值，x为弧度 ASIN(x) 返回x的反正弦值，x为弧度；x不在-1到1之间，返回null COS(x) 返回x的余弦值，x为弧度 ACOS(x) 返回x的反余弦值，x为弧度；x不在-1到1之间，返回null TAN(x) 返回x的正切值，x为弧度 ATAN(x) 返回x的反正切值 ATAN2(m,n) 返回两个参数的反正切值 COT(x) 返回x的余切值，其中x为弧度值 举例：​ ATAN2(M,N)函数返回两个参数的反正切值。 与ATAN(X)函数相比，ATAN2(M,N)需要两个参数，例如有两个 点point(x1,y1)和point(x2,y2)，使用ATAN(X)函数计算反正切值为ATAN((y2-y1)/(x2-x1))，使用ATAN2(M,N)计 算反正切值则为ATAN2(y2-y1,x2-x1)。由使用方式可以看出，当x2-x1等于0时，ATAN(X)函数会报错，而 ATAN2(M,N)函数则仍然可以计算。ATAN2(M,N)函数的使用示例如下：SELECTSIN(RADIANS(30)),DEGREES(ASIN(1)),TAN(RADIANS(45)),DEGREES(ATAN(1)),DEGREES(ATAN2(1,1))FROM DUAL;2.4 指数和对数 函数 说明 POW(x,y) 返回x的y次方 EXP(x) 返回e的x次方 LN(x) 返回以e为底x的对数，x&amp;lt;=0时，返回结果为null LOG10(x) 返回以10为底的x的对数，x&amp;lt;=0时，返回结果为null LOG2(x) 返回以2为底的x的对数，x&amp;lt;=0时，返回结果为null SELECT POW(2,5),POWER(2,4),EXP(2),LN(10),LOG10(10),LOG2(4) FROM DUAL;2.5 进制间的转换 函数 说明 BIN(x) 返回x的二进制编码 HEX(x) 返回x的十六进制编码 OCT(x) 返回x的八进制编码 CONV(f1，x，f2) 返回f1进制的x转换为f2进制数 SELECT BIN(10),HEX(10),OCT(10),CONV(10,2,8) FROM DUAL;3.字符串函数 函数 说明 ASCII(s) 返回字符串s的ASCII码 CHAR_LENGTH(s) 返回字符串s的字符数 LENGTH(s) 返回字符串的字节数，与字符集相关 CONCAT(s1,s2,s3) 返回s1，s2，s3连接后的字符串 CONCAT_WS(x,s1,s2,s3) 返回s1，s2，s3连接后的字符串，字符串之间用x相连接 INSERT(str，idx，len，replacestr) 将字符串str从idx位置开始，len个字符长的字串替换为字符串replacestr REPLACE(str, a, b) 用字符串b替换字符串str中所有出现的字符串b UPPER(s) 将字符串s的所有字母转成大写字母 LOWER(s) 将字符串s的所有字母转成小写字母 LEFT(str,n) 返回字符串str最左边的n个字符 RIGHT(str,n) 返回字符串str最右边的n个字符 LPAD(str, len, pad) 用字符串pad对str最左边进行填充，直到str的长度为len个字符 RPAD(str ,len, pad) 用字符串pad对str最右边进行填充，直到str的长度为len个字符 LTRIM(s) 去掉字符串s左侧的空格 RTRIM(s) 去掉字符串s右侧的空格 TRIM(s) 去掉字符串s开始与结尾的空格 TRIM(s1 FROM s) 去掉字符串s开始与结尾的s1 TRIM(LEADING s1 FROM s) 去掉字符串s开始处的s1 TRIM(TRAILING s1 FROM s) 去掉字符串s结尾处的s1 REPEAT(str, n) 返回str重复n次的结果 SPACE(n) 返回n个空格 STRCMP(s1,s2) 比较字符串s1,s2的ASCII码值的大小 SUBSTR(s,index,len) 返回从字符串s的index位置其len个字符，作用与SUBSTRING(s,n,len)、 MID(s,n,len)相同 LOCATE(substr,str) 返回字符串substr在字符串str中首次出现的位置，作用于POSITION(substr IN str)、INSTR(str,substr)相同。未找到，返回0 ELT(m,s1,s2,…,sn) 返回指定位置的字符串，如果m=1，则返回s1，如果m=2，则返回s2，如 果m=n，则返回sn FIELD(s,s1,s2,…,sn) 返回字符串s在字符串列表中第一次出现的位置 FIND_IN_SET(s1,s2) 返回字符串s1在字符串s2中出现的位置。其中，字符串s2是一个以逗号分 隔的字符串 REVERSE(s) 返回s反转后的字符串 NULLIF(value1,value2) 比较两个字符串，如果value1与value2相等，则返回NULL，否则返回 value1 注意：MySQL中，字符串的位置是从1开始的。4.日期和时间函数4.1 获取日期、时间 函数 说明 CURDATE() ，CURRENT_DATE() 返回当前日期，只包含年、 月、日 CURTIME() ， CURRENT_TIME() 返回当前时间，只包含时、 分、秒 NOW() / SYSDATE() / CURRENT_TIMESTAMP() / LOCALTIME() / LOCALTIMESTAMP() 返回当前系统日期和时间 UTC_DATE() 返回UTC（世界标准时间） 日期 UTC_TIME() 返回UTC（世界标准时间） 时间 SELECT CURDATE(),CURTIME(),NOW(),SYSDATE()+0,UTC_DATE(),UTC_DATE()+0,UTC_TIME(),UTC_TIME()+0FROM DUAL;4.2 日期与时间戳的转换 函数 说明 UNIX_TIMESTAMP() 以UNIX时间戳的形式返回当前时间。SELECT UNIX_TIMESTAMP() - &amp;gt;1634348884 UNIX_TIMESTAMP(date) 将时间date以UNIX时间戳的形式返回。 FROM_UNIXTIME(timestamp) 将UNIX时间戳的时间转换为普通格式的时间 SELECT FROM_UNIXTIME(1576380910);4.3 获取月份、星期、星期数、天数等函数 函数 说明 YEAR(date) / MONTH(date) / DAY(date) 返回具体的日期值 HOUR(time) / MINUTE(time) / SECOND(time) 返回具体的时间值 MONTHNAME(date) 返回月份：January，… DAYNAME(date) 返回星期几：MONDAY，TUESDAY…..SUNDAY WEEKDAY(date) 返回周几，注意，周1是0，周2是1，。。。周日是6 QUARTER(date) 返回日期对应的季度，范围为1～4 WEEKOFYEAR(date) 返回一年中的第几周 DAYOFYEAR(date) 返回日期是一年中的第几天 DAYOFMONTH(date) 返回日期位于所在月份的第几天 DAYOFWEEK(date) 返回周几，注意：周日是1，周一是2，。。。周六是 7 SELECT YEAR(CURDATE()),MONTH(CURDATE()),DAY(CURDATE()),HOUR(CURTIME()),MINUTE(NOW()),SECOND(SYSDATE())FROM DUAL;SELECT MONTHNAME(&#39;2021-10-26&#39;),DAYNAME(&#39;2021-10-26&#39;),WEEKDAY(&#39;2021-10-26&#39;),QUARTER(CURDATE()),WEEK(CURDATE()),DAYOFYEAR(NOW()),DAYOFMONTH(NOW()),DAYOFWEEK(NOW())FROM DUAL;4.4 日期的操作函数 函数 说明 EXTRACT(type FROM date) 返回指定日期中特定的部分，type指定返回的值 EXTRACT(type FROM date)函数中type的取值与含义：SELECT EXTRACT(MINUTE FROM NOW()),EXTRACT( WEEK FROM NOW()),EXTRACT( QUARTER FROM NOW()),EXTRACT( MINUTE_SECOND FROM NOW())FROM DUAL;4.5 时间和秒钟转换的函数 函数 说明 TIME_TO_SEC(time) 将 time 转化为秒并返回结果值。转化的公式为： 小时*3600+分钟 *60+秒 SEC_TO_TIME(seconds) 将 seconds 描述转化为包含小时、分钟和秒的时间 SELECT TIME_TO_SEC(NOW());SELECT SEC_TO_TIME(78774);4.6 计算日期和时间的函数 函数 说明 DATE_ADD(datetime, INTERVAL expr type)， ADDDATE(date,INTERVAL expr type） 返回与给定日期时间相差INTERVAL时 间段的日期时间 DATE_SUB(date,INTERVAL expr type)， SUBDATE(date,INTERVAL expr type) 返回与date相差INTERVAL时间间隔的 日期 上述函数中type的取值：SELECT DATE_ADD(NOW(), INTERVAL 1 DAY) AS col1,DATE_ADD(&#39;2021-10-21 23:32:12&#39;,INTERVAL 1 SECOND) AS col2,DATE_ADD(&#39;2021-10-21 23:32:12&#39;,INTERVAL 1 SECOND) AS col3,DATE_ADD(&#39;2021-10-21 23:32:12&#39;,INTERVAL &#39;1_1&#39; MINUTE_SECOND) AS col4,DATE_ADD(NOW(), INTERVAL -1 YEAR) AS col5, #可以是负数DATE_ADD(NOW(), INTERVAL &#39;1_1&#39; YEAR_MONTH) AS col6 #需要单引号FROM DUAL;SELECT DATE_SUB(&#39;2021-01-21&#39;,INTERVAL 31 DAY) AS col1,SUBDATE(&#39;2021-01-21&#39;,INTERVAL 31 DAY) AS col2,DATE_SUB(&#39;2021-01-21 02:01:01&#39;,INTERVAL &#39;1 1&#39; DAY_HOUR) AS col3FROM DUAL; 函数 说明 ADDTIME(time1,time2) 返回time1加上time2的时间。当time2为一个数字时，代表的是 秒 ，可以为负数 SUBTIME(time1,time2) 返回time1减去time2后的时间。当time2为一个数字时，代表的 是 秒 ，可以为负数 DATEDIFF(date1,date2) 返回date1 - date2的日期间隔天数 TIMEDIFF(time1, time2) 返回time1 - time2的时间间隔 FROM_DAYS(N） 返回从0000年1月1日起，N天以后的日期 TO_DAYS(date) 返回日期date距离0000年1月1日的天数 LAST_DAY(date) 返回date所在月份的最后一天的日期 MAKEDATE(year,n) 针对给定年份与所在年份中的天数返回一个日期 MAKETIME(hour,minute,second) 将给定的小时、分钟和秒组合成时间并返回 PERIOD_ADD(time,n) 返回time加上n后的时间 SELECTADDTIME(NOW(),20),SUBTIME(NOW(),30),SUBTIME(NOW(),&#39;1:1:3&#39;),DATEDIFF(NOW(),&#39;2021-10-01&#39;),TIMEDIFF(NOW(),&#39;2021-10-25 22:10:10&#39;),FROM_DAYS(366),TO_DAYS(&#39;0000-12-25&#39;),LAST_DAY(NOW()),MAKEDATE(YEAR(NOW()),12),MAKETIME(10,21,23),PERIOD_ADD(20200101010101,10)FROM DUAL; SELECT ADDTIME(NOW(), 50);mysql&amp;gt; SELECT SUBTIME(NOW(), &#39;1:1:1&#39;);+-------------------------+| SUBTIME(NOW(), &#39;1:1:1&#39;) |+-------------------------+| 2019-12-15 21:23:50 |+-------------------------+1 row in set (0.00 sec)mysql&amp;gt; SELECT SUBTIME(NOW(), &#39;-1:-1:-1&#39;);+----------------------------+| SUBTIME(NOW(), &#39;-1:-1:-1&#39;) |+----------------------------+| 2019-12-15 22:25:11 |+----------------------------+1 row in set, 1 warning (0.00 sec)mysql&amp;gt; SELECT FROM_DAYS(366);+----------------+| FROM_DAYS(366) |+----------------+| 0001-01-01 |+----------------+1 row in set (0.00 sec)mysql&amp;gt; SELECT MAKEDATE(2020,1);+------------------+| MAKEDATE(2020,1) |+------------------+| 2020-01-01 |+------------------+1 row in set (0.00 sec)mysql&amp;gt; SELECT MAKEDATE(2020,32);+-------------------+| MAKEDATE(2020,32) |+-------------------+| 2020-02-01 |+-------------------+1 row in set (0.00 sec)mysql&amp;gt; SELECT MAKETIME(1,1,1);+-----------------+| MAKETIME(1,1,1) |+-----------------+| 01:01:01 |+-----------------+1 row in set (0.00 sec)mysql&amp;gt; SELECT PERIOD_ADD(20200101010101,1);+------------------------------+| PERIOD_ADD(20200101010101,1) |+------------------------------+| 20200101010102 |+------------------------------+1 row in set (0.00 sec)mysql&amp;gt; SELECT TO_DAYS(NOW());+----------------+| TO_DAYS(NOW()) |+----------------+| 737773 |+----------------+1 row in set (0.00 sec)举例：查询 7 天内的新增用户数有多少？SELECT COUNT(*) as num FROM new_user WHERE TO_DAYS(NOW())-TO_DAYS(regist_time)&amp;lt;=74.7 日期的格式化与解析 函数 说明 DATE_FORMAT(date,fmt) 按照字符串fmt格式化日期date值 TIME_FORMAT(time,fmt) 按照字符串fmt格式化时间time值 GET_FORMAT(date_type,format_type 返回日期字符串的显示格式 STR_TO_DATE(str, fmt) 按照字符串fmt对str进行解析，解析为一个日期 GET_FORMAT函数中date_type和format_type参数取值如下：mysql&amp;gt; SELECT DATE_FORMAT(NOW(), &#39;%H:%i:%s&#39;);+--------------------------------+| DATE_FORMAT(NOW(), &#39;%H:%i:%s&#39;) |+--------------------------------+| 22:57:34 |+--------------------------------+1 row in set (0.00 sec)SELECT STR_TO_DATE(&#39;09/01/2009&#39;,&#39;%m/%d/%Y&#39;)FROM DUAL;SELECT STR_TO_DATE(&#39;20140422154706&#39;,&#39;%Y%m%d%H%i%s&#39;)FROM DUAL;SELECT STR_TO_DATE(&#39;2014-04-22 15:47:06&#39;,&#39;%Y-%m-%d %H:%i:%s&#39;)FROM DUAL;mysql&amp;gt; SELECT GET_FORMAT(DATE, &#39;USA&#39;);+-------------------------+| GET_FORMAT(DATE, &#39;USA&#39;) |+-------------------------+| %m.%d.%Y |+-------------------------+1 row in set (0.00 sec)SELECT DATE_FORMAT(NOW(),GET_FORMAT(DATE,&#39;USA&#39;)),FROM DUAL;mysql&amp;gt; SELECT STR_TO_DATE(&#39;2020-01-01 00:00:00&#39;,&#39;%Y-%m-%d&#39;);+-----------------------------------------------+| STR_TO_DATE(&#39;2020-01-01 00:00:00&#39;,&#39;%Y-%m-%d&#39;) |+-----------------------------------------------+| 2020-01-01 |+-----------------------------------------------+1 row in set, 1 warning (0.00 sec)5. 流程控制函数​ 流程处理函数可以根据不同的条件，执行不同的处理流程，可以在SQL语句中实现不同的条件选择。 MySQL中的流程处理函数主要包括IF()、IFNULL()和CASE()函数。 函数 说明 IF(value,value1,value2) 如果value的值为TRUE，返回value1， 否则返回value2 IFNULL(value1, value2) 如果value1不为NULL，返回value1，否 则返回value2 CASE WHEN 条件1 THEN 结果1 WHEN 条件2 THEN 结果2 …. [ELSE resultn] END 相当于Java的if…else if…else… CASE expr WHEN 常量值1 THEN 值1 WHEN 常量值1 THEN 值1 …. [ELSE 值n] END 相当于Java的switch…case… SELECT IF(1 &amp;gt; 0,&#39;正确&#39;,&#39;错误&#39;)-&amp;gt;正确SELECT IFNULL(null,&#39;Hello Word&#39;)-&amp;gt;Hello WordSELECT CASEWHEN 1 &amp;gt; 0THEN &#39;1 &amp;gt; 0&#39;WHEN 2 &amp;gt; 0THEN &#39;2 &amp;gt; 0&#39;ELSE &#39;3 &amp;gt; 0&#39;END-&amp;gt;1 &amp;gt; 0SELECT CASE 1WHEN 1 THEN &#39;我是1&#39;WHEN 2 THEN &#39;我是2&#39;ELSE &#39;你是谁&#39;SELECT employee_id,salary, CASE WHEN salary&amp;gt;=15000 THEN &#39;高薪&#39;WHEN salary&amp;gt;=10000 THEN &#39;潜力股&#39;WHEN salary&amp;gt;=8000 THEN &#39;屌丝&#39;ELSE &#39;草根&#39; END &quot;描述&quot;FROM employees;SELECT oid,`status`, CASE `status` WHEN 1 THEN &#39;未付款&#39;WHEN 2 THEN &#39;已付款&#39;WHEN 3 THEN &#39;已发货&#39;WHEN 4 THEN &#39;确认收货&#39;ELSE &#39;无效订单&#39; ENDFROM t_order; SELECT CASE WHEN 1 &amp;gt; 0 THEN &#39;yes&#39; WHEN 1 &amp;lt;= 0 THEN &#39;no&#39; ELSE &#39;unknown&#39; END; SELECT CASE WHEN 1 &amp;lt; 0 THEN &#39;yes&#39; WHEN 1 = 0 THEN &#39;no&#39; ELSE &#39;unknown&#39; END;SELECT CASE 1 WHEN 0 THEN 0 WHEN 1 THEN 1 ELSE -1 END;mysql&amp;gt; SELECT CASE -1 WHEN 0 THEN 0 WHEN 1 THEN 1 ELSE -1 END;+-------------------------------------------------+| CASE -1 WHEN 0 THEN 0 WHEN 1 THEN 1 ELSE -1 END |+-------------------------------------------------+| -1 |+-------------------------------------------------+1 row in set (0.00 sec)SELECT employee_id,12 * salary * (1 + IFNULL(commission_pct,0))FROM employees;SELECT last_name, job_id, salary,CASE job_id WHEN &#39;IT_PROG&#39; THEN 1.10*salaryWHEN &#39;ST_CLERK&#39; THEN 1.15*salaryWHEN &#39;SA_REP&#39; THEN 1.20*salaryELSE salary END &quot;REVISED_SALARY&quot;FROM employees;6. 加密与解密函数​ 加密与解密函数主要用于对数据库中的数据进行加密和解密处理，以防止数据被他人窃取。这些函数在 保证数据库安全时非常有用。(一般不在数据库加密，了解一下) 函数 代码块 PASSWORD(str） 【这个函数Mysql8.0没有了】返回字符串str的加密版本，41位长的字符串。加密结果 不可 逆 ，常用于用户的密码加密 MD5(str) 返回字符串str的md5加密后的值，也是一种加密方式。若参数为 NULL，则会返回NULL SHA(str) 从原明文密码str计算并返回加密后的密码字符串，当参数为 NULL时，返回NULL。 SHA加密算法比MD5更加安全 。 ENCODE(value,password_seed) 【这个函数Mysql8.0没有了】返回使用password_seed作为加密密码加密value DECODE(value,password_seed) 【这个函数Mysql8.0没有了】返回使用password_seed作为加密密码解密value 可以看到，ENCODE(value,password_seed)函数与DECODE(value,password_seed)函数互为反函数。SELECT PASSWORD(&#39;mysql&#39;), PASSWORD(NULL); SELECT MD5(&#39;AAA&#39;) ,SHA(&#39;BBB&#39;) FROM DUAL;+----------------------------------+------------------------------------------+| MD5(&#39;AAA&#39;) | SHA(&#39;BBB&#39;) |+----------------------------------+------------------------------------------+| e1faffb3e614e6c2fba74296962386b7 | aa6878b1c31a9420245df1daffb7b223338737a3 |+----------------------------------+------------------------------------------+7. MySQL信息函数​ MySQL中内置了一些可以查询MySQL信息的函数，这些函数主要用于帮助数据库开发或运维人员更好地 对数据库进行维护工作。 函数 说明 VERSION() 返回当前MySQL的版本号 CONNECTION_ID() 返回当前MySQL服务器的连接数 DATABASE()，SCHEMA() 返回MySQL命令行当前所在的数据库 USER()，CURRENT_USER()、SYSTEM_USER()， SESSION_USER() 返回当前连接MySQL的用户名，返回结果格式为 “主机名@用户名” CHARSET(value) 返回字符串value自变量的字符集 COLLATION(value) 返回字符串value的比较规则 SELECT DATABASE();+------------+| DATABASE() |+------------+| atguigudb |+------------+1 row in setmysql&amp;gt; SELECT USER(), CURRENT_USER(), SYSTEM_USER(),SESSION_USER();+----------------+----------------+----------------+----------------+| USER() | CURRENT_USER() | SYSTEM_USER() | SESSION_USER() |+----------------+----------------+----------------+----------------+| root@localhost | root@localhost | root@localhost | root@localhost |+----------------+----------------+----------------+----------------+1 row in setmysql&amp;gt; SELECT CHARSET(&#39;ABC&#39;);+----------------+| CHARSET(&#39;ABC&#39;) |+----------------+| utf8mb3 |+----------------+1 row in setmysql&amp;gt; SELECT COLLATION(&#39;ABC&#39;);+------------------+| COLLATION(&#39;ABC&#39;) |+------------------+| utf8_general_ci |+------------------+1 row in set8. 其他函数​ MySQL中有些函数无法对其进行具体的分类，但是这些函数在MySQL的开发和运维过程中也是不容忽视 的。 函数 说明 FORMAT(value,n) 返回对数字value进行格式化后的结果数据。n表示 四舍五入 后保留 到小数点后n位 CONV(value,from,to) 将value的值进行不同进制之间的转换 INET_ATON(ipvalue) 将以点分隔的IP地址转化为一个数字 INET_NTOA(value) 将数字形式的IP地址转化为以点分隔的IP地址 BENCHMARK(n,expr) 将表达式expr重复执行n次。用于测试MySQL处理expr表达式所耗费 的时间 CONVERT(value USING char_code) 将value所使用的字符编码修改为char_code mysql&amp;gt; SELECT FORMAT(123.123, 2), FORMAT(123.523, 0), FORMAT(123.123, -2);+--------------------+--------------------+---------------------+| FORMAT(123.123, 2) | FORMAT(123.523, 0) | FORMAT(123.123, -2) |+--------------------+--------------------+---------------------+| 123.12 | 124 | 123 |+--------------------+--------------------+---------------------+1 row in setmysql&amp;gt; SELECT CONV(16, 10, 2), CONV(8888,10,16), CONV(NULL, 10, 2);+-----------------+------------------+-------------------+| CONV(16, 10, 2) | CONV(8888,10,16) | CONV(NULL, 10, 2) |+-----------------+------------------+-------------------+| 10000 | 22B8 | NULL |+-----------------+------------------+-------------------+1 row in setmysql&amp;gt; SELECT INET_ATON(&#39;192.168.1.100&#39;);+----------------------------+| INET_ATON(&#39;192.168.1.100&#39;) |+----------------------------+| 3232235876 |+----------------------------+1 row in set# 以“192.168.1.100”为例，计算方式为192乘以256的3次方，加上168乘以256的2次方，加上1乘以256，再加上100。mysql&amp;gt; SELECT INET_NTOA(3232235876);+-----------------------+| INET_NTOA(3232235876) |+-----------------------+| 192.168.1.100 |+-----------------------+1 row in set# 函数执行n次所需要的时间mysql&amp;gt; SELECT BENCHMARK(1, MD5(&#39;mysql&#39;));+----------------------------+| BENCHMARK(1, MD5(&#39;mysql&#39;)) |+----------------------------+| 0 |+----------------------------+1 row in setmysql&amp;gt; SELECT CHARSET(&#39;mysql&#39;), CHARSET(CONVERT(&#39;mysql&#39; USING &#39;utf8&#39;));+------------------+----------------------------------------+| CHARSET(&#39;mysql&#39;) | CHARSET(CONVERT(&#39;mysql&#39; USING &#39;utf8&#39;)) |+------------------+----------------------------------------+| utf8mb3 | utf8mb3 |+------------------+----------------------------------------+1 row in set9. 课后练习 显示系统时间SELECT NOW()FROM DUAL;+---------------------+| NOW() |+---------------------+| 2022-05-13 10:18:08 |+---------------------+1 row in set 显示员工号，姓名，工资以及工资提高20%后的结果SELECT employee_id,last_name,salary,salary*1.2 &quot;new salary&quot;FROM employees;+-------------+-------------+--------+------------+| employee_id | last_name | salary | new salary |+-------------+-------------+--------+------------+| 100 | King | 24000 | 28800.00 || 101 | Kochhar | 17000 | 20400.00 || 102 | De Haan | 17000 | 20400.00 || 103 | Hunold | 9000 | 10800.00 || 104 | Ernst | 6000 | 7200.00 || 105 | Austin | 4800 | 5760.00 || 106 | Pataballa | 4800 | 5760.00 || 107 | Lorentz | 4200 | 5040.00 || 108 | Greenberg | 12000 | 14400.00 || 109 | Faviet | 9000 | 10800.00 || 110 | Chen | 8200 | 9840.00 || 111 | Sciarra | 7700 | 9240.00 || 112 | Urman | 7800 | 9360.00 || 113 | Popp | 6900 | 8280.00 || 114 | Raphaely | 11000 | 13200.00 || 115 | Khoo | 3100 | 3720.00 || 116 | Baida | 2900 | 3480.00 || 117 | Tobias | 2800 | 3360.00 || 118 | Himuro | 2600 | 3120.00 || 119 | Colmenares | 2500 | 3000.00 | 将员工的姓名按首字母排序，并写出姓名的长度SELECT last_name,LENGTH(last_name) &quot;name_length&quot;FROM employeesORDER BY name_length ASC;+-------------+-------------+| last_name | name_length |+-------------+-------------+| Gee | 3 || Seo | 3 || Lee | 3 || Fox | 3 || Fay | 3 || King | 4 || Chen | 4 || Popp | 4 || Khoo | 4 || Rajs | 4 || Hall | 4 || King | 4 || Ande | 4 || Ozer | 4 || Abel | 4 || Bull | 4 || Bell | 4 || Baer | 4 || Ernst | 5 || Urman | 5 || Baida | 5 || Weiss | 5 || Fripp | 5 || Nayer | 5 || Olson | 5 || Patel | 5 || Matos | 5 | 查询员工id，last_name,salary,并作为一个列输出，别名为OUT_PUTSELECT CONCAT(employee_id ,&quot;,&quot;, last_name,&quot;,&quot;,salary) &quot;OUT_PUT&quot;FROM employees;+-------------------------+| OUT_PUT |+-------------------------+| 100,King,24000.00 || 101,Kochhar,17000.00 || 102,De Haan,17000.00 || 103,Hunold,9000.00 || 104,Ernst,6000.00 || 105,Austin,4800.00 || 106,Pataballa,4800.00 || 107,Lorentz,4200.00 || 108,Greenberg,12000.00 || 109,Faviet,9000.00 || 110,Chen,8200.00 || 111,Sciarra,7700.00 || 112,Urman,7800.00 || 113,Popp,6900.00 || 114,Raphaely,11000.00 || 115,Khoo,3100.00 || 116,Baida,2900.00 || 117,Tobias,2800.00 || 118,Himuro,2600.00 || 119,Colmenares,2500.00 || 120,Weiss,8000.00 || 121,Fripp,8200.00 | 查询公司各员工的工作年数、工作天数，并按工作年数降序排列SELECT employee_id ,DATEDIFF(NOW(),hire_date)/365 &quot;worked_years&quot; ,DATEDIFF(NOW(),hire_date) &quot;worked_days&quot;FROM employeesORDER BY worked_years DESC;+-------------+--------------+-------------+| employee_id | worked_years | worked_days |+-------------+--------------+-------------+| 100 | 34.9288 | 12749 || 200 | 34.6767 | 12657 || 101 | 32.663 | 11922 || 103 | 32.3781 | 11818 || 104 | 31 | 11315 || 102 | 29.3479 | 10712 || 203 | 27.9507 | 10202 || 204 | 27.9507 | 10202 || 205 | 27.9507 | 10202 || 206 | 27.9507 | 10202 || 109 | 27.7589 | 10132 || 108 | 27.7562 | 10131 || 114 | 27.4493 | 10019 || 122 | 27.0521 | 9874 || 115 | 27.0055 | 9857 || 137 | 26.8493 | 9800 || 141 | 26.589 | 9705 || 184 | 26.3096 | 9603 | 查询员工姓名，hire_date，department_id,满足以下条件： 雇佣时间在1997年之后，department_id为80,90或100，commission_pct不为空 SELECT last_name,hire_date,department_idFROM employeesWHERE department_id IN (80,90,100)AND commission_pct IS NOT NULL AND hire_date &amp;gt;=&#39;1997-01-01&#39;;+------------+------------+---------------+| last_name | hire_date | department_id |+------------+------------+---------------+| Partners | 1997-01-05 | 80 || Errazuriz | 1997-03-10 | 80 || Cambrault | 1999-10-15 | 80 || Zlotkey | 2000-01-29 | 80 || Tucker | 1997-01-30 | 80 || Bernstein | 1997-03-24 | 80 || Hall | 1997-08-20 | 80 || Olsen | 1998-03-30 | 80 || Cambrault | 1998-12-09 | 80 || Tuvault | 1999-11-23 | 80 || Smith | 1997-03-10 | 80 || Doran | 1997-12-15 | 80 || Sewall | 1998-11-03 | 80 || Vishney | 1997-11-11 | 80 || Greene | 1999-03-19 | 80 || Marvins | 2000-01-24 | 80 || Lee | 2000-02-23 | 80 || Ande | 2000-03-24 | 80 || Banda | 2000-04-21 | 80 || Ozer | 1997-03-11 | 80 || Bloom | 1998-03-23 | 80 || Fox | 1998-01-24 | 80 || Smith | 1999-02-23 | 80 || Bates | 1999-03-24 | 80 || Kumar | 2000-04-21 | 80 || Hutton | 1997-03-19 | 80 || Taylor | 1998-03-24 | 80 || Livingston | 1998-04-23 | 80 || Johnson | 2000-01-04 | 80 |+------------+------------+---------------+29 rows in set 查询公司中入职超过10000天的员工姓名、入职时间SELECT last_name,hire_dateFROM employeesWHERE DATEDIFF(NOW(),hire_date) &amp;gt;= 10000;+-----------+------------+| last_name | hire_date |+-----------+------------+| King | 1987-06-17 || Kochhar | 1989-09-21 || De Haan | 1993-01-13 || Hunold | 1990-01-03 || Ernst | 1991-05-21 || Greenberg | 1994-08-17 || Faviet | 1994-08-16 || Raphaely | 1994-12-07 || Whalen | 1987-09-17 || Mavris | 1994-06-07 || Baer | 1994-06-07 || Higgins | 1994-06-07 || Gietz | 1994-06-07 |+-----------+------------+13 rows in set 做一个查询，产生下面的结果&amp;lt;last_name&amp;gt;earns&amp;lt;salary&amp;gt; monthly but wants &amp;lt;salary*3&amp;gt;SELECT CONCAT (last_name,&#39; earns &#39;,TRUNCATE(salary,0),&#39; monthly but wants &#39;,TRUNCATE(salary*3,0))FROM employees;+--------------------------------------------------------------------------------------------+| CONCAT (last_name,&#39; earns &#39;,TRUNCATE(salary,0),&#39; monthly but wants &#39;,TRUNCATE(salary*3,0)) |+--------------------------------------------------------------------------------------------+| King earns 24000 monthly but wants 72000 || Kochhar earns 17000 monthly but wants 51000 || De Haan earns 17000 monthly but wants 51000 || Hunold earns 9000 monthly but wants 27000 || Ernst earns 6000 monthly but wants 18000 || Austin earns 4800 monthly but wants 14400 || Pataballa earns 4800 monthly but wants 14400 || Lorentz earns 4200 monthly but wants 12600 || Greenberg earns 12000 monthly but wants 36000 || Faviet earns 9000 monthly but wants 27000 || Chen earns 8200 monthly but wants 24600 || Sciarra earns 7700 monthly but wants 23100 || Urman earns 7800 monthly but wants 23400 | 使用case-when，按照下面的条件JOB GRADEAD_PRES A ST_MAN BIT_PROG CSA_REP DST_CLERK E得到如下结果SELECT last_name &quot;Last_name&quot;,job_id &quot;Job_id&quot;, CASE job_id WHEN &#39;AD_PRES&#39; THEN &#39;A&#39;WHEN &#39;ST_MAN&#39; THEN &#39;B&#39;WHEN &#39;IT_PROG&#39; THEN &#39;C&#39;WHEN &#39;SA_REP&#39; THEN &#39;D&#39;WHEN &#39;ST_CLERK&#39; THEN &#39;E&#39;END &quot;Grade&quot;FROM employees;+-------------+------------+-------+| Last_name | Job_id | Grade |+-------------+------------+-------+| King | AD_PRES | A || Kochhar | AD_VP | NULL || De Haan | AD_VP | NULL || Hunold | IT_PROG | C || Ernst | IT_PROG | C || Austin | IT_PROG | C || Pataballa | IT_PROG | C || Lorentz | IT_PROG | C || Greenberg | FI_MGR | NULL || Faviet | FI_ACCOUNT | NULL || Chen | FI_ACCOUNT | NULL || Sciarra | FI_ACCOUNT | NULL || Urman | FI_ACCOUNT | NULL || Popp | FI_ACCOUNT | NULL || Raphaely | PU_MAN | NULL || Khoo | PU_CLERK | NULL |参考链接 MySQL数据库教程天花板，mysql安装到mysql高级，强！硬！" }, { "title": "MySQL多表查询", "url": "/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/", "categories": "数据库", "tags": "MySQL", "date": "2021-06-06 00:00:00 +0800", "snippet": "​ 多表查询，也称为关联查询，指两个或更多个表一起完成查询操作。 前提条件：这些一起查询的表之间是有关系的（一对一、一对多），它们之间一定是有关联字段，这个 关联字段可能建立了外键，也可能没有建立外键。比如：员工表和部门表，这两个表依靠“部门编号”进 行关联。1. 多表查询分类讲解1. 等值连接等值连接SELECT employees.employee_id, employees.last_name,employees.department_id, departments.department_id,departments.location_idFROM employees, departmentsWHERE employees.department_id = departments.department_id; 拓展1：多个连接条件与 AND 操作符 拓展2：区分重复的列名 多个表中有相同列时，必须在列名之前加上表名前缀。 在不同表中具有相同列名的列可以用 表名 加以区分。 SELECT employees.last_name, departments.department_name,employees.department_idFROM employees, departmentsWHERE employees.department_id = departments.department_id; 拓展3：表的别名 使用别名可以简化查询 列名前使用表名前缀可以提高查询效率 SELECT e.employee_id, e.last_name, e.department_id,d.department_id, d.location_idFROM employees e , departments dWHERE e.department_id = d.department_id;需要注意的是，如果我们使用了表的别名，在查询字段中、过滤条件中就只能使用别名进行代替， 不能使用原有的表名，否则就会报错。阿里开发规范 ：【 强制 】：对于数据库中表记录的查询和变更，只要涉及多个表，都需要在列名前加表的别名（或表名）进行限定。【 说明 】：对多表进行查询记录、更新记录、删除记录时，如果对操作列没有限定表的别名（或表名），并且操作列在多个表中存在时，就会抛异常。【 正例 】 ：select t1.name from table_first as t1 , table_second as t2 where t1.id=t2.id;【 反例 】 ：在某业务中，由于多表关联查询语句没有加表的别名（或表名）的限制，正常运行两年后，最近在 某个表中增加一个同名字段，在预发布环境做数据库变更后，线上查询语句出现出 1052 异常：Column &#39;name&#39; in field list is ambiguous。 拓展4：连接多个表总结：连接 n个表,至少需要n-1个连接条件。比如，连接三个表，至少需要两个连接条件。2. 非等值连接SELECT e.last_name, e.salary, j.grade_levelFROM employees e, job_grades jWHERE e.salary BETWEEN j.lowest_sal AND j.highest_sal;3. 自连接​ 当table1和table2本质上是同一张表，只是用取别名的方式虚拟成两张表以代表不同的意义。然后两 个表再进行内连接，外连接等查询。4.内连接和外连接​ 内连接: 合并具有同一列的两个以上的表的行, 结果集中不包含一个表与另一个表不匹配的行​ 外连接: 两个表在连接过程中除了返回满足连接条件的行以外还返回左（或右）表中不满足条件的 行 ，这种连接称为左（或右） 外连接。没有匹配的行时, 结果表中相应的列为空(NULL)。 如果是左外连接，则连接条件中左边的表也称为 主表 ，右边的表称为 从表 。 如果是右外连接，则连接条件中右边的表也称为 主表 ，左边的表称为 从表 。2.多表查询实现1.内连接(INNER JOIN)的实现SELECT 字段列表FROM A表 INNER JOIN B表ON 关联条件WHERE 等其他子句;SELECT e.employee_id, e.last_name, e.department_id,d.department_id, d.location_idFROM employees e JOIN departments dON (e.department_id = d.department_id);SELECT employee_id, city, department_nameFROM employees eJOIN departments dON d.department_id = e.department_idJOIN locations lON d.location_id = l.location_id;2.外连接(OUTER JOIN)的实现2.1 左外连接(LEFT OUTER JOIN)语法：#实现查询结果是ASELECT 字段列表FROM A表 LEFT JOIN B表ON 关联条件WHERE 等其他子句;举例：SELECT e.last_name, e.department_id, d.department_nameFROM employees eLEFT OUTER JOIN departments dON (e.department_id = d.department_id) ;2.2 右外连接(RIGHT OUTER JOIN)语法：#实现查询结果是BSELECT 字段列表FROM A表 RIGHT JOIN B表ON 关联条件WHERE 等其他子句;举例：SELECT e.last_name, e.department_id, d.department_nameFROM employees eRIGHT OUTER JOIN departments dON (e.department_id = d.department_id) ;2.3 满外连接(FULL OUTER JOIN) 满外连接的结果 = 左右表匹配的数据 + 左表没有匹配到的数据 + 右表没有匹配到的数据。 SQL99是支持满外连接的。使用FULL JOIN 或 FULL OUTER JOIN来实现。 需要注意的是，MySQL不支持FULL JOIN，但是可以用 LEFT JOIN UNION RIGHT join代替。3. UNION的使用​ 合并查询结果 利用UNION关键字，可以给出多条SELECT语句，并将它们的结果组合成单个结果集。合并时，两个表对应的列数和数据类型必须相同，并且相互对应。​ 各个SELECT语句之间使用UNION或UNION ALL关键字分隔。语法格式：SELECT column,... FROM table1UNION [ALL]SELECT column,... FROM table2UNION操作符UNION 操作符返回两个查询的结果集的并集，去除重复记录。UNION ALL操作符UNION ALL操作符返回两个查询的结果集的并集。对于两个结果集的重复部分，不去重。​ 注意：执行UNION ALL语句时所需要的资源比UNION语句少。如果明确知道合并数据后的结果数据 不存在重复数据，或者不需要去除重复的数据，则尽量使用UNION ALL语句，以提高数据查询的效 率。举例：查询部门编号&amp;gt;90或邮箱包含a的员工信息#方式1SELECT * FROM employees WHERE email LIKE &#39;%a%&#39; OR department_id&amp;gt;90;#方式2SELECT * FROM employees WHERE email LIKE &#39;%a%&#39;UNIONSELECT * FROM employees WHERE department_id&amp;gt;90;举例：查询中国用户中男性的信息以及美国用户中年男性的用户信息SELECT id,cname FROM t_chinamale WHERE csex=&#39;男&#39;UNION ALLSELECT id,tname FROM t_usmale WHERE tGender=&#39;male&#39;;3. 七种SQL JOINS的实现4.1 代码实现#中图：内连接 A∩BSELECT employee_id,last_name,department_nameFROM employees e JOIN departments dON e.`department_id` = d.`department_id`;#左上图：左外连接SELECT employee_id,last_name,department_nameFROM employees e LEFT JOIN departments dON e.`department_id` = d.`department_id`;#右上图：右外连接SELECT employee_id,last_name,department_nameFROM employees e RIGHT JOIN departments dON e.`department_id` = d.`department_id`;#左中图：A - A∩BSELECT employee_id,last_name,department_nameFROM employees e LEFT JOIN departments dON e.`department_id` = d.`department_id`WHERE d.`department_id` IS NULL#右中图：B-A∩BSELECT employee_id,last_name,department_nameFROM employees e RIGHT JOIN departments dON e.`department_id` = d.`department_id`WHERE e.`department_id` IS NULL#左下图：满外连接# 左中图 + 右上图 A∪BSELECT employee_id,last_name,department_nameFROM employees e LEFT JOIN departments dON e.`department_id` = d.`department_id`WHERE d.`department_id` IS NULLUNION ALL #没有去重操作，效率高SELECT employee_id,last_name,department_nameFROM employees e RIGHT JOIN departments dON e.`department_id` = d.`department_id`;#右下图#左中图 + 右中图 A ∪B- A∩B 或者 (A - A∩B) ∪ （B - A∩B）SELECT employee_id,last_name,department_nameFROM employees e LEFT JOIN departments dON e.`department_id` = d.`department_id`WHERE d.`department_id` IS NULLUNION ALLSELECT employee_id,last_name,department_nameFROM employees e RIGHT JOIN departments dON e.`department_id` = d.`department_id`WHERE e.`department_id` IS NULL4.2 小结左中图#实现A - A∩Bselect 字段列表from A表 left join B表on 关联条件where 从表关联字段 is null and 等其他子句;右中图#实现B - A∩Bselect 字段列表from A表 right join B表on 关联条件where 从表关联字段 is null and 等其他子句;左下图#实现查询结果是A∪B#用左外的A，union 右外的Bselect 字段列表from A表 left join B表on 关联条件where 等其他子句unionselect 字段列表from A表 right join B表on 关联条件where 等其他子句;右下图#实现A∪B - A∩B 或 (A - A∩B) ∪ （B - A∩B）#使用左外的 (A - A∩B) union 右外的（B - A∩B）select 字段列表from A表 left join B表on 关联条件where 从表关联字段 is null and 等其他子句unionselect 字段列表from A表 right join B表on 关联条件where 从表关联字段 is null and 等其他子句4.课后练习 显示所有员工的姓名、部门号和部门名称SELECT e.last_name,e.department_id,d.department_nameFROM employees e JOIN departments dON e.`department_id` = d.`department_id`; 查询90号部门员工的job_id和90号部门员工的location_idSELECT e.job_id, d.location_idFROM employees e JOIN departments dON e.`department_id` = d.`department_id`WHERE d.`department_id` = 90; 选择所有有奖金的员工的last_name，department_name，location_id，citySELECT last_name,department_name,location_id,cityFROM employees e LEFT JOIN departments dON e.`department_id` = d.`department_id`LEFT JOIN locations l ON d.`location_id` = l.`location_id`WHERE e.`commission_pct` IS NOT NULL; 选择city在Toronto工作的员工的last_name，job_id，department_id，department_nameSELECT last_name，job_id，department_id，department_nameFROM employees e JOIN departments dON e.`department_id` = d.`department_id`JOIN locations lON d.`location_id` = l.`location_id`WHERE l.`city` = &#39;Toronto&#39;; 查询员工所在的部门名称、部门地址、姓名、工作、工资，其中员工所在部门的部门名称为ExecutiveSELECT department_name,street_address,last_name,job_id,salaryFROM employees e LEFT JOIN departments dON e.`department_id` = d.`department_id`LEFT JOIN locations lON d.`location_id` = l.`location_id`WHERE d.`department_name` = &#39;Executive&#39;; 选择指定员工的姓名、员工号、他的管理者的姓名、员工号，结果显示如下 employees Emp manager Mgrjack 101 tom 02 SELECT emp.last_name &quot;employees&quot;,emp.employee_id &quot;Emp&quot;,mgr.last_name &quot;manager&quot;,mgr.employee_id &quot;Mgr&quot;FROM employees emp LEFT JOIN employees mgrON emp.manager_id = mgr.employee_id; 查询哪些部门没有员工SELECT d.department_idFROM departments d LEFT JOIN employees eON d.`department_id` = e.`department_id`WHERE e.`department_id` IS NULL; 查询哪个城市没有部门SELECT l.location_id,l.cityFROM locations l LEFT JOIN departments dON l.`location_id` = d.`location_id`WHERE d.`location` IS NULL; 查询部门名为Sales或IT的员工信息SELECT e.employee_id,e.last_name,e.department_id,d.department_nameFROM employees e JOIN departments d ON e.`department_id` = d.`department_id`WHERE d.`department_name` IN (&#39;Sales&#39;,&#39;IT&#39;);参考链接 MySQL数据库教程天花板，mysql安装到mysql高级，强！硬！" }, { "title": "MySQL排序和分页", "url": "/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E6%8E%92%E5%BA%8F%E5%92%8C%E5%88%86%E9%A1%B5/", "categories": "数据库", "tags": "MySQL", "date": "2021-06-05 00:00:00 +0800", "snippet": "1. 排序数据1.1 排序规则使用 ORDER BY 子句排序 ASC（ascend）: 升序 DESC（descend）:降序 ORDER BY 子句在SELECT语句的结尾。1.2 单列排序SELECT last_name, job_id, department_id, hire_dateFROM employeesORDER BY hire_date ;SELECT last_name, job_id, department_id, hire_dateFROM employeesORDER BY hire_date DESC ;SELECT employee_id, last_name, salary*12 annsalFROM employeesORDER BY annsal;1.3 多列排序SELECT last_name, department_id, salaryFROM employeesORDER BY department_id, salary DESC; 可以使用不在SELECT列表中的列排序。 在对多列进行排序的时候，首先排序的第一列必须有相同的列值，才会对第二列进行排序。 如果第 一列数据中所有值都是唯一的，将不再对第二列进行排序。2. 分页2.1 背景​ 背景1：查询返回的记录太多了，查看起来很不方便，怎么样能够实现分页查询呢？ 背景2：表里有 4 条数据，我们只想要显示第 2、3 条数据怎么办呢？2.2 实现规则 分页原理 所谓分页显示，就是将数据库中的结果集，一段一段显示出来需要的条件。 MySQL中使用 LIMIT 实现分页 格式： LIMIT [位置偏移量,] 行数第一个“位置偏移量”参数指示MySQL从哪一行开始显示，是一个可选参数，如果不指定“位置偏移 量”，将会从表中的第一条记录开始（第一条记录的位置偏移量是0，第二条记录的位置偏移量是 1，以此类推）；第二个参数“行数”指示返回的记录条数。--前10条记录：SELECT * FROM 表名 LIMIT 0,10;或者SELECT * FROM 表名 LIMIT 10;--第11至20条记录：SELECT * FROM 表名 LIMIT 10,10;--第21至30条记录：SELECT * FROM 表名 LIMIT 20,10;MySQL 8.0中可以使用“LIMIT 3 OFFSET 4”，意思是获取从第5条记录开始后面的3条记录，和“LIMIT 4,3;”返回的结果相同。分页显式公式：（当前页数-1）*每页条数，每页条数SELECT * FROM tableLIMIT(PageNo - 1)*PageSize,PageSize; 注意：LIMIT 子句必须放在整个SELECT语句的最后！使用 LIMIT 的好处 :​ 约束返回结果的数量可以 减少数据表的网络传输量 ，也可以 提升查询效率 。如果我们知道返回结果只有 1 条，就可以使用 LIMIT 1 ，告诉 SELECT 语句只需要返回一条记录即可。这样的好处就是 SELECT 不需 要扫描完整的表，只需要检索到一条符合条件的记录即可返回。2.3 拓展​ 在不同的 DBMS 中使用的关键字可能不同。在 MySQL、PostgreSQL、MariaDB 和 SQLite 中使用 LIMIT 关 键字，而且需要放到 SELECT 语句的最后面。 如果是 SQL Server 和 Access，需要使用 TOP 关键字，比如： 如果是 SQL Server 和 Access，需要使用 TOP 关键字，比如：SELECT TOP 5 name, hp_max FROM heros ORDER BY hp_max DESC 如果是 DB2，使用 FETCH FIRST 5 ROWS ONLY 这样的关键字：SELECT name, hp_max FROM heros ORDER BY hp_max DESC FETCH FIRST 5 ROWS ONLY 如果是 Oracle，你需要基于 ROWNUM 来统计行数：SELECT rownum,last_name,salary FROM employees WHERE rownum &amp;lt; 5 ORDER BY salary DESC;​ 需要说明的是，这条语句是先取出来前 5 条数据行，然后再按照 hp_max 从高到低的顺序进行排序。但 这样产生的结果和上述方法的并不一样。我会在后面讲到子查询，你可以使用SELECT rownum, last_name,salaryFROM (SELECT last_name,salaryFROM employeesORDER BY salary DESC)WHERE rownum &amp;lt; 10;3.练习 查询员工的姓名、部门号和年薪，按年薪的降序、姓名的升序显示SELECT last_name,department_id,salary *12 annual_salaryFROM employeesORDER BY annual_salary DESC,last_name ASC; 选择工资不在8000到17000的员工的姓名和工资，按工资降序，显示第21 到 40位置的数据SELECT last_name,salaryFROM employeesWHERE salary NOT BETWEEN 8000 AND 17000ORDER BY salary DESCLIMIT 20,20; 查询邮箱中包含e的员工信息，并先按邮箱的字节数降序，再按部门号升序SELECT emplyee_id,last_name,email,department_idFROM employeesWHERE email REGEXP &#39;[e]&#39;ORDER BY LENGTH(email) DESC,department_id;" }, { "title": "MySQL运算符", "url": "/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E8%BF%90%E7%AE%97%E7%AC%A6/", "categories": "数据库", "tags": "MySQL", "date": "2021-06-04 00:00:00 +0800", "snippet": "1. 算术运算符​ 算术运算符主要用于数学运算，其可以连接运算符前后的两个数值或表达式，对数值或表达式进行加 （+）、减（-）、乘（*）、除（/）和取模（%）运算。1．加法与减法运算符mysql&amp;gt; SELECT 100, 100 + 0, 100 - 0, 100 + 50, 100 + 50 -30, 100 + 35.5, 100 - 35.5FROM dual;+-----+---------+---------+----------+--------------+------------+------------+| 100 | 100 + 0 | 100 - 0 | 100 + 50 | 100 + 50 -30 | 100 + 35.5 | 100 - 35.5 |+-----+---------+---------+----------+--------------+------------+------------+| 100 | 100 | 100 | 150 | 120 | 135.5 | 64.5 |+-----+---------+---------+----------+--------------+------------+------------+1 row in set (0.00 sec) 一个整数类型的值对整数进行加法和减法操作，结果还是一个整数； 一个整数类型的值对浮点数进行加法和减法操作，结果是一个浮点数； 加法和减法的优先级相同，进行先加后减操作与进行先减后加操作的结果是一样的； 在Java中，+的左右两边如果有字符串，那么表示字符串的拼接。但是在MySQL中+只表示数值相加。如果遇到非数值类型，先尝试转成数值，如果转失败，就按0计算。（补充：MySQL 中字符串拼接要使用字符串函数CONCAT()实现）2．乘法与除法运算符mysql&amp;gt; SELECT 100, 100 * 1, 100 * 1.0, 100 / 1.0, 100 / 2,100 + 2 * 5 / 2,100 /3, 100DIV 0 FROM dual;+-----+---------+-----------+-----------+---------+-----------------+---------+-----------+| 100 | 100 * 1 | 100 * 1.0 | 100 / 1.0 | 100 / 2 | 100 + 2 * 5 / 2 | 100 /3 | 100DIV 0 |+-----+---------+-----------+-----------+---------+-----------------+---------+-----------+| 100 | 100 | 100.0 | 100.0000 | 50.0000 | 105.0000 | 33.3333 |NULL |+-----+---------+-----------+-----------+---------+-----------------+---------+-----------+1 row in set (0.00 sec)#计算出员工的年基本工资SELECT employee_id,salary,salary * 12 annual_salFROM employees;由运算结果可以得出如下结论： 一个数乘以整数1和除以整数1后仍得原数； 一个数乘以浮点数1和除以浮点数1后变成浮点数，数值与原数相等； 一个数除以整数后，不管是否能除尽，结果都为一个浮点数； 一个数除以另一个数，除不尽时，结果为一个浮点数，并保留到小数点后4位； 乘法和除法的优先级相同，进行先乘后除操作与先除后乘操作，得出的结果相同。 在数学运算中，0不能用作除数，在MySQL中，一个数除以0为NULL。3．求模（求余）运算符将t22表中的字段i对3和5进行求模（求余）运算。mysql&amp;gt; SELECT 12 % 3, 12 MOD 5 FROM dual;+--------+----------+| 12 % 3 | 12 MOD 5 |+--------+----------+| 0 | 2 |+--------+----------+1 row in set (0.00 sec)# 筛选出employee_id是偶数的员工SELECT * FROM employeesWHERE employee_id MOD 2 = 0;可以看到，100对3求模后的结果为3，对5求模后的结果为0。2. 比较运算符​ 比较运算符用来对表达式左边的操作数和右边的操作数进行比较，比较的结果为真则返回1，比较的结果 为假则返回0，其他情况则返回NULL。​ 比较运算符经常被用来作为SELECT查询语句的条件来使用，返回符合条件的结果记录。1. 等号运算符​ 等号运算符（=）判断等号两边的值、字符串或表达式是否相等，如果相等则返回1，不相等则返回 0。在使用等号运算符时，遵循如下规则： 如果等号两边的值、字符串或表达式都为字符串，则MySQL会按照字符串进行比较，其比较的 是每个字符串中字符的ANSI编码是否相等。 如果等号两边的值都是整数，则MySQL会按照整数来比较两个值的大小。 如果等号两边的值一个是整数，另一个是字符串，则MySQL会将字符串转化为数字进行比较。 如果等号两边的值、字符串或表达式中有一个为NULL，则比较结果为NULL。对比：SQL中赋值符号使用 : =mysql&amp;gt; SELECT 1 = 1, 1 = &#39;1&#39;, 1 = 0, &#39;a&#39; = &#39;a&#39;, (5 + 3) = (2 + 6), &#39;&#39; = NULL , NULL =NULL;+-------+---------+-------+-----------+-------------------+-----------+-------------+| 1 = 1 | 1 = &#39;1&#39; | 1 = 0 | &#39;a&#39; = &#39;a&#39; | (5 + 3) = (2 + 6) | &#39;&#39; = NULL | NULL = NULL |+-------+---------+-------+-----------+-------------------+-----------+-------------+| 1 | 1 | 0 | 1 | 1 | NULL | NULL |+-------+---------+-------+-----------+-------------------+-----------+-------------+1 row in set (0.00 sec)#查询salary=10000，注意在Java中比较是==SELECT employee_id,salary FROM employees WHERE salary = 10000;2. 安全等于运算符​ 安全等于运算符（&amp;lt;=&amp;gt;）与等于运算符（=）的作用是相似的， 唯一的区别 是‘&amp;lt;=&amp;gt;’可 以用来对NULL进行判断。在两个操作数均为NULL时，其返回值为1，而不为NULL；当一个操作数为NULL 时，其返回值为0，而不为NULL。安全等于运算符就是为NULL而生mysql&amp;gt; SELECT 1 &amp;lt;=&amp;gt; &#39;1&#39;, 1 &amp;lt;=&amp;gt; 0, &#39;a&#39; &amp;lt;=&amp;gt; &#39;a&#39;, (5 + 3) &amp;lt;=&amp;gt; (2 + 6), &#39;&#39; &amp;lt;=&amp;gt; NULL,NULL&amp;lt;=&amp;gt; NULL FROM dual;+-----------+---------+-------------+---------------------+-------------+---------------+| 1 &amp;lt;=&amp;gt; &#39;1&#39; | 1 &amp;lt;=&amp;gt; 0 | &#39;a&#39; &amp;lt;=&amp;gt; &#39;a&#39; | (5 + 3) &amp;lt;=&amp;gt; (2 + 6) | &#39;&#39; &amp;lt;=&amp;gt; NULL | NULL &amp;lt;=&amp;gt;NULL |+-----------+---------+-------------+---------------------+-------------+---------------+| 1 | 0 | 1 | 1 | 0 | 1 |+-----------+---------+-------------+---------------------+-------------+---------------+1 row in set (0.00 sec)3. 不等于运算符​ 不等于运算符（&amp;lt;&amp;gt;和!=）用于判断两边的数字、字符串或者表达式的值是否不相等， 如果不相等则返回1，相等则返回0。不等于运算符不能判断NULL值。如果两边的值有任意一个为NULL， 或两边都为NULL，则结果为NULL。 SQL语句示例如下：mysql&amp;gt; SELECT 1 &amp;lt;&amp;gt; 1, 1 != 2, &#39;a&#39; != &#39;b&#39;, (3+4) &amp;lt;&amp;gt; (2+6), &#39;a&#39; != NULL, NULL &amp;lt;&amp;gt; NULL;+--------+--------+------------+----------------+-------------+--------------+| 1 &amp;lt;&amp;gt; 1 | 1 != 2 | &#39;a&#39; != &#39;b&#39; | (3+4) &amp;lt;&amp;gt; (2+6) | &#39;a&#39; != NULL | NULL &amp;lt;&amp;gt; NULL |+--------+--------+------------+----------------+-------------+--------------+| 0 | 1 | 1 | 1 | NULL | NULL |+--------+--------+------------+----------------+-------------+--------------+1 row in set (0.00 sec)4. 空运算符​ 空运算符（IS NULL或者ISNULL）判断一个值是否为NULL，如果为NULL则返回1，否则返回 0。 SQL语句示例如下：mysql&amp;gt; SELECT NULL IS NULL, ISNULL(NULL), ISNULL(&#39;a&#39;), 1 IS NULL;+--------------+--------------+-------------+-----------+| NULL IS NULL | ISNULL(NULL) | ISNULL(&#39;a&#39;) | 1 IS NULL |+--------------+--------------+-------------+-----------+| 1 | 1 | 0 | 0 |+--------------+--------------+-------------+-----------+1 row in set (0.00 sec)#查询commission_pct等于NULL。比较如下的四种写法SELECT employee_id,commission_pct FROM employees WHERE commission_pct IS NULL;SELECT employee_id,commission_pct FROM employees WHERE commission_pct &amp;lt;=&amp;gt; NULL;SELECT employee_id,commission_pct FROM employees WHERE ISNULL(commission_pct);SELECT employee_id,commission_pct FROM employees WHERE commission_pct = NULL;SELECT last_name, manager_idFROM employeesWHERE manager_id IS NULL;5. 非空运算符​ 非空运算符（IS NOT NULL）判断一个值是否不为NULL，如果不为NULL则返回1，否则返 回0。 SQL语句示例如下：mysql&amp;gt; SELECT NULL IS NOT NULL, &#39;a&#39; IS NOT NULL, 1 IS NOT NULL;+------------------+-----------------+---------------+| NULL IS NOT NULL | &#39;a&#39; IS NOT NULL | 1 IS NOT NULL |+------------------+-----------------+---------------+| 0 | 1 | 1 |+------------------+-----------------+---------------+1 row in set (0.01 sec)6. 最小值运算符​ 语法格式为：LEAST(值1，值2，…，值n)。​ 其中，“值n”表示参数列表中有n个值。在有 两个或多个参数的情况下，返回最小值。mysql&amp;gt; SELECT LEAST (1,0,2), LEAST(&#39;b&#39;,&#39;a&#39;,&#39;c&#39;), LEAST(1,NULL,2);+---------------+--------------------+-----------------+| LEAST (1,0,2) | LEAST(&#39;b&#39;,&#39;a&#39;,&#39;c&#39;) | LEAST(1,NULL,2) |+---------------+--------------------+-----------------+| 0 | a | NULL |+---------------+--------------------+-----------------+1 row in set (0.00 sec)​ 由结果可以看到，当参数是整数或者浮点数时，LEAST将返回其中最小的值；当参数为字符串时，返回字 母表中顺序最靠前的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。7. 最大值运算符​ 语法格式为：GREATEST(值1，值2，…，值n)。​ 其中，n表示参数列表中有n个值。当有 两个或多个参数时，返回值为最大值。假如任意一个自变量为NULL，则GREATEST()的返回值为NULL。mysql&amp;gt; SELECT GREATEST(1,0,2), GREATEST(&#39;b&#39;,&#39;a&#39;,&#39;c&#39;), GREATEST(1,NULL,2);+-----------------+-----------------------+--------------------+| GREATEST(1,0,2) | GREATEST(&#39;b&#39;,&#39;a&#39;,&#39;c&#39;) | GREATEST(1,NULL,2) |+-----------------+-----------------------+--------------------+| 2 | c | NULL |+-----------------+-----------------------+--------------------+1 row in set (0.00 sec)​ 由结果可以看到，当参数中是整数或者浮点数时，GREATEST将返回其中最大的值；当参数为字符串时， 返回字母表中顺序最靠后的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。8. BETWEEN AND运算符 BETWEEN运算符使用的格式通常为SELECT D FROM TABLE WHERE C BETWEEN A AND B，此时，当C大于或等于A，并且C小于或等于B时，结果为1，否则结果为0。【包含边界】mysql&amp;gt; SELECT 1 BETWEEN 0 AND 1, 10 BETWEEN 11 AND 12, &#39;b&#39; BETWEEN &#39;a&#39; AND &#39;c&#39;; +-------------------+----------------------+-------------------------+| 1 BETWEEN 0 AND 1 | 10 BETWEEN 11 AND 12 | &#39;b&#39; BETWEEN &#39;a&#39; AND &#39;c&#39; |+-------------------+----------------------+-------------------------+| 1 | 0 | 1 |+-------------------+----------------------+-------------------------+1 row in set (0.00 sec)SELECT last_name, salaryFROM employeesWHERE salary BETWEEN 2500 AND 3500;9. IN运算符​ IN运算符用于判断给定的值是否是IN列表中的一个值，如果是则返回1，否则返回0。如果给定的值为NULL，或者IN列表中存在NULL，则结果为NULL。mysql&amp;gt; SELECT &#39;a&#39; IN (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;), 1 IN (2,3), NULL IN (&#39;a&#39;,&#39;b&#39;), &#39;a&#39; IN (&#39;a&#39;, NULL);+----------------------+------------+-------------------+--------------------+| &#39;a&#39; IN (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;) | 1 IN (2,3) | NULL IN (&#39;a&#39;,&#39;b&#39;) | &#39;a&#39; IN (&#39;a&#39;, NULL) |+----------------------+------------+-------------------+--------------------+| 1 | 0 | NULL | 1 |+----------------------+------------+-------------------+--------------------+1 row in set (0.00 sec)SELECT employee_id, last_name, salary, manager_idFROM employeesWHERE manager_id IN (100, 101, 201);10. NOT IN运算符​ NOT IN运算符用于判断给定的值是否不是IN列表中的一个值，如果不是IN列表中的一 个值，则返回1，否则返回0。mysql&amp;gt; SELECT &#39;a&#39; NOT IN (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;), 1 NOT IN (2,3);+--------------------------+----------------+| &#39;a&#39; NOT IN (&#39;a&#39;,&#39;b&#39;,&#39;c&#39;) | 1 NOT IN (2,3) |+--------------------------+----------------+| 0 | 1 |+--------------------------+----------------+1 row in set (0.00 sec)11. LIKE运算符​ LIKE运算符主要用来匹配字符串，通常用于模糊匹配，如果满足条件则返回1，否则返回 0。如果给定的值或者匹配条件为NULL，则返回结果为NULL。​ LIKE运算符通常使用如下通配符：%：匹配0个或多个字符。_：只能匹配一个字符。mysql&amp;gt; SELECT NULL LIKE &#39;abc&#39;, &#39;abc&#39; LIKE NULL;+-----------------+-----------------+| NULL LIKE &#39;abc&#39; | &#39;abc&#39; LIKE NULL |+-----------------+-----------------+| NULL | NULL |+-----------------+-----------------+1 row in set (0.00 sec)SELECT first_nameFROM employeesWHERE first_name LIKE &#39;S%&#39;;SELECT last_nameFROM employeesWHERE last_name LIKE &#39;_o%&#39;;ESCAPE​ 回避特殊符号的：使用转义符。例如：将[%]转为[$%]、[]转为[$]，然后再加上[ESCAPE‘$’]即可。举例：要求第二个字符为_SELECT job_idFROM jobsWHERE job_id LIKE &quot;IT\\_%&quot;;如果使用\\表示转义，要省略ESCAPE。MySQL中如果不用\\，则要加上ESCAPE。SELECT job_idFROM jobsWHERE job_id LIKE &#39;IT$_%&#39; escape &#39;$&#39;;12. REGEXP运算符 REGEXP运算符用来匹配字符串，语法格式为： expr REGEXP 匹配条件 。如果expr满足匹配条件，返回 1；如果不满足，则返回0。若expr或匹配条件任意一个为NULL，则结果为NULL。（1）‘^’匹配以该字符后面的字符开头的字符串。（2）‘$’匹配以该字符前面的字符结尾的字符串。（3）‘.’匹配任何一个单字符。（4）“[...]”匹配在方括号内的任何字符。例如，“[abc]”匹配“a”或“b”或“c”。为了命名字符的范围，使用一个‘-’。“[a-z]”匹配任何字母，而“[0-9]”匹配任何数字。（5）‘*’匹配零个或多个在它前面的字符。例如，“x*”匹配任何数量的‘x’字符，“[0-9]*”匹配任何数量的数字，而“*”匹配任何数量的任何字符。3.逻辑运算符​ 逻辑运算符主要用来判断表达式的真假，在MySQL中，逻辑运算符的返回结果为1、0或者NULL。MySQL中支持4种逻辑运算符如下：1. 逻辑非运算符逻辑非（NOT或!）运算符表示当给定的值为0时返回1；当给定的值为非0值时返回0； 当给定的值为NULL时，返回NULL。mysql&amp;gt; SELECT NOT 1, NOT 0, NOT(1+1), NOT !1, NOT NULL;+-------+-------+----------+--------+----------+| NOT 1 | NOT 0 | NOT(1+1) | NOT !1 | NOT NULL |+-------+-------+----------+--------+----------+| 0 | 1 | 0 | 1 | NULL |+-------+-------+----------+--------+----------+1 row in set, 1 warning (0.00 sec)SELECT last_name, job_idFROM employeesWHERE job_id NOT IN (&#39;IT_PROG&#39;, &#39;ST_CLERK&#39;, &#39;SA_REP&#39;);2. 逻辑与运算符​ 逻辑与（AND或&amp;amp;&amp;amp;）运算符是当给定的所有值均为非0值，并且都不为NULL时，返回 1；当给定的一个值或者多个值为0时则返回0；否则返回NULL。mysql&amp;gt; SELECT 1 AND -1, 0 AND 1, 0 AND NULL, 1 AND NULL;+----------+---------+------------+------------+| 1 AND -1 | 0 AND 1 | 0 AND NULL | 1 AND NULL |+----------+---------+------------+------------+| 1 | 0 | 0 | NULL |+----------+---------+------------+------------+1 row in set (0.00 sec)SELECT employee_id, last_name, job_id, salaryFROM employeesWHERE salary &amp;gt;=10000AND job_id LIKE &#39;%MAN%&#39;;3. 逻辑或运算符 ​ 逻辑或（OR或   ）运算符是当给定的值都不为NULL，并且任何一个值为非0值时，则返 回1，否则返回0；当一个值为NULL，并且另一个值为非0值时，返回1，否则返回NULL；当两个值都为 NULL时，返回NULL。 mysql&amp;gt; SELECT 1 OR -1, 1 OR 0, 1 OR NULL, 0 || NULL, NULL || NULL;+---------+--------+-----------+-----------+--------------+| 1 OR -1 | 1 OR 0 | 1 OR NULL | 0 || NULL | NULL || NULL |+---------+--------+-----------+-----------+--------------+| 1 | 1 | 1 | NULL | NULL |+---------+--------+-----------+-----------+--------------+1 row in set, 2 warnings (0.00 sec)#查询基本薪资不在9000-12000之间的员工编号和基本薪资SELECT employee_id,salary FROM employeesWHERE NOT (salary &amp;gt;= 9000 AND salary &amp;lt;= 12000);SELECT employee_id,salary FROM employeesWHERE salary &amp;lt;9000 OR salary &amp;gt; 12000;SELECT employee_id,salary FROM employeesWHERE salary NOT BETWEEN 9000 AND 12000;SELECT employee_id, last_name, job_id, salaryFROM employeesWHERE salary &amp;gt;= 10000OR job_id LIKE &#39;%MAN%&#39;;注意： OR可以和AND一起使用，但是在使用时要注意两者的优先级，由于AND的优先级高于OR，因此先 对AND两边的操作数进行操作，再与OR中的操作数结合。4. 逻辑异或运算符​ 逻辑异或（XOR）运算符是当给定的值中任意一个值为NULL时，则返回NULL；如果 两个非NULL的值都是0或者都不等于0时，则返回0；如果一个值为0，另一个值不为0时，则返回1。mysql&amp;gt; SELECT 1 XOR -1, 1 XOR 0, 0 XOR 0, 1 XOR NULL, 1 XOR 1 XOR 1, 0 XOR 0 XOR 0;+----------+---------+---------+------------+---------------+---------------+| 1 XOR -1 | 1 XOR 0 | 0 XOR 0 | 1 XOR NULL | 1 XOR 1 XOR 1 | 0 XOR 0 XOR 0 |+----------+---------+---------+------------+---------------+---------------+| 0 | 1 | 0 | NULL | 1 | 0 |+----------+---------+---------+------------+---------------+---------------+1 row in set (0.00 sec)select last_name,department_id,salaryfrom employeeswhere department_id in (10,20) XOR salary &amp;gt; 8000;4. 位运算符​ 位运算符是在二进制数上进行计算的运算符。位运算符会先将操作数变成二进制数，然后进行位运算， 最后将计算结果从二进制变回十进制数。​ MySQL支持的位运算符如下：1．按位与运算符​ 按位与（&amp;amp;）运算符将给定值对应的二进制数逐位进行逻辑与运算。当给定值对应的二 进制位的数值都为1时，则该位返回1，否则返回0。mysql&amp;gt; SELECT 1 &amp;amp; 10, 20 &amp;amp; 30;+--------+---------+| 1 &amp;amp; 10 | 20 &amp;amp; 30 |+--------+---------+| 0 | 20 |+--------+---------+1 row in set (0.00 sec)​ 1的二进制数为0001，10的二进制数为1010，所以1 &amp;amp; 10的结果为0000，对应的十进制数为0。20的二进制 数为10100，30的二进制数为11110，所以20 &amp;amp; 30的结果为10100，对应的十进制数为20。2. 按位或运算符 按位或（|）运算符将给定的值对应的二进制数逐位进行逻辑或运算。当给定值对应的 二进制位的数值有一个或两个为1时，则该位返回1，否则返回0。mysql&amp;gt; SELECT 1 | 10, 20 | 30;+--------+---------+| 1 | 10 | 20 | 30 |+--------+---------+| 11 | 30 |+--------+---------+1 row in set (0.00 sec ​ 1的二进制数为0001，10的二进制数为1010，所以1 10的结果为1011，对应的十进制数为11。20的二进 制数为10100，30的二进制数为11110，所以20 30的结果为11110，对应的十进制数为30。 3. 按位异或运算符​ 按位异或（^）运算符将给定的值对应的二进制数逐位进行逻辑异或运算。当给定值 对应的二进制位的数值不同时，则该位返回1，否则返回0。mysql&amp;gt; SELECT 1 ^ 10, 20 ^ 30;+--------+---------+| 1 ^ 10 | 20 ^ 30 |+--------+---------+| 11 | 10 |+--------+---------+1 row in set (0.00 sec)​ 1的二进制数为0001，10的二进制数为1010，所以1 ^ 10的结果为1011，对应的十进制数为11。20的二进 制数为10100，30的二进制数为11110，所以20 ^ 30的结果为01010，对应的十进制数为10。 再举例：mysql&amp;gt; SELECT 12 &amp;amp; 5, 12 | 5,12 ^ 5 FROM DUAL;+--------+--------+--------+| 12 &amp;amp; 5 | 12 | 5 | 12 ^ 5 |+--------+--------+--------+| 4 | 13 | 9 |+--------+--------+--------+1 row in set (0.00 sec)4. 按位取反运算符​ 按位取反（~）运算符将给定的值的二进制数逐位进行取反操作，即将1变为0，将0变 为1。mysql&amp;gt; SELECT 10 &amp;amp; ~1;+---------+| 10 &amp;amp; ~1 |+---------+| 10 |+---------+1 row in set (0.00 sec)​ 由于按位取反（~）运算符的优先级高于按位与（&amp;amp;）运算符的优先级，所以10 &amp;amp; ~1，首先，对数字1进 行按位取反操作，结果除了最低位为0，其他位都为1，然后与10进行按位与操作，结果为10。5. 按位右移运算符​ 按位右移（»）运算符将给定的值的二进制数的所有位右移指定的位数。右移指定的 位数后，右边低位的数值被移出并丢弃，左边高位空出的位置用0补齐。mysql&amp;gt; SELECT 1 &amp;gt;&amp;gt; 2, 4 &amp;gt;&amp;gt; 2;+--------+--------+| 1 &amp;gt;&amp;gt; 2 | 4 &amp;gt;&amp;gt; 2 |+--------+--------+| 0 | 1 |+--------+--------+1 row in set (0.00 sec)​ 1的二进制数为0000 0001，右移2位为0000 0000，对应的十进制数为0。4的二进制数为0000 0100，右移2 位为0000 0001，对应的十进制数为1。6. 按位左移运算符 按位左移（«）运算符将给定的值的二进制数的所有位左移指定的位数。左移指定的 位数后，左边高位的数值被移出并丢弃，右边低位空出的位置用0补齐mysql&amp;gt; SELECT 1 &amp;lt;&amp;lt; 2, 4 &amp;lt;&amp;lt; 2;+--------+--------+| 1 &amp;lt;&amp;lt; 2 | 4 &amp;lt;&amp;lt; 2 |+--------+--------+| 4 | 16 |+--------+--------+1 row in set (0.00 sec)​ 1的二进制数为0000 0001，左移两位为0000 0100，对应的十进制数为4。4的二进制数为0000 0100，左移 两位为0001 0000，对应的十进制数为16。5. 练习 选择工资不在5000到12000的员工的姓名和工资SELECT last_name,salaryFROM employeesWHERE salary between 5000 and 12000; 选择在20或50号部门工作的员工姓名和部门号SELECT last_name ,department_id FROM employeesWHERE department_id IN(20,50); 选择公司中没有管理者的员工姓名和job_idSELECT last_name,job_id,manager_idFROM employeesWHERE manage_id &amp;lt;=&amp;gt; NULL; 选择公司中有奖金的员工姓名，工资和奖金级别SELECT last_name,salary,commission_pctFROM employeesWHERE NOT commission_pct &amp;lt;=&amp;gt; NULL; 选择姓名中有字母a和k的员工姓名SELECT last_name FROM employeesWHERE last_name LIKE &quot;%a%k%&quot; OR LIKE &quot;%k%a%&quot;; 选择员工姓名的第三个字母为a的员工姓名SELECT last_nameFROM employeesWHERE last_name LIKE &quot;__a%&quot;; 显示出表employees中first_name以e结尾的员工信息SELECT first_name,last_nameFROM employeesWHERE first_name LIKE &#39;%e&#39;; 显示出表employees部门编号在80-100之间的姓名、工种SELECT last_name,job_idFROM employeesWHERE department_id between 80 and 100; 显示表employees的manage_id是100,101,110的员工姓名、工资、管理者idSELECT last_name,salary，manager_id FROM employeesWHERE manager_id IN(100,101,110);" }, { "title": "MySQL基本SELECT语句", "url": "/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E5%9F%BA%E6%9C%ACSELECT%E8%AF%AD%E5%8F%A5/", "categories": "数据库", "tags": "MySQL", "date": "2021-06-03 00:00:00 +0800", "snippet": "1. SQL概述1.1 SQL背景知识​ 1946 年，世界上第一台电脑诞生，如今，借由这台电脑发展起来的互联网已经自成江湖。在这几十 年里，无数的技术、产业在这片江湖里沉浮，有的方兴未艾，有的已经几幕兴衰。但在这片浩荡的 波动里，有一门技术从未消失，甚至“老当益壮”，那就是 SQL。​ 45 年前，也就是 1974 年，IBM 研究员发布了一篇揭开数据库技术的论文《SEQUEL：一门结构 化的英语查询语言》，直到今天这门结构化的查询语言并没有太大的变化，相比于其他语 言， SQL 的半衰期可以说是非常长 了。​ 不论是前端工程师，还是后端算法工程师，都一定会和数据打交道，都需要了解如何又快又准确地 提取自己想要的数据。更别提数据分析师了，他们的工作就是和数据打交道，整理不同的报告，以 便指导业务决策。​ SQL（Structured Query Language，结构化查询语言）是使用关系模型的数据库应用语言， 与数据直 接打交道 ，由 IBM 上世纪70年代开发出来。后由美国国家标准局（ANSI）开始着手制定SQL标准， 先后有 SQL-86 ， SQL-89 ， SQL-92 ， SQL-99 等标准。​ SQL 有两个重要的标准，分别是 SQL92 和 SQL99，它们分别代表了 92 年和 99 年颁布的 SQL 标 准，我们今天使用的 SQL 语言依然遵循这些标准。​ 不同的数据库生产厂商都支持SQL语句，但都有特有内容。1.2 SQL 分类SQL语言在功能上主要分为如下3大类：​ DDL（Data Definition Languages、数据定义语言），这些语句定义了不同的数据库、表、视图、索 引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。​ 主要的语句关键字包括 CREATE 、 DROP 、 ALTER 等​ DML（Data Manipulation Language、数据操作语言），用于添加、删除、更新和查询数据库记 录，并检查数据完整性。​ ` 主要的语句关键字包括 INSERT 、 DELETE 、 UPDATE 、 SELECT 等`。【SELECT是SQL语言的基础，最为重要】​ DCL（Data Control Language、数据控制语言），用于定义数据库、表、字段、用户的访问权限和 安全级别。​ 主要的语句关键字包括 GRANT 、 REVOKE 、 COMMIT 、 ROLLBACK 、 SAVEPOINT 等2. SQL语言的规则与规范2.1 基本规则 SQL 可以写在一行或者多行。为了提高可读性，各子句分行写，必要时使用缩进 每条命令以 ; 或 \\g 或 \\G 结束 关键字不能被缩写也不能分行 关于标点符号 必须保证所有的()、单引号、双引号是成对结束的 必须使用英文状态下的半角输入方式 字符串型和日期时间类型的数据可以使用单引号（’ ‘）表示 列的别名，尽量使用双引号（” “），而且不建议省略as 2.2 SQL大小写规范 （建议遵守） MySQL 在 Windows 环境下是大小写不敏感的 **MySQL 在 Linux 环境下是大小写敏感的 ** 数据库名、表名、表的别名、变量名是严格区分大小写的 关键字、函数名、列名(或字段名)、列的别名(字段的别名) 是忽略大小写的。 推荐采用统一的书写规范： 数据库名、表名、表别名、字段名、字段别名等都小写 SQL 关键字、函数名、绑定变量等都大写 2.3 注 释可以使用如下格式的注释结构单行注释：#注释文字(MySQL特有的方式)单行注释：-- 注释文字(--后面必须包含一个空格。)多行注释：/* 注释文字 */2.4 命名规则（暂时了解） 数据库、表名不得超过30个字符，变量名限制为29个 必须只能包含 A–Z, a–z, 0–9, _共63个字符 数据库名、表名、字段名等对象名中间不要包含空格 同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名 必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使 用`（着重号）引起来 保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据 类型在一个表里是整数，那在另一个表里可就别变成字符型了2.5 数据导入指令​ 在命令行客户端登录mysql，使用source指令导入mysql&amp;gt; source d:\\mysqldb.sqlmysql&amp;gt; desc employees;+----------------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------------+-------------+------+-----+---------+-------+| employee_id | int(6) | NO | PRI | 0 | || first_name | varchar(20) | YES | | NULL | || last_name | varchar(25) | NO | | NULL | || email | varchar(25) | NO | UNI | NULL | || phone_number | varchar(20) | YES | | NULL | || hire_date | date | NO | | NULL | || job_id | varchar(10) | NO | MUL | NULL | || salary | double(8,2) | YES | | NULL | || commission_pct | double(2,2) | YES | | NULL | || manager_id | int(6) | YES | MUL | NULL | || department_id | int(4) | YES | MUL | NULL | |+----------------+-------------+------+-----+---------+-------+11 rows in set (0.00 sec)3.基本的SELECT语句3.0 SELECT…SELECT 1; #没有任何子句SELECT 9/2; #没有任何子句3.1 SELECT … FROMSELECT 标识选择哪些列FROM 标识从哪个表中选择选择全部列：SELECT 标识选择哪些列FROM 标识从哪个表中选择​ 一般情况下，除非需要使用表中所有的字段数据，最好不要使用通配符‘*’。使用通配符虽然可以节 省输入查询语句的时间，但是获取不需要的列数据通常会降低查询和所使用的应用程序的效率。​ 通配符的优势是，当不知道所需要的列的名称时，可以通过它获取它们。​ 在生产环境下，不推荐你直接使用 SELECT * 进行查询。选择特定的列：SELECT department_id, location_idFROM departments;​ MySQL中的SQL语句是不区分大小写的，因此SELECT和select的作用是相同的。但是，许多开发人 员习惯将关键字大写、数据列和表名小写，读者也应该养成一个良好的编程习惯，这样写出来的代码更容易阅读和维护。3.2 列的别名 重命名一个列 便于计算 紧跟列名，也可以在列名和别名之间加入关键字AS，别名使用双引号，以便在别名中包含空格或特 殊的字符并区分大小写。 AS 可以省略 建议别名简短，见名知意举例SELECT last_name AS name, commission_pct commFROM employees;3.3 去除重复行默认情况下，查询会返回全部行，包括重复行。SELECT department_idFROM employees;107 rows in set在SELECT语句中使用关键字DISTINCT去除重复行SELECT DISTINCT department_idFROM employees;这里有两点需要注意： DISTINCT 需要放到所有列名的前面。如果写成 SELECT salary, DISTINCT department_id FROM employees 会报错。 DISTINCT 其实是对后面所有列名的组合进行去重，你能看到最后的结果是 74 条，因为这 74 个部 门id不同，都有 salary 这个属性值。如果你想要看都有哪些不同的部门（department_id），只需要写 DISTINCT department_id 即可，后面不需要再加其他的列名了。3.4 空值参与运算所有运算符或列值遇到null值，运算的结果都为nullSELECT employee_id,salary,commission_pct,12 * salary * (1 + commission_pct) &quot;annual_sal&quot;FROM employees;​ 这里你一定要注意，在 MySQL 里面， 空值不等于空字符串。​ 一个空字符串的长度是 0，而一个空值的长度是空。而且，在 MySQL 里面，空值是占用空间的。3.5 着重号错误的mysql&amp;gt; SELECT * FROM ORDER;ERROR 1064 (42000): You have an error in your SQL syntax; check the manual thatcorresponds to your MySQL server version for the right syntax to use near &#39;ORDER&#39; atline 1正确的mysql&amp;gt; SELECT * FROM `ORDER`;+----------+------------+| order_id | order_name |+----------+------------+| 1 | shkstart || 2 | tomcat || 3 | dubbo |+----------+------------+3 rows in set (0.00 sec)mysql&amp;gt; SELECT * FROM `order`;+----------+------------+| order_id | order_name |+----------+------------+| 1 | shkstart || 2 | tomcat || 3 | dubbo |+----------+------------+3 rows in set (0.00 sec)结论: 我们需要保证表中的字段、表名等没有和保留字、数据库系统或常用方法冲突。如果真的相同，请在 SQL语句中使用一对``（着重号）引起来。3.6 查询常数​ SELECT 查询还可以对常数进行查询。对的，就是在 SELECT 查询结果中增加一列固定的常数列。这列的 取值是我们指定的，而不是从数据表中动态取出的。 你可能会问为什么我们还要对常数进行查询呢？​ SQL 中的 SELECT 语法的确提供了这个功能，一般来说我们只从一个表中查询数据，通常不需要增加一个 固定的常数列，但如果我们想整合不同的数据源，用常数列作为这个表的标记，就需要查询常数。 比如说，我们想对 employees 数据表中的员工姓名进行查询，同时增加一列字段 corporation ，这个 字段固定值为“尚硅谷”，可以这样写：SELECT &#39;尚硅谷&#39; as corporation, last_name FROM employees;4. 显示表结构​ 使用DESCRIBE 或 DESC 命令，表示表结构。DESCRIBE employees;或DESC employees;mysql&amp;gt; desc employees;+----------------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------------+-------------+------+-----+---------+-------+| employee_id | int(6) | NO | PRI | 0 | || first_name | varchar(20) | YES | | NULL | || last_name | varchar(25) | NO | | NULL | || email | varchar(25) | NO | UNI | NULL | || phone_number | varchar(20) | YES | | NULL | || hire_date | date | NO | | NULL | || job_id | varchar(10) | NO | MUL | NULL | || salary | double(8,2) | YES | | NULL | || commission_pct | double(2,2) | YES | | NULL | || manager_id | int(6) | YES | MUL | NULL | || department_id | int(4) | YES | MUL | NULL | |+----------------+-------------+------+-----+---------+-------+11 rows in set (0.00 sec)其中，各个字段的含义分别解释如下： Field：表示字段名称。 Type：表示字段类型，这里 barcode、goodsname 是文本型的，price 是整数类型的。 Null：表示该列是否可以存储NULL值。 Key：表示该列是否已编制索引。PRI表示该列是表主键的一部分；UNI表示该列是UNIQUE索引的一 部分；MUL表示在列中某个给定值允许出现多次。 Default：表示该列是否有默认值，如果有，那么值是多少。 Extra：表示可以获取的与给定列有关的附加信息，例如AUTO_INCREMENT等。5. 过滤数据SELECT 字段1,字段2FROM 表名WHERE 过滤条件举例SELECT employee_id, last_name, job_id, department_idFROM employeesWHERE department_id = 90 6. 习题1.查询员工12个月工资的总和，并起别名为ANNUAL SALARYSELECT employee_id, last_name,salary*12*(1+IFNULL(commission_pct,0)) &quot;ANNUAL SALARY&quot;FROM employees;2.查询employee表中去除重复的job_id以后的数据SELECT DISTINCT job_idFROM employees;3.查询工资大于12000的员工姓名和工资SELECT last_name,salary FROM employeesWHERE salary &amp;gt;12000;4.查询员工号为176的员工姓名和部门号SELECT last_name,department_idFROM employeesWHERE employee_id =176;5.显示表department的结构，并查询其中的全部数据DESC departments;SELECT * FROM departments;" }, { "title": "MySQL安装", "url": "/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E5%AE%89%E8%A3%85/", "categories": "数据库", "tags": "MySQL", "date": "2021-06-02 00:00:00 +0800", "snippet": "1. 下载软件官网：https://www.mysql.com下载地址：https://dev.mysql.com/downloads/windows/installer/8.0.html MySQL Community Server 社区版本，开源免费，自由下载，但不提供官方技术支持，适用于大多数普通用户。 MySQL Enterprise Edition 企业版本，需付费，不能在线下载，可以试用30天。提供了更多的功能和更完备的技术支持，更适合于对数据库的功能和可靠性要求较高的企业客户。 MySQL Cluster 集群版，开源免费。用于架设集群服务器，可将几个MySQL Server封装成一个Server。需要在社区版或企业版的基础上使用。 MySQL Cluster CGE 高级集群版，需付费。目前最新版本为 8.0.29 ，发布时间 2022年1月 。2. 安装点击安装，按照步骤一步步来，注意安装路径 Development Machine（开发机器） ：该选项代表典型个人用桌面工作站。此时机器上需要运行 多个应用程序，那么MySQL服务器将占用最少的系统资源。 Server Machine（服务器） ：该选项代表服务器，MySQL服务器可以同其他服务器应用程序一起 运行，例如Web服务器等。MySQL服务器配置成适当比例的系统资源。 Dedicated Machine（专用服务器） ：该选项代表只运行MySQL服务的服务器。MySQL服务器配置 成使用所有可用系统资源。3. MySQL8.0 环境变量如果不配置MySQL环境变量，就不能在命令行直接输入MySQL登录命令。下面说如何配置MySQL的环境 变量：​ 步骤1：在桌面上右击【此电脑】图标，在弹出的快捷菜单中选择【属性】菜单命令。​ 步骤2：打开【系 统】窗口，单击【高级系统设置】链接。​ 步骤3：打开【系统属性】对话框，选择【高级】选项卡，然 后单击【环境变量】按钮。​ 步骤4：打开【环境变量】对话框，在系统变量列表中选择path变量。​ 步骤 5：单击【编辑】按钮，在【编辑环境变量】对话框中，将MySQL应用程序的bin目录（C:\\Program Files\\MySQL\\MySQL Server 8.0\\bin）添加到变量值中，用分号将其与其他路径分隔开。​ 步骤6：添加完成 之后，单击【确定】按钮，这样就完成了配置path变量的操作，然后就可以直接输入MySQL命令来登录 数据库了。4. MySQL8.0登录与停止4.1 服务的启动与停止​ MySQL安装完毕之后，需要启动服务器进程，不然客户端无法连接数据库。 在前面的配置过程中，已经将MySQL安装为Windows服务，并且勾选当Windows启动、停止时，MySQL也 自动启动、停止。 方式1：使用图形界面工具 步骤1：打开windows服务 方式1：计算机（点击鼠标右键）→ 管理（点击）→ 服务和应用程序（点击）→ 服务（点 击） 方式2：控制面板（点击）→ 系统和安全（点击）→ 管理工具（点击）→ 服务（点击） 方式3：任务栏（点击鼠标右键）→ 启动任务管理器（点击）→ 服务（点击） 方式4：单击【开始】菜单，在搜索框中输入“services.msc”，按Enter键确认 步骤2：找到MySQL80（点击鼠标右键）→ 启动或停止（点击）4.2 登录mysql -h 主机名 -P 端口号 -u 用户名 -p密码# 举例mysql -h localhost -P 3306 -u root -pabc123 # 这里我设置的root用户的密码是abc1234.3 Navicat登录​ 使用Navicat会遇到1251问题，这是密码编码方式不对引起的，需要配置后登录。# 1. 通过shell登录mysqlmysql -h localhost -P 3306 -u root -p123456# 2. 修改密码编码方式mysql&amp;gt; use mysql;Database changedmysql&amp;gt; alter user &#39;root&#39;@&#39;localhost&#39; identified with mysql_native_password by &#39;123456&#39;;Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&amp;gt; flush previleges;# 3.刷新权限，重新Navicat连接flush privileges;" }, { "title": "MySQL基础", "url": "/posts/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E5%9F%BA%E7%A1%80/", "categories": "数据库", "tags": "MySQL", "date": "2021-06-01 00:00:00 +0800", "snippet": "1. 数据库功能​ 持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多 通过各种关系数据库来完成。​ 持久化的主要作用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数 据文件中。2.数据库与数据库管理系统2.1 数据库的相关概念 概念 说明 DB：数据库（Database） 即存储数据的“仓库”，其本质是一个文件系统。它保存了一系列有组织的数据。 DBMS：数据库管理系统（Database Management System） 是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控 制。用户通过数据库管理系统访问数据库中表内的数据。 SQL：结构化查询语言（Structured Query Language） 专门用来与数据库通信的语言。 2.2 数据库与数据库管理系统的关系​ 数据库管理系统(DBMS)可以管理多个数据库，一般开发人员会针对每一个应用创建一个数据库。为保存 应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体用户的数据。 数据库管理系统、数据库和表的关系如图所示：2.3 常见的数据库管理系统排名(DBMS)​ 目前互联网上常见的数据库管理软件有Oracle、MySQL、MS SQL Server、DB2、PostgreSQL、Access、 Sybase、Informix这几种。以下是2021年DB-Engines Ranking 对各数据库受欢迎程度进行调查后的统计结 果：（查看数据库最新排名: https://db-engines.com/en/ranking）2.4 常见的数据库介绍Oracle​ 1979 年，Oracle 2 诞生，它是第一个商用的 RDBMS（关系型数据库管理系统）。随着 Oracle 软件的名气 越来越大，公司也改名叫 Oracle 公司。 2007年，总计85亿美金收购BEA Systems。 2009年，总计74亿美金收购SUN。此前的2008年，SUN以10亿美金收购MySQL。意味着Oracle 同时拥有了 MySQL 的管理权，至此 Oracle 在数据库领域中成为绝对的领导者。 2013年，甲骨文超越IBM，成为继Microsoft后全球第二大软件公司。 如今 Oracle 的年收入达到了 400 亿美金，足以证明商用（收费）数据库软件的价值。SQL Server SQL Server SQL Server SQL Server 是微软开发的大型商业数据库，诞生于 1989 年。C#、.net等语言常使用，与WinNT完全集 成，也可以很好地与Microsoft BackOffice产品集成。 DB2​ IBM公司的数据库产品,收费的。常应用在银行系统中。PostgreSQL​ PostgreSQL 的稳定性极强，最符合SQL标准，开放源码，具备商业级DBMS质量。PG对数据量大的文本以 及SQL处理较快。SyBase​ 已经淡出历史舞台。提供了一个非常专业数据建模的工具PowerDesigner。SQLite​ 嵌入式的小型数据库，应用在手机端。 零配置，SQlite3不用安装，不用配置，不用启动，关闭或者配置 数据库实例。当系统崩溃后不用做任何恢复操作，再下次使用数据库的时候自动恢复。informix​ IBM公司出品，取自Information 和Unix的结合，它是第一个被移植到Linux上的商业数据库产品。仅运行 于unix/linux平台，命令行操作。 性能较高，支持集群，适应于安全性要求极高的系统，尤其是银行，证 券系统的应用。 3. MySQL介3.概述3.1 概述 MySQL是一个 开放源代码的关系型数据库管理系统 ，由瑞典MySQL AB（创始人Michael Widenius）公 司1995年开发，迅速成为开源数据库的 No.1。 2008被 Sun 收购（10亿美金），2009年Sun被 Oracle 收购。 MariaDB 应运而生。（MySQL 的创 造者担心 MySQL 有闭源的风险，因此创建了 MySQL 的分支项目 MariaDB） MySQL6.x 版本之后分为 社区版 和 商业版 。 MySQL是一种关联数据库管理系统，将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。 MySQL是开源的，所以你不需要支付额外的费用。 MySQL是可以定制的，采用了 GPL（GNU General Public License） 协议，你可以修改源码来 开发自己的MySQL系统。 MySQL支持大型的数据库。可以处理拥有上千万条记录的大型数据库。 MySQL支持大型数据库，支持5000万条记录的数据仓库，32位系统表文件最大可支持 4GB ，64位系 统支持最大的表文件为 8TB 。 MySQL使用 标准的SQL数据语言 形式。 MySQL可以允许运行于多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、 Java、Perl、PHP和Ruby等。3.2 关于MySQL 8.0​ MySQL从5.7版本直接跳跃发布了8.0版本 ，可见这是一个令人兴奋的里程碑版本。MySQL 8版本在功能上 做了显著的改进与增强，开发者对MySQL的源代码进行了重构，最突出的一点是多MySQL Optimizer优化 器进行了改进。不仅在速度上得到了改善，还为用户带来了更好的性能和更棒的体验3.3 Why choose MySQL?​ 为什么如此多的厂商要选用MySQL？大概总结的原因主要有以下几点： 开放源代码，使用成本低。 性能卓越，服务稳定。 软件体积小，使用简单，并且易于维护。 历史悠久，社区用户非常活跃，遇到问题可以寻求帮助。 许多互联网公司在用，经过了时间的验证。3.4 Oracle vs MySQL​ Oracle 更适合大型跨国企业的使用，因为他们对费用不敏感，但是对性能要求以及安全性有更高的要求。​ MySQL 由于其体积小、速度快、总体拥有成本低，可处理上千万条记录的大型数据库，尤其是开放源码 这一特点，使得很多互联网公司、中小型网站选择了MySQL作为网站数据库（Facebook，Twitter， YouTube，阿里巴巴/蚂蚁金服，去哪儿，美团外卖，腾讯）。4. RDBMS 与 非RDBMS​ 从排名中我们能看出来，关系型数据库绝对是 DBMS 的主流，其中使用最多的 DBMS 分别是 Oracle、 MySQL 和 SQL Server。这些都是关系型数据库（RDBMS）。4.1 关系型数据库(RDBMS)4.1.1 实质​ 这种类型的数据库是 最古老的数据库类型，关系型数据库模型是把复杂的数据结构归结为简单的 二元关系 （即二维表格形式）。​ 关系型数据库以 行(row) 和 列(column) 的形式存储数据，以便于用户理解。这一系列的行和列被 称为 表(table) ，一组表组成了一个库(database)​ 表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用 关系模型 来表示。关系型数据库，就是建立在 关系模型 基础上的数据库。​ SQL 就是关系型数据库的查询语言。4.1.2 优势​ **复杂查询 **可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。​ **事务支持 **使得对于安全性能很高的数据访问要求得以实现4.2 非关系型数据库(非RDBMS)4.2.1 介绍​ 非关系型数据库，可看成传统关系型数据库的功能 阉割版本 ，基于键值对存储数据，不需要经过SQL层 的解析， 性能非常高 。同时，通过减少不常用的功能，进一步提高性能。 目前基本上大部分主流的非关系型数据库都是免费的。4.2.2 非关系型数据库​ 相比于 SQL，NoSQL 泛指非关系型数据库，包括了榜单上的键值型数据库、文档型数据库、搜索引擎和 列存储等，除此以外还包括图形数据库。也只有用 NoSQL 一词才能将这些技术囊括进来。**键值型数据库 **​ 键值型数据库通过 Key-Value 键值的方式来存储数据，其中 Key 和 Value 可以是简单的对象，也可以是复 杂的对象。Key 作为唯一的标识符，优点是查找速度快，在这方面明显优于关系型数据库，缺点是无法 像关系型数据库一样使用条件过滤（比如 WHERE），如果你不知道去哪里找数据，就要遍历所有的键， 这就会消耗大量的计算。​ 键值型数据库典型的使用场景是作为 内存缓存 。 Redis 是最流行的键值型数据库。**文档型数据库 **​ 此类数据库可存放并获取文档，可以是XML、JSON等格式。在数据库中文档作为处理信息的基本单位， 一个文档就相当于一条记录。文档数据库所存放的文档，就相当于键值数据库所存放的“值”。MongoDB 是最流行的文档型数据库。此外，还有CouchDB等。**搜索引擎数据库 **​ 虽然关系型数据库采用了索引提升检索效率，但是针对全文索引效率却较低。搜索引擎数据库是应用在 搜索引擎领域的数据存储形式，由于搜索引擎会爬取大量的数据，并以特定的格式进行存储，这样在检 索的时候才能保证性能最优。核心原理是“倒排索引”。 典型产品：Solr、Elasticsearch、Splunk 等。列式数据库​ 列式数据库是相对于行式存储的数据库，Oracle、MySQL、SQL Server 等数据库都是采用的行式存储 （Row-based），而列式数据库是将数据按照列存储到数据库中，这样做的好处是可以大量降低系统的 I/O，适合于分布式文件系统，不足在于功能相对有限。典型产品：HBase等。图形数据库​ 图形数据库，利用了图这种数据结构存储了实体（对象）之间的关系。图形数据库最典型的例子就是社 交网络中人与人的关系，数据模型主要是以节点和边（关系）来实现，特点在于能高效地解决复杂的关 系问题。 图形数据库顾名思义，就是一种存储图形关系的数据库。它利用了图这种数据结构存储了实体（对象） 之间的关系。关系型数据用于存储明确关系的数据，但对于复杂关系的数据存储却有些力不从心。如社 交网络中人物之间的关系，如果用关系型数据库则非常复杂，用图形数据库将非常简单。典型产品： Neo4J、InfoGrid等。4.2.3 NoSQL的演变 由于 SQL 一直称霸 DBMS，因此许多人在思考是否有一种数据库技术能远离 SQL，于是 NoSQL 诞生了， 但是随着发展却发现越来越离不开 SQL。到目前为止 NoSQL 阵营中的 DBMS 都会有实现类似 SQL 的功 能。下面是“NoSQL”这个名词在不同时期的诠释，从这些释义的变化中可以看出 NoSQL 功能的演变 ：​ 1970：NoSQL = We have no SQL​ 1980：NoSQL = Know SQL​ 2000：NoSQL = No SQL!​ 2005：NoSQL = Not only SQL​ 2013：NoSQL = No, SQL!​ NoSQL 对 SQL 做出了很好的补充，比如实际开发中，有很多业务需求，其实并不需要完整的关系型数据 库功能，非关系型数据库的功能就足够使用了。这种情况下，使用 性能更高 、 成本更低 的非关系型数据 库当然是更明智的选择。比如：日志收集、排行榜、定时器等。4.3 小结 NoSQL 的分类很多，即便如此，在 DBMS 排名中，还是 SQL 阵营的比重更大，影响力前 5 的 DBMS 中有 4 个是关系型数据库，而排名前 20 的 DBMS 中也有 12 个是关系型数据库。所以说，掌握 SQL 是非常有 必要的。整套课程将围绕 SQL 展开。5. 关系型数据库设计规则 关系型数据库的典型数据结构就是 数据表 ，这些数据表的组成都是结构化的（Structured）。 将数据放到表中，表再放到库中。 一个数据库中可以有多个表，每个表都有一个名字，用来标识自己。表名具有唯一性。 表具有一些特性，这些特性定义了数据在表中如何存储，类似Java和Python中 “类”的设计。5.1 表、记录、字段​ E-R（entity-relationship，实体-联系）模型中有三个主要概念是： 实体集 、 属性 、 联系集 。 一个实体集（class）对应于数据库中的一个表（table），一个实体（instance）则对应于数据库表 中的一行（row），也称为一条记录（record）。一个属性（attribute）对应于数据库表中的一列 （column），也称为一个字段（field）。ORM思想 (Object Relational Mapping)体现：数据库中的一个表 &amp;lt;---&amp;gt; Java或Python中的一个类表中的一条数据 &amp;lt;---&amp;gt; 类中的一个对象（或实体）表中的一个列 &amp;lt;----&amp;gt; 类中的一个字段、属性(field)5.2 表的关联关系 表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用 关系模型来表示。 四种：一对一关联、一对多关联、多对多关联、自我引用5.2.1 一对一关联（one-to-one）​ 在实际的开发中应用不多，因为一对一可以创建成一张表。​ 举例：设计 学生表 ：学号、姓名、手机号码、班级、系别、身份证号码、家庭住址、籍贯、紧急 联系人、…拆为两个表：两个表的记录是一一对应关系。 基础信息表 （常用信息）：学号、姓名、手机号码、班级、系别 档案信息表 （不常用信息）：学号、身份证号码、家庭住址、籍贯、紧急联系人、…两种建表原则： 外键唯一：主表的主键和从表的外键（唯一），形成主外键关系，外键唯一。 外键是主键：主表的主键和从表的主键，形成主外键关系。5.2.2 一对多关系（one-to-many）常见实例场景： 客户表和订单表 ， 分类表和商品表 ， 部门表和员工表 。举例：​ 员工表：编号、姓名、…、所属部门​ 部门表：编号、名称、简介一对多建表原则：在从表(多方)创建一个字段，字段作为外键指向主表(一方)的主键5.2.3 多对多（many-to-many）​ 要表示多对多关系，必须创建第三个表，该表通常称为 联接表 ，它将多对多关系划分为两个一对多关系。将这两个表的主键都插入到第三个表中。举例1：学生-课程​ 学生信息表 ：一行代表一个学生的信息（学号、姓名、手机号码、班级、系别…）​ 课程信息表 ：一行代表一个课程的信息（课程编号、授课老师、简介…）​ 选课信息表 ：一个学生可以选多门课，一门课可以被多个学生选择学号 课程编号1 10012 10011 1002举例2：产品-订单​ “订单”表和“产品”表有一种多对多的关系，这种关系是通过与“订单明细”表建立两个一对多关系来 定义的。一个订单可以有多个产品，每个产品可以出现在多个订单中。​ 产品表 ：“产品”表中的每条记录表示一个产品。​ 订单表 ：“订单”表中的每条记录表示一个订单。​ 订单明细表 ：每个产品可以与“订单”表中的多条记录对应，即出现在多个订单中。一个订单 可以与“产品”表中的多条记录对应，即包含多个产品。举例3：用户-角色​ 多对多关系建表原则：需要创建第三张表，中间表中至少两个字段，这两个字段分别作为外键指向 各自一方的主键。5.3.4 自我引用(Self reference)参考链接1.MySQL数据库教程天花板，mysql安装到mysql高级，强！硬！" }, { "title": "前后端分离API文档案例", "url": "/posts/%E5%89%8D%E7%AB%AF-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BBAPI%E6%96%87%E6%A1%A3%E6%A1%88%E4%BE%8B/", "categories": "前端", "tags": "前端Vue", "date": "2021-05-22 00:00:00 +0800", "snippet": "电商管理后台 API 接口文档​ 本文是电商管理系统开发的API接口文档，用来定义前后端数据交互内容，方便前后端分离开发对照使用，提升开发效率1.API V1 接口说明 接口基准地址：http://127.0.0.1:8888/api/private/v1/ 服务端已开启 CORS 跨域支持 API V1 认证统一使用 Token 认证 需要授权的 API ，必须在请求头中使用 Authorization 字段提供 token 令牌 使用 HTTP Status Code 标识状态 数据返回格式统一使用 JSON1.1 支持的请求方法 请求方法 说明 GET（SELECT） 从服务器取出资源（一项或多项） POST（CREATE） 在服务器新建一个资源 PUT（UPDATE） 在服务器更新资源（客户端提供改变后的完整资源） PATCH（UPDATE） 在服务器更新资源（客户端提供改变的属性） DELETE（DELETE） 从服务器删除资源 HEAD 获取资源的元数据 OPTIONS 获取信息，关于资源的哪些属性是客户端可以改变的 1.2 通用返回状态说明 状态码 含义 说明 200 OK 请求成功 201 CREATED 创建成功 204 DELETED 删除成功 400 BAD REQUEST 请求的地址不存在或者包含不支持的参数 401 UNAUTHORIZED 未授权 403 FORBIDDEN 被禁止访问 404 NOT FOUND 请求的资源不存在 422 Unprocesable entity [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误 500 INTERNAL SERVER ERROR 内部错误       2. 登录2.1. 登录验证接口 请求路径：/login 请求方法：post 请求参数 参数名 参数说明 备注 username 用户名 不能为空 password 密码 不能为空 响应参数 参数名 参数说明 备注 id 用户 ID   rid 用户角色 ID   username 用户名   mobile 手机号   email 邮箱   token 令牌 基于 jwt 的令牌 响应数据{ &quot;data&quot;: { &quot;id&quot;: 500, &quot;rid&quot;: 0, &quot;username&quot;: &quot;admin&quot;, &quot;mobile&quot;: &quot;123&quot;, &quot;email&quot;: &quot;123@qq.com&quot;, &quot;token&quot;: &quot;Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1aWQiOjUwMCwicmlkIjowLCJpYXQiOjE1MTI1NDQyOTksImV4cCI6MTUxMjYzMDY5OX0.eGrsrvwHm-tPsO9r_pxHIQ5i5L1kX9RX444uwnRGaIM&quot; }, &quot;meta&quot;: { &quot;msg&quot;: &quot;登录成功&quot;, &quot;status&quot;: 200 }}3. 用户管理3.1. 用户数据列表 请求路径：/users 请求方法：get 请求参数 参数名 参数说明 备注 query 查询参数 可以为空 pagenum 当前页码 不能为空 pagesize 每页显示条数 不能为空 响应参数 参数名 参数说明 备注 total 总记录数   pagenum 当前页码   users 用户数据集合   响应数据{ &quot;data&quot;: { &quot;totalpage&quot;: 5, &quot;pagenum&quot;: 4, &quot;users&quot;: [ { &quot;id&quot;: 25, &quot;username&quot;: &quot;tige117&quot;, &quot;mobile&quot;: &quot;18616358651&quot;, &quot;type&quot;: 1, &quot;email&quot;: &quot;tige112@163.com&quot;, &quot;create_time&quot;: &quot;2017-11-09T20:36:26.000Z&quot;, &quot;mg_state&quot;: true, // 当前用户的状态 &quot;role_name&quot;: &quot;炒鸡管理员&quot; } ] }, &quot;meta&quot;: { &quot;msg&quot;: &quot;获取成功&quot;, &quot;status&quot;: 200 }}3.2. 添加用户 请求路径：/users 请求方法：post 请求参数 参数名 参数说明 备注 username 用户名称 不能为空 password 用户密码 不能为空 email 邮箱 可以为空 mobile 手机号 可以为空 响应参数 参数名 参数说明 备注 id 用户 ID   rid 用户角色 ID   username 用户名   mobile 手机号   email 邮箱   响应数据{ &quot;data&quot;: { &quot;id&quot;: 28, &quot;username&quot;: &quot;tige1200&quot;, &quot;mobile&quot;: &quot;test&quot;, &quot;type&quot;: 1, &quot;openid&quot;: &quot;&quot;, &quot;email&quot;: &quot;test@test.com&quot;, &quot;create_time&quot;: &quot;2017-11-10T03:47:13.533Z&quot;, &quot;modify_time&quot;: null, &quot;is_delete&quot;: false, &quot;is_active&quot;: false }, &quot;meta&quot;: { &quot;msg&quot;: &quot;用户创建成功&quot;, &quot;status&quot;: 201 }}3.3. 修改用户状态 请求路径：users/:uId/state/:type 请求方法：put 请求参数 参数名 参数说明 备注 uId 用户 ID 不能为空携带在url中 type 用户状态 不能为空携带在url中，值为 true 或者 false 响应数据{ &quot;data&quot;: { &quot;id&quot;: 566, &quot;rid&quot;: 30, &quot;username&quot;: &quot;admin&quot;, &quot;mobile&quot;: &quot;123456&quot;, &quot;email&quot;: &quot;bb@itcast.com&quot;, &quot;mg_state&quot;: 0 }, &quot;meta&quot;: { &quot;msg&quot;: &quot;设置状态成功&quot;, &quot;status&quot;: 200 }}3.4. 根据 ID 查询用户信息 请求路径：users/:id 请求方法：get 请求参数 参数名 参数说明 备注 id 用户 ID 不能为空携带在url中 响应参数 参数名 参数说明 备注 id 用户 ID   role_id 角色 ID   mobile 手机号   email 邮箱   响应数据{ &quot;data&quot;: { &quot;id&quot;: 503, &quot;username&quot;: &quot;admin3&quot;, &quot;role_id&quot;: 0, &quot;mobile&quot;: &quot;00000&quot;, &quot;email&quot;: &quot;new@new.com&quot; }, &quot;meta&quot;: { &quot;msg&quot;: &quot;查询成功&quot;, &quot;status&quot;: 200 }}3.5. 编辑用户提交 请求路径：users/:id 请求方法：put 请求参数 参数名 参数说明 备注 id 用户 id 不能为空 参数是url参数:id email 邮箱 可以为空 mobile 手机号 可以为空 响应参数 参数名 参数说明 备注 id 用户 ID   role_id 角色 ID   mobile 手机号   email 邮箱   响应数据/* 200表示成功，500表示失败 */{ &quot;data&quot;: { &quot;id&quot;: 503, &quot;username&quot;: &quot;admin3&quot;, &quot;role_id&quot;: 0, &quot;mobile&quot;: &quot;111&quot;, &quot;email&quot;: &quot;123@123.com&quot; }, &quot;meta&quot;: { &quot;msg&quot;: &quot;更新成功&quot;, &quot;status&quot;: 200 }}3.6. 删除单个用户 请求路径：users/:id 请求方法：delete 请求参数 参数名 参数说明 备注 id 用户 id 不能为空参数是url参数:id 响应数据{ &quot;data&quot;: null, &quot;meta&quot;: { &quot;msg&quot;: &quot;删除成功&quot;, &quot;status&quot;: 200 }}3.7. 分配用户角色 请求路径：users/:id/role 请求方法：put 请求参数 参数名 参数说明 备注 id 用户 ID 不能为空参数是url参数:id rid 角色 id 不能为空参数body参数 响应参数 参数名 参数说明 备注 id 用户 ID   role_id 角色 ID   mobile 手机号   email 邮箱   响应数据{ &quot;data&quot;: { &quot;id&quot;: 508, &quot;rid&quot;: &quot;30&quot;, &quot;username&quot;: &quot;asdf1&quot;, &quot;mobile&quot;: &quot;123123&quot;, &quot;email&quot;: &quot;adfsa@qq.com&quot; }, &quot;meta&quot;: { &quot;msg&quot;: &quot;设置角色成功&quot;, &quot;status&quot;: 200 }}4. 权限管理4.1. 所有权限列表 请求路径：rights/:type 请求方法：get 请求参数 参数名 参数说明 备注 type 类型 值 list 或 tree , list 列表显示权限, tree 树状显示权限,参数是url参数:type 响应参数 参数名 参数说明 备注 id 权限 ID   authName 权限说明   level 权限层级   pid 权限父 ID   path 对应访问路径   响应数据 type=list { &quot;data&quot;: [ { &quot;id&quot;: 101, &quot;authName&quot;: &quot;商品管理&quot;, &quot;level&quot;: &quot;0&quot;, &quot;pid&quot;: 0, &quot;path&quot;: null }, { &quot;id&quot;: 102, &quot;authName&quot;: &quot;订单管理&quot;, &quot;level&quot;: &quot;0&quot;, &quot;pid&quot;: 0, &quot;path&quot;: null } ], &quot;meta&quot;: { &quot;msg&quot;: &quot;获取权限列表成功&quot;, &quot;status&quot;: 200 }}type=tree{ &quot;data&quot;: [ { &quot;id&quot;: 101, &quot;authName&quot;: &#39;商品管理&#39;, &quot;path&quot;: null, &quot;pid&quot;: 0, &quot;children&quot;: [ { &quot;id&quot;: 104, &quot;authName&quot;: &#39;商品列表&#39;, &quot;path&quot;: null, &quot;pid&quot;: 101, &quot;children&quot;: [ { &quot;id&quot;: 105, &quot;authName&quot;: &#39;添加商品&#39;, &quot;path&quot;: null, &quot;pid&quot;: &#39;104,101&#39; } ] } ] } ], &quot;meta&quot;: { &quot;msg&quot;: &#39;获取权限列表成功&#39;, &quot;status&quot;: 200 }}4.2. 左侧菜单权限 请求路径：menus 请求方法：get 响应数据{ &quot;data&quot;: { &quot;id&quot;: 101, &quot;authName&quot;: &quot;商品管理&quot;, &quot;path&quot;: null, &quot;children&quot;: [ { &quot;id&quot;: 104, &quot;authName&quot;: &quot;商品列表&quot;, &quot;path&quot;: null, &quot;children&quot;: [] } ] }, &quot;meta&quot;: { &quot;msg&quot;: &quot;获取菜单列表成功&quot;, &quot;status&quot;: 200 }}5. 角色管理5.1. 角色列表 请求路径：/roles 请求方法：get 响应数据说明 第一层为角色信息 第二层开始为权限说明，权限一共有 3 层权限 最后一层权限，不包含 children 属性 响应数据 { &quot;data&quot;: [ { &quot;id&quot;: 30, &quot;roleName&quot;: &quot;主管&quot;, &quot;roleDesc&quot;: &quot;技术负责人&quot;, &quot;children&quot;: [ { &quot;id&quot;: 101, &quot;authName&quot;: &quot;商品管理&quot;, &quot;path&quot;: null, &quot;children&quot;: [ { &quot;id&quot;: 104, &quot;authName&quot;: &quot;商品列表&quot;, &quot;path&quot;: null, &quot;children&quot;: [ { &quot;id&quot;: 105, &quot;authName&quot;: &quot;添加商品&quot;, &quot;path&quot;: null } ] } ] } ] } ], &quot;meta&quot;: { &quot;msg&quot;: &quot;获取成功&quot;, &quot;status&quot;: 200 }}5.2. 添加角色 请求路径：/roles 请求方法：post 请求参数 参数名 参数说明 备注 roleName 角色名称 不能为空 roleDesc 角色描述 可以为空 响应参数 参数名 参数说明 备注 roleId 角色 ID   roleName 角色名称   roleDesc 角色描述   响应数据{ &quot;data&quot;: { &quot;roleId&quot;: 40, &quot;roleName&quot;: &quot;admin2&quot;, &quot;roleDesc&quot;: &quot;admin2Desc&quot; }, &quot;meta&quot;: { &quot;msg&quot;: &quot;创建成功&quot;, &quot;status&quot;: 201 }}5.3. 根据 ID 查询角色 请求路径：/roles/:id 请求方法：get 请求参数 参数名 参数说明 备注 :id 角色 ID 不能为空携带在url中 响应参数 参数名 参数说明 备注 roleId 角色 ID   roleName 角色名称   roleDesc 角色描述   响应数据{ &quot;data&quot;: { &quot;roleId&quot;: 31, &quot;roleName&quot;: &quot;测试角色&quot;, &quot;roleDesc&quot;: &quot;测试负责人&quot; }, &quot;meta&quot;: { &quot;msg&quot;: &quot;获取成功&quot;, &quot;status&quot;: 200 }}5.4. 编辑提交角色 请求路径：/roles/:id 请求方法：put 请求参数 参数名 参数说明 备注 :id 角色 ID 不能为空携带在url中 roleName 角色名称 不能为空 roleDesc 角色描述 可以为空 响应数据{ &quot;data&quot;: { &quot;roleId&quot;: 31, &quot;roleName&quot;: &quot;测试角色&quot;, &quot;roleDesc&quot;: &quot;测试角色描述&quot; }, &quot;meta&quot;: { &quot;msg&quot;: &quot;获取成功&quot;, &quot;status&quot;: 200 }}5.5. 删除角色 请求路径：/roles/:id 请求方法：delete 请求参数 参数名 参数说明 备注 :id 角色 ID 不能为空携带在url中 响应数据{ &quot;data&quot;: null, &quot;meta&quot;: { &quot;msg&quot;: &quot;删除成功&quot;, &quot;status&quot;: 200 }}5.6. 角色授权 请求路径：/roles/:roleId/rights 请求方法：post 请求参数：通过 请求体 发送给后端 参数名 参数说明 备注 :roleId 角色 ID 不能为空携带在url中 rids 权限 ID 列表（字符串） 以 , 分割的权限 ID 列表（获取所有被选中、叶子节点的key和半选中节点的key, 包括 1，2，3级节点） 响应数据{ &quot;data&quot;: null, &quot;meta&quot;: { &quot;msg&quot;: &quot;更新成功&quot;, &quot;status&quot;: 200 }}5.7. 删除角色指定权限 请求路径：roles/:roleId/rights/:rightId 请求方法：delete 请求参数 参数名 参数说明 备注 :roleId 角色 ID 不能为空携带在url中 :rightId 权限 ID 不能为空携带在url中 响应数据说明 返回的data, 是当前角色下最新的权限数据 响应数据 { &quot;data&quot;: [ { &quot;id&quot;: 101, &quot;authName&quot;: &quot;商品管理&quot;, &quot;path&quot;: null, &quot;children&quot;: [ { &quot;id&quot;: 104, &quot;authName&quot;: &quot;商品列表&quot;, &quot;path&quot;: null, &quot;children&quot;: [ { &quot;id&quot;: 105, &quot;authName&quot;: &quot;添加商品&quot;, &quot;path&quot;: null }, { &quot;id&quot;: 116, &quot;authName&quot;: &quot;修改&quot;, &quot;path&quot;: null } ] } ] } ], &quot;meta&quot;: { &quot;msg&quot;: &quot;取消权限成功&quot;, &quot;status&quot;: 200 }}6. 商品分类管理6.1. 商品分类数据列表 请求路径：categories 请求方法：get 请求参数 参数名 参数说明 备注 type [1,2,3] 值：1，2，3 分别表示显示一层二层三层分类列表【可选参数】如果不传递，则默认获取所有级别的分类 pagenum 当前页码值 【可选参数】如果不传递，则默认获取所有分类 pagesize 每页显示多少条数据 【可选参数】如果不传递，则默认获取所有分类 响应参数 参数名 参数说明 备注 cat_id 分类 ID   cat_name 分类名称   cat_pid 分类父 ID   cat_level 分类当前层级   响应数据{ &quot;data&quot;: [ { &quot;cat_id&quot;: 1, &quot;cat_name&quot;: &quot;大家电&quot;, &quot;cat_pid&quot;: 0, &quot;cat_level&quot;: 0, &quot;cat_deleted&quot;: false, &quot;children&quot;: [ { &quot;cat_id&quot;: 3, &quot;cat_name&quot;: &quot;电视&quot;, &quot;cat_pid&quot;: 1, &quot;cat_level&quot;: 1, &quot;cat_deleted&quot;: false, &quot;children&quot;: [ { &quot;cat_id&quot;: 6, &quot;cat_name&quot;: &quot;曲面电视&quot;, &quot;cat_pid&quot;: 3, &quot;cat_level&quot;: 2, &quot;cat_deleted&quot;: false }, { &quot;cat_id&quot;: 7, &quot;cat_name&quot;: &quot;海信&quot;, &quot;cat_pid&quot;: 3, &quot;cat_level&quot;: 2, &quot;cat_deleted&quot;: false } ] } ] } ], &quot;meta&quot;: { &quot;msg&quot;: &quot;获取成功&quot;, &quot;status&quot;: 200 }}6.2. 添加分类 请求路径：/categories 请求方法：post 请求参数 参数名 参数说明 备注 cat_pid 分类父 ID 不能为空，如果要添加1级分类，则父分类Id应该设置为 0 cat_name 分类名称 不能为空 cat_level 分类层级 不能为空，0表示一级分类；1表示二级分类；2表示三级分类 响应数据{ &quot;data&quot;: { &quot;cat_id&quot;: 62, &quot;cat_name&quot;: &quot;相框&quot;, &quot;cat_pid&quot;: &quot;1&quot;, &quot;cat_level&quot;: &quot;1&quot; }, &quot;meta&quot;: { &quot;msg&quot;: &quot;创建成功&quot;, &quot;status&quot;: 201 }}6.3. 根据 id 查询分类 请求路径：categories/:id 请求方法：get 请求参数 参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 响应数据{ &quot;data&quot;: { &quot;cat_id&quot;: 3, &quot;cat_name&quot;: &quot;厨卫电器&quot;, &quot;cat_pid&quot;: 0, &quot;cat_level&quot;: 0 }, &quot;meta&quot;: { &quot;msg&quot;: &quot;获取成功&quot;, &quot;status&quot;: 200 }}6.4. 编辑提交分类 请求路径：categories/:id 请求方法：put 请求参数 参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 cat_name 分类名称 不能为空【此参数，放到请求体中】 响应数据{ &quot;data&quot;: { &quot;cat_id&quot;: 22, &quot;cat_name&quot;: &quot;自拍杆&quot;, &quot;cat_pid&quot;: 7, &quot;cat_level&quot;: 2 }, &quot;meta&quot;: { &quot;msg&quot;: &quot;更新成功&quot;, &quot;status&quot;: 200 }}6.5. 删除分类 请求路径：categories/:id 请求方法：delete 请求参数 参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 响应数据{ &quot;data&quot;: null, &quot;meta&quot;: { &quot;msg&quot;: &quot;删除成功&quot;, &quot;status&quot;: 200 }}7. 分类参数管理7.1. 参数列表 请求路径：/categories/:id/attributes 请求方法：get 请求参数 参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 sel [only,many] 不能为空,通过 only 或 many 来获取分类静态参数还是动态参数 响应参数 参数名 参数说明 备注 attr_id 分类参数 ID   attr_name 分类参数名称   cat_id 分类参数所属分类   attr_sel only:输入框(唯一) many:后台下拉列表/前台单选框   attr_write manual:手工录入 list:从列表选择   attr_vals 如果 attr_write:list,那么有值，该值以逗号分隔   响应数据{ &quot;data&quot;: [ { &quot;attr_id&quot;: 1, &quot;attr_name&quot;: &quot;cpu&quot;, &quot;cat_id&quot;: 22, &quot;attr_sel&quot;: &quot;only&quot;, &quot;attr_write&quot;: &quot;manual&quot;, &quot;attr_vals&quot;: &quot;ffff&quot; } ], &quot;meta&quot;: { &quot;msg&quot;: &quot;获取成功&quot;, &quot;status&quot;: 200 }}7.2. 添加动态参数或者静态属性 请求路径：/categories/:id/attributes 请求方法：post 请求参数 参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 attr_name 参数名称 不能为空 attr_sel [only,many] 不能为空 attr_vals 如果是 many 就需要填写值的选项，以逗号分隔 【可选参数】 响应数据{ &quot;data&quot;: { &quot;attr_id&quot;: 44, &quot;attr_name&quot;: &quot;测试参数&quot;, &quot;cat_id&quot;: &quot;1&quot;, &quot;attr_sel&quot;: &quot;many&quot;, &quot;attr_write&quot;: &quot;list&quot;, &quot;attr_vals&quot;: &quot;a,b,c&quot; }, &quot;meta&quot;: { &quot;msg&quot;: &quot;创建成功&quot;, &quot;status&quot;: 201 }}7.3. 删除参数 请求路径： categories/:id/attributes/:attrid 请求方法：delete 请求参数 参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 :attrid 参数 ID 不能为空携带在url中 响应数据{ &quot;data&quot;: null, &quot;meta&quot;: { &quot;msg&quot;: &quot;删除成功&quot;, &quot;status&quot;: 200 }}7.4. 根据 ID 查询参数 请求路径：categories/:id/attributes/:attrId 请求方法：get 请求参数 参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 :attrId 属性 ID 不能为空携带在url中 attr_sel [only,many] 不能为空 attr_vals 如果是 many 就需要填写值的选项，以逗号分隔   响应数据{ &quot;data&quot;: { &quot;attr_id&quot;: 1, &quot;attr_name&quot;: &quot;cpu&quot;, &quot;cat_id&quot;: 22, &quot;attr_sel&quot;: &quot;only&quot;, &quot;attr_write&quot;: &quot;manual&quot;, &quot;attr_vals&quot;: &quot;ffff&quot; }, &quot;meta&quot;: { &quot;msg&quot;: &quot;获取成功&quot;, &quot;status&quot;: 200 }}7.5. 编辑提交参数 请求路径：/categories/:id/attributes/:attrId 请求方法：put 请求参数 参数名 参数说明 备注 :id 分类 ID 不能为空携带在url中 :attrId 属性 ID 不能为空携带在url中 attr_name 新属性的名字 不能为空，携带在请求体中 attr_sel 属性的类型[many或only] 不能为空，携带在请求体中 attr_vals 参数的属性值 可选参数，携带在请求体中 响应数据{ &quot;data&quot;: { &quot;attr_id&quot;: 9, &quot;attr_name&quot;: &quot;测试更新&quot;, &quot;cat_id&quot;: &quot;43&quot;, &quot;attr_sel&quot;: &quot;only&quot;, &quot;attr_write&quot;: &quot;manual&quot;, &quot;attr_vals&quot;: &quot;abc&quot; }, &quot;meta&quot;: { &quot;msg&quot;: &quot;更新成功&quot;, &quot;status&quot;: 200 }}8. 商品管理8.1. 商品列表数据 请求路径：/goods 请求方法：get 请求参数 参数名 参数说明 备注 query 查询参数 可以为空 pagenum 当前页码 不能为空 pagesize 每页显示条数 不能为空 响应参数 参数名 参数说明 备注 total 总共商品条数   pagenum 当前商品页数   goods_id 商品 ID   goods_name 商品名称   goods_price 价格   goods_number 数量   goods_weight 重量 不能为空 goods_state 商品状态 商品状态 0: 未通过 1: 审核中 2: 已审核 add_time 添加时间   upd_time 更新时间   hot_mumber 热销品数量   is_promote 是否是热销品   响应数据{ &quot;data&quot;: { &quot;total&quot;: 50, &quot;pagenum&quot;: &quot;1&quot;, &quot;goods&quot;: [ { &quot;goods_id&quot;: 144, &quot;goods_name&quot;: &quot;asfdsd&quot;, &quot;goods_price&quot;: 1, &quot;goods_number&quot;: 1, &quot;goods_weight&quot;: 1, &quot;goods_state&quot;: null, &quot;add_time&quot;: 1512954923, &quot;upd_time&quot;: 1512954923, &quot;hot_mumber&quot;: 0, &quot;is_promote&quot;: false } ] }, &quot;meta&quot;: { &quot;msg&quot;: &quot;获取成功&quot;, &quot;status&quot;: 200 }}8.2. 添加商品 请求路径：goods 请求方法：post 请求参数 参数名 参数说明 备注 goods_name 商品名称 不能为空 goods_cat 以为’,’分割的分类列表 不能为空 goods_price 价格 不能为空 goods_number 数量 不能为空 goods_weight 重量 不能为空 goods_introduce 介绍 可以为空 pics 上传的图片临时路径（对象） 可以为空 attrs 商品的参数（数组），包含 动态参数 和 静态属性 可以为空 请求数据{ &quot;goods_name&quot;:&quot;test_goods_name2&quot;, &quot;goods_cat&quot;: &quot;1,2,3&quot;, &quot;goods_price&quot;:20, &quot;goods_number&quot;:30, &quot;goods_weight&quot;:40, &quot;goods_introduce&quot;:&quot;abc&quot;, &quot;pics&quot;:[ {&quot;pic&quot;:&quot;/tmp_uploads/30f08d52c551ecb447277eae232304b8&quot;} ], &quot;attrs&quot;:[ { &quot;attr_id&quot;:15, &quot;attr_value&quot;:&quot;ddd&quot; }, { &quot;attr_id&quot;:15, &quot;attr_value&quot;:&quot;eee&quot; } ]} 响应参数 参数名 参数说明 备注 total 总共商品条数   pagenum 当前商品页数   goods_id 商品 ID   goods_cat 以为’,’分割的分类列表   goods_name 商品名称   goods_price 价格   goods_number 数量   goods_weight 重量 不能为空 goods_state 商品状态 商品状态 0: 未通过 1: 审核中 2: 已审核 add_time 添加时间   upd_time 更新时间   hot_mumber 热销品数量   is_promote 是否是热销品   pics 上传的图片临时路径（对象） pics_id:图片 ID,goods_id:商品 ID,pics_big:大图,pics_mid:中图,pics_sma:小图 attrs 商品的参数（数组） goods_id:商品 ID,attr_value:当前商品的参数值,add_price:浮动价格,attr_vals:预定义的参数值,attr_sel:手动输入，还是单选, 响应数据{ &quot;data&quot;: { &quot;goods_id&quot;: 145, &quot;goods_name&quot;: &quot;test_goods_name2&quot;, &quot;goods_price&quot;: 20, &quot;cat_id&quot;: 1, &quot;goods_number&quot;: 30, &quot;goods_weight&quot;: 40, &quot;goods_introduce&quot;: &quot;abc&quot;, &quot;goods_big_logo&quot;: &quot;&quot;, &quot;goods_small_logo&quot;: &quot;&quot;, &quot;goods_state&quot;: 1, &quot;add_time&quot;: 1512962370, &quot;upd_time&quot;: 1512962370, &quot;hot_mumber&quot;: 0, &quot;is_promote&quot;: false, &quot;pics&quot;: [ { &quot;pics_id&quot;: 397, &quot;goods_id&quot;: 145, &quot;pics_big&quot;: &quot;uploads/goodspics/big_30f08d52c551ecb447277eae232304b8&quot;, &quot;pics_mid&quot;: &quot;uploads/goodspics/mid_30f08d52c551ecb447277eae232304b8&quot;, &quot;pics_sma&quot;: &quot;uploads/goodspics/sma_30f08d52c551ecb447277eae232304b8&quot; } ], &quot;attrs&quot;: [ { &quot;goods_id&quot;: 145, &quot;attr_id&quot;: 15, &quot;attr_value&quot;: &quot;ddd&quot;, &quot;add_price&quot;: null, &quot;attr_name&quot;: &quot;fffffff&quot;, &quot;attr_sel&quot;: &quot;many&quot;, &quot;attr_write&quot;: &quot;list&quot;, &quot;attr_vals&quot;: &quot;&quot; }, { &quot;goods_id&quot;: 145, &quot;attr_id&quot;: 15, &quot;attr_value&quot;: &quot;eee&quot;, &quot;add_price&quot;: null, &quot;attr_name&quot;: &quot;fffffff&quot;, &quot;attr_sel&quot;: &quot;many&quot;, &quot;attr_write&quot;: &quot;list&quot;, &quot;attr_vals&quot;: &quot;&quot; } ] }, &quot;meta&quot;: { &quot;msg&quot;: &quot;创建商品成功&quot;, &quot;status&quot;: 201 }}8.3. 根据 ID 查询商品 请求路径：/goods/:id 请求方法：get 请求参数 参数名 参数说明 备注 id 商品 ID 不能为空携带在url中 响应参数 参数名 参数说明 备注 total 总共商品条数   pagenum 当前商品页数   goods_id 商品 ID   goods_name 商品名称   goods_price 价格   goods_number 数量   goods_weight 重量 不能为空 goods_state 商品状态 商品状态 0: 未通过 1: 审核中 2: 已审核 add_time 添加时间   upd_time 更新时间   hot_mumber 热销品数量   is_promote 是否是热销品   pics 上传的图片临时路径（对象） pics_id:图片 ID,goods_id:商品 ID,pics_big:大图,pics_mid:中图,pics_sma:小图 attrs 商品的参数（数组） goods_id:商品 ID,attr_value:当前商品的参数值,add_price:浮动价格,attr_vals:预定义的参数值,attr_sel:手动输入，还是单选, 响应数据{ &quot;data&quot;: { &quot;goods_id&quot;: 145, &quot;goods_name&quot;: &quot;test_goods_name2&quot;, &quot;goods_price&quot;: 20, &quot;goods_number&quot;: 30, &quot;goods_weight&quot;: 40, &quot;goods_introduce&quot;: &quot;abc&quot;, &quot;goods_big_logo&quot;: &quot;&quot;, &quot;goods_small_logo&quot;: &quot;&quot;, &quot;goods_state&quot;: 1, &quot;add_time&quot;: 1512962370, &quot;upd_time&quot;: 1512962370, &quot;hot_mumber&quot;: 0, &quot;is_promote&quot;: false, &quot;pics&quot;: [ { &quot;pics_id&quot;: 397, &quot;goods_id&quot;: 145, &quot;pics_big&quot;: &quot;uploads/goodspics/big_30f08d52c551ecb447277eae232304b8&quot;, &quot;pics_mid&quot;: &quot;uploads/goodspics/mid_30f08d52c551ecb447277eae232304b8&quot;, &quot;pics_sma&quot;: &quot;uploads/goodspics/sma_30f08d52c551ecb447277eae232304b8&quot; } ], &quot;attrs&quot;: [ { &quot;goods_id&quot;: 145, &quot;attr_id&quot;: 15, &quot;attr_value&quot;: &quot;ddd&quot;, &quot;add_price&quot;: null, &quot;attr_name&quot;: &quot;fffffff&quot;, &quot;attr_sel&quot;: &quot;many&quot;, &quot;attr_write&quot;: &quot;list&quot;, &quot;attr_vals&quot;: &quot;&quot; }, { &quot;goods_id&quot;: 145, &quot;attr_id&quot;: 15, &quot;attr_value&quot;: &quot;eee&quot;, &quot;add_price&quot;: null, &quot;attr_name&quot;: &quot;fffffff&quot;, &quot;attr_sel&quot;: &quot;many&quot;, &quot;attr_write&quot;: &quot;list&quot;, &quot;attr_vals&quot;: &quot;&quot; } ] }, &quot;meta&quot;: { &quot;msg&quot;: &quot;创建商品成功&quot;, &quot;status&quot;: 201 }}8.4. 编辑提交商品 请求路径：/goods/:id 请求方法：put 请求参数 参数名 参数说明 备注 id 商品 ID 不能为空携带在url中 goods_name 商品名称 不能为空 goods_price 价格 不能为空 goods_number 数量 不能为空 goods_weight 重量 不能为空 goods_introduce 介绍 可以为空 pics 上传的图片临时路径（对象） 可以为空 attrs 商品的参数（数组） 可以为空 请求数据{ &quot;goods_name&quot;:&quot;test_goods_name2&quot;, &quot;goods_price&quot;:20, &quot;goods_number&quot;:30, &quot;goods_weight&quot;:40, &quot;goods_introduce&quot;:&quot;abc&quot;, &quot;pics&quot;:[ {&quot;pic&quot;:&quot;/tmp_uploads/30f08d52c551ecb447277eae232304b8&quot;} ], &quot;attrs&quot;:[ { &quot;attr_id&quot;:15, &quot;attr_value&quot;:&quot;ddd&quot; }, { &quot;attr_id&quot;:15, &quot;attr_value&quot;:&quot;eee&quot; } ]} 响应参数 参数名 参数说明 备注 total 总共商品条数   pagenum 当前商品页数   goods_id 商品 ID   goods_name 商品名称   goods_price 价格   goods_number 数量   goods_weight 重量 不能为空 goods_state 商品状态 商品状态 0: 未通过 1: 审核中 2: 已审核 add_time 添加时间   upd_time 更新时间   hot_mumber 热销品数量   is_promote 是否是热销品   pics 上传的图片临时路径（对象） pics_id:图片 ID,goods_id:商品 ID,pics_big:大图,pics_mid:中图,pics_sma:小图 attrs 商品的参数（数组） goods_id:商品 ID,attr_value:当前商品的参数值,add_price:浮动价格,attr_vals:预定义的参数值,attr_sel:手动输入，还是单选, 响应数据{ &quot;data&quot;: { &quot;goods_id&quot;: 145, &quot;goods_name&quot;: &quot;test_goods_name2&quot;, &quot;goods_price&quot;: 20, &quot;goods_number&quot;: 30, &quot;goods_weight&quot;: 40, &quot;goods_introduce&quot;: &quot;abc&quot;, &quot;goods_big_logo&quot;: &quot;&quot;, &quot;goods_small_logo&quot;: &quot;&quot;, &quot;goods_state&quot;: 1, &quot;add_time&quot;: 1512962370, &quot;upd_time&quot;: 1512962370, &quot;hot_mumber&quot;: 0, &quot;is_promote&quot;: false, &quot;pics&quot;: [ { &quot;pics_id&quot;: 397, &quot;goods_id&quot;: 145, &quot;pics_big&quot;: &quot;uploads/goodspics/big_30f08d52c551ecb447277eae232304b8&quot;, &quot;pics_mid&quot;: &quot;uploads/goodspics/mid_30f08d52c551ecb447277eae232304b8&quot;, &quot;pics_sma&quot;: &quot;uploads/goodspics/sma_30f08d52c551ecb447277eae232304b8&quot; } ], &quot;attrs&quot;: [ { &quot;goods_id&quot;: 145, &quot;attr_id&quot;: 15, &quot;attr_value&quot;: &quot;ddd&quot;, &quot;add_price&quot;: null, &quot;attr_name&quot;: &quot;fffffff&quot;, &quot;attr_sel&quot;: &quot;many&quot;, &quot;attr_write&quot;: &quot;list&quot;, &quot;attr_vals&quot;: &quot;&quot; }, { &quot;goods_id&quot;: 145, &quot;attr_id&quot;: 15, &quot;attr_value&quot;: &quot;eee&quot;, &quot;add_price&quot;: null, &quot;attr_name&quot;: &quot;fffffff&quot;, &quot;attr_sel&quot;: &quot;many&quot;, &quot;attr_write&quot;: &quot;list&quot;, &quot;attr_vals&quot;: &quot;&quot; } ] }, &quot;meta&quot;: { &quot;msg&quot;: &quot;创建商品成功&quot;, &quot;status&quot;: 201 }}8.5. 删除商品 请求路径：goods/:id 请求方法：delete 请求参数 参数名 参数说明 备注 id 商品 ID 不能为空携带在url中 响应数据{ &quot;data&quot;: null, &quot;meta&quot;: { &quot;msg&quot;: &quot;删除成功&quot;, &quot;status&quot;: 200 }}9. 订单管理9.1. 订单数据列表 请求路径：/orders 请求方法：get 请求参数 参数名 参数说明 备注 query 查询参数 可以为空 pagenum 当前页码 不能为空 pagesize 每页显示条数 不能为空 user_id 用户 ID 可以为空 pay_status 支付状态 可以为空 is_send 是否发货 可以为空 order_fapiao_title [‘个人’,’公司’] 可以为空 order_fapiao_company 公司名称 可以为空 order_fapiao_content 发票内容 可以为空 consignee_addr 发货地址 可以为空 响应数据{ &quot;data&quot;: { &quot;total&quot;: 1, &quot;pagenum&quot;: &quot;1&quot;, &quot;goods&quot;: [ { &quot;order_id&quot;: 47, &quot;user_id&quot;: 133, &quot;order_number&quot;: &quot;itcast-59e7502d7993d&quot;, &quot;order_price&quot;: 322, &quot;order_pay&quot;: &quot;1&quot;, &quot;is_send&quot;: &quot;是&quot;, &quot;trade_no&quot;: &quot;&quot;, &quot;order_fapiao_title&quot;: &quot;个人&quot;, &quot;order_fapiao_company&quot;: &quot;&quot;, &quot;order_fapiao_content&quot;: &quot;办公用品&quot;, &quot;consignee_addr&quot;: &quot;a:7:{s:6:\\&quot;cgn_id\\&quot;;i:1;s:7:\\&quot;user_id\\&quot;;i:133;s:8:\\&quot;cgn_name\\&quot;;s:9:\\&quot;王二柱\\&quot;;s:11:\\&quot;cgn_address\\&quot;;s:51:\\&quot;北京市海淀区苏州街长远天地大厦305室\\&quot;;s:7:\\&quot;cgn_tel\\&quot;;s:11:\\&quot;13566771298\\&quot;;s:8:\\&quot;cgn_code\\&quot;;s:6:\\&quot;306810\\&quot;;s:11:\\&quot;delete_time\\&quot;;N;}&quot;, &quot;pay_status&quot;: &quot;1&quot;, &quot;create_time&quot;: 1508331565, &quot;update_time&quot;: 1508331565 } ] }, &quot;meta&quot;: { &quot;msg&quot;: &quot;获取成功&quot;, &quot;status&quot;: 200 }}9.2. 修改订单状态 请求路径：/orders/:id 请求方法：put 请求参数 参数名 参数说明 备注 id 订单 ID 不能为空携带在url中 is_send 订单是否发货 1:已经发货，0:未发货 order_pay 订单支付 支付方式 0 未支付 1 支付宝 2 微信 3 银行卡 order_price 订单价格   order_number 订单数量   pay_status 支付状态 订单状态： 0 未付款、1 已付款 请求数据说明 所有请求数据都是增量更新，如果参数不填写，就不会更新该字段 响应数据{ &quot;data&quot;: { &quot;order_id&quot;: 67, &quot;user_id&quot;: 1, &quot;order_number&quot;: &quot;itcast-g7kmck71vjaujfgoi&quot;, &quot;order_price&quot;: 20, &quot;order_pay&quot;: &quot;0&quot;, &quot;is_send&quot;: &quot;否&quot;, &quot;trade_no&quot;: &quot;&quot;, &quot;order_fapiao_title&quot;: &quot;个人&quot;, &quot;order_fapiao_company&quot;: &quot;&quot;, &quot;order_fapiao_content&quot;: &quot;&quot;, &quot;consignee_addr&quot;: &quot;&quot;, &quot;pay_status&quot;: &quot;0&quot;, &quot;create_time&quot;: 1512533560, &quot;update_time&quot;: 1512533560, &quot;goods&quot;: [ { &quot;id&quot;: 82, &quot;order_id&quot;: 67, &quot;goods_id&quot;: 96, &quot;goods_price&quot;: 333, &quot;goods_number&quot;: 2, &quot;goods_total_price&quot;: 999 }, { &quot;id&quot;: 83, &quot;order_id&quot;: 67, &quot;goods_id&quot;: 95, &quot;goods_price&quot;: 666, &quot;goods_number&quot;: 5, &quot;goods_total_price&quot;: 999 } ] }, &quot;meta&quot;: { &quot;msg&quot;: &quot;获取成功&quot;, &quot;status&quot;: 200 }}9.3. 查看订单详情 请求路径：orders/:id 请求方法：get 请求参数 参数名 参数说明 备注 id 订单 ID 不能为空携带在url中 响应数据{ &quot;data&quot;: { &quot;order_id&quot;: 67, &quot;user_id&quot;: 1, &quot;order_number&quot;: &quot;itcast-g7kmck71vjaujfgoi&quot;, &quot;order_price&quot;: 20, &quot;order_pay&quot;: &quot;0&quot;, &quot;is_send&quot;: &quot;否&quot;, &quot;trade_no&quot;: &quot;&quot;, &quot;order_fapiao_title&quot;: &quot;个人&quot;, &quot;order_fapiao_company&quot;: &quot;&quot;, &quot;order_fapiao_content&quot;: &quot;&quot;, &quot;consignee_addr&quot;: &quot;&quot;, &quot;pay_status&quot;: &quot;0&quot;, &quot;create_time&quot;: 1512533560, &quot;update_time&quot;: 1512533560, &quot;goods&quot;: [ { &quot;id&quot;: 82, &quot;order_id&quot;: 67, &quot;goods_id&quot;: 96, &quot;goods_price&quot;: 333, &quot;goods_number&quot;: 2, &quot;goods_total_price&quot;: 999 }, { &quot;id&quot;: 83, &quot;order_id&quot;: 67, &quot;goods_id&quot;: 95, &quot;goods_price&quot;: 666, &quot;goods_number&quot;: 5, &quot;goods_total_price&quot;: 999 } ] }, &quot;meta&quot;: { &quot;msg&quot;: &quot;获取成功&quot;, &quot;status&quot;: 200 }}9.4. 修改地址 省市区/县联动效果 - 结合ElementUI的 el-cascader 组件9.5. 查看物流信息 请求路径：/kuaidi/:id 请求方法：get 供测试的物流单号：1106975712662 响应数据： { &quot;data&quot;: [ { &quot;time&quot;: &quot;2018-05-10 09:39:00&quot;, &quot;ftime&quot;: &quot;2018-05-10 09:39:00&quot;, &quot;context&quot;: &quot;已签收,感谢使用顺丰,期待再次为您服务&quot;, &quot;location&quot;: &quot;&quot; }, { &quot;time&quot;: &quot;2018-05-10 08:23:00&quot;, &quot;ftime&quot;: &quot;2018-05-10 08:23:00&quot;, &quot;context&quot;: &quot;[北京市]北京海淀育新小区营业点派件员 顺丰速运 95338正在为您派件&quot;, &quot;location&quot;: &quot;&quot; }, { &quot;time&quot;: &quot;2018-05-10 07:32:00&quot;, &quot;ftime&quot;: &quot;2018-05-10 07:32:00&quot;, &quot;context&quot;: &quot;快件到达 [北京海淀育新小区营业点]&quot;, &quot;location&quot;: &quot;&quot; }, { &quot;time&quot;: &quot;2018-05-10 02:03:00&quot;, &quot;ftime&quot;: &quot;2018-05-10 02:03:00&quot;, &quot;context&quot;: &quot;快件在[北京顺义集散中心]已装车,准备发往 [北京海淀育新小区营业点]&quot;, &quot;location&quot;: &quot;&quot; }, { &quot;time&quot;: &quot;2018-05-09 23:05:00&quot;, &quot;ftime&quot;: &quot;2018-05-09 23:05:00&quot;, &quot;context&quot;: &quot;快件到达 [北京顺义集散中心]&quot;, &quot;location&quot;: &quot;&quot; }, { &quot;time&quot;: &quot;2018-05-09 21:21:00&quot;, &quot;ftime&quot;: &quot;2018-05-09 21:21:00&quot;, &quot;context&quot;: &quot;快件在[北京宝胜营业点]已装车,准备发往 [北京顺义集散中心]&quot;, &quot;location&quot;: &quot;&quot; }, { &quot;time&quot;: &quot;2018-05-09 13:07:00&quot;, &quot;ftime&quot;: &quot;2018-05-09 13:07:00&quot;, &quot;context&quot;: &quot;顺丰速运 已收取快件&quot;, &quot;location&quot;: &quot;&quot; }, { &quot;time&quot;: &quot;2018-05-09 12:25:03&quot;, &quot;ftime&quot;: &quot;2018-05-09 12:25:03&quot;, &quot;context&quot;: &quot;卖家发货&quot;, &quot;location&quot;: &quot;&quot; }, { &quot;time&quot;: &quot;2018-05-09 12:22:24&quot;, &quot;ftime&quot;: &quot;2018-05-09 12:22:24&quot;, &quot;context&quot;: &quot;您的订单将由HLA（北京海淀区清河中街店）门店安排发货。&quot;, &quot;location&quot;: &quot;&quot; }, { &quot;time&quot;: &quot;2018-05-08 21:36:04&quot;, &quot;ftime&quot;: &quot;2018-05-08 21:36:04&quot;, &quot;context&quot;: &quot;商品已经下单&quot;, &quot;location&quot;: &quot;&quot; } ], &quot;meta&quot;: { &quot;status&quot;: 200, &quot;message&quot;: &quot;获取物流信息成功！&quot; }} 10. 数据统计10.1. 基于时间统计的折线图 请求路径：/reports/type/1 请求方法：get 响应数据 需要合并的选项(echarts) options: { title: { text: &#39;用户来源&#39; }, tooltip: { trigger: &#39;axis&#39;, axisPointer: { type: &#39;cross&#39;, label: { backgroundColor: &#39;#E9EEF3&#39; } } }, grid: { left: &#39;3%&#39;, right: &#39;4%&#39;, bottom: &#39;3%&#39;, containLabel: true }, xAxis: [ { boundaryGap: false } ], yAxis: [ { type: &#39;value&#39; } ]}" }, { "title": "前端 Vue路由与vuex", "url": "/posts/%E5%89%8D%E7%AB%AF-Vue%E8%B7%AF%E7%94%B1%E4%B8%8EVuex/", "categories": "前端", "tags": "前端Vue", "date": "2021-05-21 00:00:00 +0800", "snippet": "1.Vuex1.概念​ 专门在Vue中实现集中式状态（数据）管理的一个Vue插件，对Vue应用中多个组件的共享状态进行集中式的管理（读写），也是组件间通信的方式，且适用于任意组件间通信。 所有组件的数据进行统一管理（存储和变更），每个组件内部就不再需要维护这些数据了 数据变更时，统一修改Store中数据即可，组件中用到这个数据的组件会自动更新（数据是响应式的）2.Vuex应用场景​ 如果需要构建一个中大型单页应用，Vuex 将会成为自然而然的选择，Vuex能够保持多个组件间的数据一致。对于中大型应用，就需要摒弃小应用中的props方法和全局事件总线 多个组件依赖于同一状态 来自不同组件的行为需要变更同一状态3.安装npm install vuex --save# 上面不行就用下面的npm i vuex --legacy-peer-deps# 在安装的时候，要注意vue的版本，目前直接使用上述的安装流程，只能适用于vue3.0 + # 使用vue2的朋友，需要安装vuex3.xnpm i vuex@3.6.2 需要在根目录下面创建文件夹store,并在store文件夹下创建index.jsroot-| | --- node_modulesnode | --- public | --- src | | --- main.js | --- git | --- .gitignoregit | --- babel.config.js | --- package.json | --- package.lock.json | --- README.md | --- store | ---index.jsstore/index.js//该文件用于创建Vuex中最为核心的store// 引入Vueimport Vue from &#39;vue&#39;// 引入Vueximport Vuex from &#39;vuex&#39;Vue.use(Vuex)// 准备actions - 用于相应组件中的动作，用来写动作const actions ={}// 准备mutations - 用于操作数据（state），用来写操作函数const mutations ={}// 准备state -- 用于定义和存储数据const state={}// 创建并暴露store，这个store相当于数据存储的库const store = new Vuex.Store({ actions, mutations, state,})export default storemain.js...import store from &#39;./store/index.js&#39;new Vue({ el:&quot;#app&quot;, render:h=&amp;gt;h(App), store, beforeCreate(){ Vue.prototype.$bus =this }})4.基本使用 模块 说明 state 定义应用状态的数据结构，可以在这里设置默认的初始状态 getters 允许组件从 store 中获取数据 mutations 用来更改state的唯一标准方式，且必须是同步函数 actions 组件通过调用actions来提交mutation，不是直接变更状态，可以包含任意异步操作 modules 每个module都有自己的state，getters，mutations，actions ​ 对变量的增删改查4.1 state第一种访问方式：通过 this引入​ 假设我们有一个全局状态 count 的值为 5。那么，我们就可以将其定义为 state 对象中的 key 和 value，作为全局状态供我们使用。如下：//创建一个 storeconst store = new Vuex.Store({ //state存储应用层的状态 state:{ count:5 //总数：5 }});// 把state中数据，定义在组件内的计算属性中computed: { // 1. 最完整的写法 // count: function () { // return this.$store.state.count // }, // 2. 缩写 count () { return this.$store.state.count }}// 不能使用箭头函数 this指向的不是vue实例，实际上用的是父级函数中的this state中的数据是自定义的，但是state属性名是固定的 获取数据可以通过 $store.state 可以使用计算属性优化模板中获取数据的方式 计算属性不可以使用箭头函数（箭头函数本身是没有this的，实际上用的是父级函数中的this）第二种访问方式：mapState// 1. 从vuex中按需导入mapState函数import { mapState } from &#39;vuex&#39; // 2.通过导入的mapState函数，将当前组件需要的全局数据，映射为当前组件的computed计算属性computed:{ ...mapState([&#39;count&#39;])}// 这时候，count作为组件的一个计算属性，直接使用就ok了4.2 Getters​ 可以认为，getters 是store的计算属性，类似于computed，对state里的数据进行一些过滤，改造等等​ 假设我们要在state.count的基础上派生出一个新的状态newCount出来，就适合使用我们的 getters，getters 接受 state 作为其第一个参数。const store = new Vuex.Store({ //state存储应用层的状态 state:{ count:5 //总数：5 }, getters:{ newCount:state =&amp;gt; state.count * 3; showNum(state){ return &quot;当前最新的数量是&quot;+ state.count} } })在组件中获取 `` 方式：export default { computed: { newCount(){ return this.$store.getters.newCount; } }}; 第二种方式，通过mapGetters，引入getters中的变量，作为计算属性，直接使用即可&amp;lt;template&amp;gt; &amp;lt;div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt; import { mapGetters } from &#39;vuex&#39; export default{ name：&quot;xxx&quot;, computed: { ...mapGetters([&#39;showNum&#39;]) } }&amp;lt;/script&amp;gt;4.3 Mutations​ Vuex 给我们提供修改仓库 store中的状态的唯一办法就是通过提交mutation ，且必须是同步函数​ 只有mutaitons才有修改state中数据的权利我们在 mutations中定义了一个叫increment的函数，函数体就是我们要进行更改的地方，Mutations 中的increment函数会接受 state作为第一个参数，第二个是自定义传参const store = new Vuex.Store({ //state存储应用层的状态 state:{ count:5 //总数：5 }, // mutations是修改state中数据的唯一途径 mutations:{ increment(state，value){ state.count += value; } }});我们在提交commit时候，第一个参数&quot;increment&quot;，就是对应在 mutations中的increment方法，第二个参数是自定义值。例如：methods: { getVal() { let value = 10; //通过commit调用一个名为increment的mutation this.$store.commit(&quot;increment&quot;, value); }}除了通过commit调用，vuex提供了mapmutations供组件方便调用store中的mutationimport { mapMutations } from &#39;vuex&#39;methods: { ...mapMutations([&#39;increment&#39;]) getVal() { let value = 10; //通过commit调用一个名为increment的mutation this.increment(value); }}4.4 Action 用于提交 mutation，而不是直接变更状态，可以包含任意异步操作 只有通过 action =&amp;gt; mutations =&amp;gt; states ，这个流程进行操作，具体步骤如下：export default new Vuex.Store({ //1.存放数据 state: { obj: {}, }, //4. 通过commit mutations中的方法来处理 mutations: { getParam(state, Object) { //5.修改state中的数据 state.obj = Object } }, //2.接受dispatch传递过来的方法和参数 actions: { getParamAsync(store, Object) { // 处理异步操作 setTimeout(() =&amp;gt; { // 3.通过commit提交一个名为getParam的mutation // action 函数接收一个 store 的实例对象，因此可以调用 store.commit 提交一个 mutation store.commit(&quot;getParam&quot;, Object); }, 1000) } }})然后我们就在组件里这么调用就可以了。注意：只能通过dispatch方法触发actionmethods: { getVal() { let name= &quot;xia&quot;; let age= &quot;26&quot;; let sex= &quot;man&quot;; // 1.通过dispatch将方法getParamSync和多个参数{name,age,sex}传递给actions this.$store.dispatch(&quot;getParamSync&quot;,{name,age,sex}) }}第二种引入方式mapAction1. 从vuex中按需导入 mapActions函数import { mapAcitons } from &#39;vuex&#39;2. 通过指定的actions函数，映射为当前组件的methods函数methods:{ ...mapAcitons([&#39;getParamSync&#39;]), // 可以定义函数调用，也可以直接调用getParamSync // mapAcitons相当于将acitons中的函数直接映射到本组件中，属于本组件的方法，所以可以直接用 getVal() { this.getParamSync({name,age,sex}) }}4.5 Modules​ 随着项目的复杂度增大，为了方便管理 Vuex，一般会将其按功能分割成不同的模块(Module)，方便日后管理。每个模块拥有自己的 state、mutation、action、getter 甚至是嵌套子模块import Vue from &quot;vue&quot;import Vuex from &quot;vuex&quot;import state from &quot;./state&quot;import mutations from &quot;./mutations&quot;import actions from &quot;./actions&quot;import * as getters from &quot;./getters&quot;import moduleA from &quot;./module/moduleA&quot; // 模块Aimport moduleB from &quot;./module/moduleB&quot; // 模块BVue.use(Vuex)export default new Vuex.Store({ actions, getters, state, mutations, modules: { moduleA, moduleB }})moduleA.js / moduleB.js 文件// 每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块export default { state: { text: &quot;moduleA&quot; }, getters: {}, mutations: {}, actions: {}}然后我们就在组件里这么调用就可以了&amp;lt;template&amp;gt;&amp;lt;div class=&quot;demo&quot;&amp;gt; &amp;lt;h1&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;h1&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt; computed: { getText1(){ return this.$store.state.moduleA.text; }, //或 ...mapState({ getText2: state =&amp;gt; state.moduleB.text; }) }&amp;lt;/script&amp;gt;由此可知，模块内部的 state 是局部的，只属于模块本身所有，所以外部必须通过对应的模块名进行访问。2.Router1.概念​ Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。​ 路由实际上就是可以理解为指向，就是我在页面上点击一个按钮需要跳转到对应的页面，这就是路由跳转；首先我们来学习三个单词（route，routes，router）： route：首先它是个单数，译为路由，即我们可以理解为单个路由或者某一个路由； routes：它是个复数，表示多个的集合才能为复数；即我们可以理解为多个路由的集合，JS中表示多种不同状态的集合的形式只有数组和对象两种，事实上官方定义routes是一个数组；所以我们记住了，routes表示多个数组的集合； router：译为路由器，上面都是路由，这个是路由器，我们可以理解为一个容器包含上述两个或者说它是一个管理者，负责管理上述两个；举个常见的场景的例子：当用户在页面上点击按钮的时候，这个时候router就会去routes中去查找route，就是说路由器会去路由集合中找对应的路由；2.应用场景​ 后端路由每次仿问一个页面都要向浏览器发送请求，然后服务端再响应解析，在这个过程中肯定会存在延迟，但是前端路由中仿问一个新的界面的时候只是浏览器的路径改变了，没有和服务端交互「所以不存在延迟」，这个对用户体验来说是大大的提高。​ vue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。​ vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。传统的页面应用，是用一些超链接来实现页面切换和跳转的。​ 在vue-router单页面应用中，则是路径之间的切换，也就是组件的切换。3.安装npm i vue-router@3注意：目前vue2.x只能使用vue-router 3；而vue 3x版本使用vue-router 4。4.案例使用root-| | --- node_modulesnode | --- public | --- src | --- App.vue | --- assets | --- main.js | --- router.js | --- components | --- Home.vue | --- About.vue | --- git | --- .gitignoregit | --- babel.config.js | --- package.json | --- package.lock.json | --- README.md | --- vue.config.jsApp.vue&amp;lt;template&amp;gt; &amp;lt;div id=&quot;app&quot;&amp;gt; &amp;lt;div id=&quot;&quot; class=&quot;col-6 mx-auto my-5&quot;&amp;gt; Vue-route demo &amp;lt;div id=&quot;&quot; class=&quot;col-3 mt-3&quot;&amp;gt; &amp;lt;div id=&quot;&quot; class=&quot;btn btn-warning&quot;&amp;gt; &amp;lt;router-link active-class=&#39;active&#39; to=&#39;/home&#39;&amp;gt;home&amp;lt;/router-link&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div id=&quot;&quot; class=&quot;btn btn-info&quot;&amp;gt; &amp;lt;router-link active-class=&#39;active&#39; to=&#39;/about&#39;&amp;gt;About&amp;lt;/router-link&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;col-12 border mt-1&quot;&amp;gt; &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt; import Home from &#39;./components/Home.vue&#39; import About from &#39;./components/About.vue&#39; export default { name: &#39;App&#39;, components: { Home, About } }&amp;lt;/script&amp;gt;main.jsimport Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;import BootstrapVue from &quot;bootstrap-vue&quot;import VueRouter from &#39;vue-router&#39;import router from &#39;./router.js&#39;Vue.config.productionTip = falseVue.use(BootstrapVue)Vue.use(VueRouter)import &quot;bootstrap/dist/css/bootstrap.css&quot;new Vue({ render: h =&amp;gt; h(App), router,}).$mount(&#39;#app&#39;)router.jsimport VueRouter from &#39;vue-router&#39;import About from &#39;./components/About&#39;import Home from &#39;./components/Home&#39;// 创建router实例对象，去管理一组一组的路由规则const router = new VueRouter({ routes:[ { path:&#39;/about&#39;, component:About }, { path:&#39;/home&#39;, component:Home } ]})// 暴露routerexport default routersrc/components/home.vue&amp;lt;template&amp;gt;&amp;lt;div id=&quot;&quot;&amp;gt; &amp;lt;h1&amp;gt;这是Home页面&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt; export default { name:&quot;Home&quot; }&amp;lt;/script&amp;gt;&amp;lt;style&amp;gt;&amp;lt;/style&amp;gt;src/components/about.vue&amp;lt;template&amp;gt;&amp;lt;div id=&quot;&quot;&amp;gt; &amp;lt;h1&amp;gt;这是about页面&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt; export default { name:&quot;About&quot; }&amp;lt;/script&amp;gt;&amp;lt;style&amp;gt;&amp;lt;/style&amp;gt;注意点： 实现切换（active-class 可配置高亮样式，由bootstrap实现） &amp;lt;router-link active-class=&#39;active&#39; to=&#39;/about&#39;&amp;gt;About&amp;lt;/router-link&amp;gt; 指示展示位置 &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt; Tips 1. 路由组件通常存放在`pages`文件夹中，一般组件通常存放在`components`文件夹。2. 通过路由切换，&#39;隐藏&#39;了的路由组件，默认是被销毁掉的（相当于v-if），需要的时候再去挂载。 （后面会讲keep-alive，实现v-show的功能，见第12节缓存路由组件）3. 每个组件都有自己`$route`属性，里面存放着自己的路由信息。4. 整个应用只有一个`router`，可以通过组件的`$router`属性获取到。 5.多级路由​ 1.配置路由规则（children属性）router.jsimport VueRouter from &#39;vue-router&#39;import About from &#39;./components/About&#39;import Home from &#39;./components/Home&#39;routes:[ { path:&#39;/about&#39;, component:About }, { path:&#39;/home&#39;, component:Home, children:[ { path:&#39;news&#39;, //此处一定不要写 /news component:News }, { path:&#39;message&#39;, //此处一定不要写 /message component:Message }, ] }]// 暴露routerexport default router 实现切换&amp;lt;router-link to=&quot;/home/news&quot;&amp;gt;News&amp;lt;/router-link&amp;gt;&amp;lt;router-link to=&quot;/home/message&quot;&amp;gt;Message&amp;lt;/router-link&amp;gt;&amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;6.路由传参​ 在vue中，实现多级路由后，需要传递参数，就需要用到vue路由的多级传参操作router.jsimport VueRouter from &#39;vue-router&#39;import About from &#39;./components/About&#39;import Home from &#39;./components/Home&#39;import Detail from &#39;./components/Home&#39;const router = new VueRouter({ routes:[ { path:&#39;/about&#39;, component:About }, { path:&#39;/home&#39;, component:Home, children:[ { path:&#39;news&#39;, //此处一定不要写 /news component:News }, { path:&#39;message&#39;, //此处一定不要写 /message component:Message, children:[ path:&#39;Detail&#39;, component:Detail // 配置Detail组件 ] }, ] } ]})// 暴露routerexport default routerMessage.vue&amp;lt;template&amp;gt;&amp;lt;div&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li v-for =&quot;m in messageList&quot; :key=&#39;m.id&#39;&amp;gt; &amp;lt;router-link :to=&quot;{ path:&#39;/home/message/detail&#39;, query:{ id:m.id, title:m.title } }&quot;&amp;gt; &amp;lt;/router-link&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt; export default{ name:&#39;Message&#39;, data(){ return{ messageList:[ { id:&#39;001&#39;,title:&#39;消息001&#39; }, { id:&#39;002&#39;,title:&#39;消息002&#39; }, { id:&#39;003&#39;,title:&#39;消息003&#39; } ] } } }&amp;lt;/script&amp;gt;Detail.vue&amp;lt;template&amp;gt;&amp;lt;ul&amp;gt; &amp;lt;li&amp;gt; 消息编号： &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 消息标题： &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt; export default{ name:&#39;Detail&#39;, }&amp;lt;/script&amp;gt; 传递参数的方式&amp;lt;router-link :to=&quot;{ path:&#39;/home/message/detail&#39;, query:{ id:m.id, title:m.title } }&quot;&amp;gt;&amp;lt;/router-link&amp;gt; 接收参数的方式&amp;lt;ul&amp;gt; &amp;lt;li&amp;gt; 消息编号： &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 消息标题： &amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;7.命名路由 作用 对于超级长的路由命名，采用命名路由，可以简化路由的的跳转。 使用 router.jsimport VueRouter from &#39;vue-router&#39;import About from &#39;./components/About&#39;import Home from &#39;./components/Home&#39;import Detail from &#39;./components/Home&#39;const router = new VueRouter({ routes:[ { path:&#39;/about&#39;, component:About }, { path:&#39;/home&#39;, component:Home, children:[ { path:&#39;news&#39;, //此处一定不要写 /news component:News }, { path:&#39;message&#39;, //此处一定不要写 /message component:Message, children:[ name:&#39;xijie&#39;, // 添加路由名字 path:&#39;Detail&#39;, component:Detail // 配置Detail组件 ] }, ] } ] )} // 暴露router export default routerMessage.vue&amp;lt;!--简化前--&amp;gt;&amp;lt;router-link to=&#39;/home/news/detail&#39;&amp;gt;跳转 &amp;lt;/router-link&amp;gt;&amp;lt;!--简化后,直接通过名字跳转,方便了程序员--&amp;gt;&amp;lt;router-link to=&#39;{name:&quot;hello&quot;}&#39;&amp;gt;跳转 &amp;lt;/router-link&amp;gt;&amp;lt;!--简化后,配合传参--&amp;gt;&amp;lt;router-link :to=&quot;{ name:&#39;hello&#39;, query:{ id :666, title:&#39;你好&#39; } }&quot; &amp;gt; 跳转&amp;lt;/router-link&amp;gt;8.路由params传参router.jsimport VueRouter from &#39;vue-router&#39;import About from &#39;./components/About&#39;import Home from &#39;./components/Home&#39;import Detail from &#39;./components/Home&#39;const router = new VueRouter({ routes:[ { path:&#39;/about&#39;, component:About }, { path:&#39;/home&#39;, component:Home, children:[ { path:&#39;news&#39;, //此处一定不要写 /news component:News }, { path:&#39;message&#39;, //此处一定不要写 /message component:Message, children:[ name:&#39;xijie&#39;, // 添加路由名字 path:&#39;detail/:id/:title&#39;, // 使用占位符声明接收params参数 component:Detail // 配置Detail组件 ] }, ] } ] )} // 暴露router export default routerMessage.vue&amp;lt;!--使用to字符串写法--&amp;gt;&amp;lt;router-link to=&#39;`/home/news/detail/$/`&#39;&amp;gt;跳转 &amp;lt;/router-link&amp;gt;&amp;lt;!--使用to的对象写法特别注意:使用to的对象写法，则不能使用path的配置项，必须使用name配置！--&amp;gt;&amp;lt;router-link :to=&quot;{ name:&#39;xijie&#39;, params:{ id :666, title:&#39;你好&#39; } }&quot; &amp;gt;跳转&amp;lt;/router-link&amp;gt;9.路由的props配置​ 作用：让路由组件更方便的收到参数Message.vue&amp;lt;template&amp;gt;&amp;lt;div&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li v-for =&quot;m in messageList&quot; :key=&#39;m.id&#39;&amp;gt; &amp;lt;router-link :to=&quot;{ path:&#39;/home/message/detail&#39;, query:{ id:m.id, title:m.title } }&quot;&amp;gt; &amp;lt;/router-link&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt; export default{ name:&#39;Message&#39;, data(){ return{ messageList:[ { id:&#39;001&#39;,title:&#39;消息001&#39; }, { id:&#39;002&#39;,title:&#39;消息002&#39; }, { id:&#39;003&#39;,title:&#39;消息003&#39; } ] } } }&amp;lt;/script&amp;gt;router.jsimport VueRouter from &#39;vue-router&#39;import About from &#39;./components/About&#39;import Home from &#39;./components/Home&#39;import Detail from &#39;./components/Home&#39;const router = new VueRouter({ routes:[ { path:&#39;/about&#39;, component:About }, { path:&#39;/home&#39;, component:Home, children:[ { path:&#39;news&#39;, //此处一定不要写 /news component:News }, { path:&#39;message&#39;, //此处一定不要写 /message component:Message, children:[ { name:&#39;xiangqing&#39;, path:&#39;detail&#39;, component:Detail, //第一种写法:props值为对象，该对象中所有的key-value的组合最终会通过props传给Detail组件 // props:{a:900} // 第二种写法:props值为布尔值，布尔值为true，这把路由所有收到的params参数通过props传给Detail组件 // props：true // 第三种写法:props值为函数，参数是$router，该函数返回的对象中每一组key-value都会通过props传给Detail组件 props($route):{ return{ id:$route.query.id, title:$route.query.title } } } ] }, ]} ] )}// 暴露routerexport default routerDetail.vue&amp;lt;template&amp;gt;&amp;lt;ul&amp;gt; &amp;lt;li&amp;gt; 消息编号： &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 消息标题： &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt; export default{ name:&#39;Detail&#39;, props:[&#39;id&#39;,&#39;title&#39;] // props 接收参数 }&amp;lt;/script&amp;gt;10.无痕浏览 router-link的replace属性 作用：控制路由的跳转时，操作浏览器的历史记录模式 浏览器的历史记录有两种写入模式：分别是push和replace push用来追加历史记录【默认开启】 replace用来替换当前历史记录【无痕浏览】 开启replace方法 &amp;lt;router-link replace&amp;gt; new&amp;lt;/router-link&amp;gt; 11.编程式路由导航 作用：不借助&amp;lt;router-link&amp;gt;实现路由跳转，让路由跳转更加灵活 具体编码Message.vue// router的两个APImethods{ this.$router.push({ name:&#39;xiangqing&#39;, params:{ id:666, title:&#39;hello&#39; } }) // 无痕的方法 this.$router.replace({ name:&#39;xiangqing&#39;, params:{ id:666, title:&#39;hello&#39; } })}this.$router.forward() // 前进this.$router.back() // 后退this.$router.go() // 可进可退12.缓存路由组件 作用：让不展示的路由组件保持挂载，不被销毁 具体编码 &amp;lt;keep-alive include=&#39;News&#39;&amp;gt; &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;&amp;lt;/keep-alive&amp;gt; 缓存需要使用keep-alive便签包裹router-view，include 里面写需要缓存的组件名，这样该组件在被切换后，不会被销毁，得以保存数据； 如果是多个，直接写成数组 include=&quot;[&#39;News&#39;,&#39;Message&#39;]&quot; 13.路由组件钩子 作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态 具体名字： activated 路由组件被激活时触发 deactivated路由组件失活时触发 &amp;lt;script&amp;gt; methods:{ // 组件激活时，开启定时器 activated(){ console.log(&quot;组件激活了&quot;) this.timer = setInterval(()=&amp;gt;{ console.log(&#39;@&#39;) },1000) }, // 组件失效时，关闭定时器 deactivated(){ console.log(&#39;组件失活了&#39;) clearInterval(this.timer) } }&amp;lt;/script&amp;gt;14.路由守卫 作用：对路由进行权限控制 分类：全局路由守卫、独享路由守卫、组件内守卫 全局路由守卫router.jsimport VueRouter from &#39;vue-router&#39;import About from &#39;./components/About&#39;import Home from &#39;./components/Home&#39;import Detail from &#39;./components/Home&#39;const router = new VueRouter({ routes:[ { path:&#39;/about&#39;, component:About, meta:{isAuth:true,title:&#39;关于&#39;} // 配置元数据 ，设定是否需要权限校验 }, { path:&#39;/home&#39;, component:Home, children:[ { path:&#39;news&#39;, //此处一定不要写 /news component:News }, { path:&#39;message&#39;, //此处一定不要写 /message component:Message, children:[ name:&#39;xijie&#39;, // 添加路由名字 path:&#39;detail/:id/:title&#39;, // 使用占位符声明接收params参数 component:Detail // 配置Detail组件 ] }, ] } ] )} //全局前置守卫：初始化时执行、每次路由切换前执行 // to -- 跳转后的路由信息，from-- 跳转前的路由信息 ，next -- 放行跳转 router.beforeEach((to,from,next)=&amp;gt;{ console.log(&#39;前置路由守卫 beforeEach&#39;,to,from) if (to.meta.isAuth){ // 判断是否需要鉴权 if(localStorage.getItem(&#39;school&#39;)===&#39;atguigu&#39;){ //放行 next() }else{ alert(&#39;暂时无权查看&#39;) } }else{ // 放行 next() }})// 全局后置守卫：初始化时执行、每次路由切换后执行router.afterEach((to,from)=&amp;gt;{ console.log(&#39;后置路由守卫afterEach&#39;,to,from) // 切换路由后，可以实现title的切换；需要在每个路由中配置元信息 if(to.meta.title){ document.title = to.meta.title }else{ // 设置默认的title（由于原始的title没有配置） document.title = &#39;vue_test&#39; }})// 暴露routerexport default router 独享路由守卫router.jsimport VueRouter from &#39;vue-router&#39;import About from &#39;./components/About&#39;import Home from &#39;./components/Home&#39;import Detail from &#39;./components/Home&#39;const router = new VueRouter({ routes:[ { path:&#39;/about&#39;, component:About, meta:{isAuth:true,title:&#39;关于&#39;}, // 配置元数据 ，设定是否需要权限校验 // 独享路由守卫，在独立的路由中定义。其没有前置路由守卫，因为他自己就是前置路由守卫 beforeEnter(to,from,next){ console.log(&#39;beforeEnter&#39;,to,from) if(to.meta.isAuth){ if (localStorage.getItem(&#39;school&#39;)==&#39;atguigu&#39;){ next() }else{ alert(&#39;暂无权限查看&#39;) } }else{ next() } } }, { path:&#39;/home&#39;, component:Home, children:[ { path:&#39;news&#39;, //此处一定不要写 /news component:News }, { path:&#39;message&#39;, //此处一定不要写 /message component:Message, children:[ name:&#39;xijie&#39;, // 添加路由名字 path:&#39;detail/:id/:title&#39;, // 使用占位符声明接收params参数 component:Detail // 配置Detail组件 ] }, ] } ], )} // 全局后置守卫：初始化时执行、每次路由切换后执行router.afterEach((to,from)=&amp;gt;{ console.log(&#39;后置路由守卫afterEach&#39;,to,from) // 切换路由后，可以实现title的切换；需要在每个路由中配置元信息 if(to.meta.title){ document.title = to.meta.title }else{ // 设置默认的title（由于原始的title没有配置） document.title = &#39;vue_test&#39; }})// 暴露routerexport default router 组件内路由守卫src/components/about.vue&amp;lt;template&amp;gt;&amp;lt;div id=&quot;&quot;&amp;gt; &amp;lt;h1&amp;gt;这是about页面&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt; export default { name:&quot;About&quot;, // 进入守卫。通过路由规则，进入该组件时被调用 beforeRouteEnter(to,from,next){ console.log(&#39;APP-挂载组件&#39;,to,from) next() }, // 离开守卫。通过路由规则，离开该组件时被调用 beforeRouteLeave(to,from,next){ console.log(&#39;APP-挂载组件离开&#39;,to,from) next() } }&amp;lt;/script&amp;gt;&amp;lt;style&amp;gt;&amp;lt;/style&amp;gt;15.history模式 / hash模式​ 在开发时候的路由有#号，默认就是hash模式。 对于一个url来说，# 后面的内容就是hash值 hash值不会包含在http请求中，即：hash值不会带给服务器 hash模式： 地址中永远带着#号，不美观 若以后将地址通过第三方收集App分享，若app校验严格，则地址会被标记为不合法 hash模式兼容性较好 history模式： 地址干净，美观 兼容性比hash模式略差 应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题（这些可以通过nginx解决） import VueRouter from &#39;vue-router&#39;import About from &#39;./components/About&#39;import Home from &#39;./components/Home&#39;import Detail from &#39;./components/Home&#39;const router = new VueRouter({ mode:&#39;history&#39;, // 使用history就没有# routes:[ { path:&#39;/about&#39;, component:About }, { path:&#39;/home&#39;, component:Home, } ] )} // 暴露router export default router参考链接1.最详细Vuex教程（超详细）-基本使用2.Vuex从入门到实战(这个讲的很详细，建议看)3.Vue路由（vue-router）详细讲解指南" }, { "title": "Vue脚手架与案例", "url": "/posts/%E5%89%8D%E7%AB%AF-Vue%E8%84%9A%E6%89%8B%E6%9E%B6%E4%B8%8E%E6%A1%88%E4%BE%8B/", "categories": "前端", "tags": "前端Vue", "date": "2021-05-20 00:00:00 +0800", "snippet": "1. 安装流程1.1 安装node.js​ 安装之前检查是否已经安装node环境，如果有，我们就进行接下来的vue-cli的安装；若没有，我们则先安装node环境。Windows系统前往node.js官网下载相应的node.js安装包node.js官网1.2 安装vue-cli​ 安装vue-cli脚手架，安装代码为：npm install -g vue-cli，我们在这里选择的是全局安装，安装完之后创建项目。1.3 创建项目​ 创建项目文件夹 vue create project_name，根据配置生成vue项目。2. 解析项目架构 名称 说明 node_modules node模块，支撑项目运行的模块 public 公共文件 src 原文件，用来开发的文件目录 .git 使用git进行版本控制 .gitignore git忽略上传更新的文件目录 babel.config.js 语法转换，将高级的语法转换为 低级的语法 (ES6转ES5) package.json 功能包列表文件 package.lock.json 包版本控制文件 README.md 项目的总体概览文件 ​ 在vue的开发中，主要集中在对src目录的编写，下面着重介绍src目录src目录结构src |--- assets |--- components |--- App.vue |--- main.jspublic |--- index.html |--- favicon.ico2.1 解析main.jsmain.js是整个项目的入口文件main.js// 引入vue对象、App对象import Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;// 关闭生产模式Vue.config.productionTip = false// 创建Vue实例对象new Vue({ // 此行代码很精髓，用来将App组件放入容器中 render: h =&amp;gt; h(App),}).$mount(&#39;#app&#39;)2.2 解析app.vueApp.vue​ App.vue是所有组件的父组件。&amp;lt;template&amp;gt;&amp;lt;div id=&quot;app&quot;&amp;gt; &amp;lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&amp;gt; &amp;lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot;/&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt; import HelloWorld from &#39;./components/HelloWorld.vue&#39; export default { name: &#39;App&#39;, components: { HelloWorld } }&amp;lt;/script&amp;gt;&amp;lt;style&amp;gt; #app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; }&amp;lt;/style&amp;gt;2.3 解析 components./components/HelloWorld.vue&amp;lt;template&amp;gt;&amp;lt;div class=&quot;hello&quot;&amp;gt; &amp;lt;h1&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt; For a guide and recipes on how to configure / customize this project,&amp;lt;br&amp;gt; check out the &amp;lt;a href=&quot;https://cli.vuejs.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&amp;gt;vue-cli documentation&amp;lt;/a&amp;gt;. &amp;lt;/p&amp;gt; &amp;lt;h3&amp;gt;Installed CLI Plugins&amp;lt;/h3&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-babel&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&amp;gt;babel&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-eslint&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&amp;gt;eslint&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;h3&amp;gt;Essential Links&amp;lt;/h3&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;https://vuejs.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&amp;gt;Core Docs&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;https://forum.vuejs.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&amp;gt;Forum&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;https://chat.vuejs.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&amp;gt;Community Chat&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;https://twitter.com/vuejs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&amp;gt;Twitter&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;https://news.vuejs.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&amp;gt;News&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;h3&amp;gt;Ecosystem&amp;lt;/h3&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;https://router.vuejs.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&amp;gt;vue-router&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;https://vuex.vuejs.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&amp;gt;vuex&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;https://github.com/vuejs/vue-devtools#vue-devtools&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&amp;gt;vue-devtools&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;https://vue-loader.vuejs.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&amp;gt;vue-loader&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;https://github.com/vuejs/awesome-vue&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&amp;gt;awesome-vue&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt; export default { name: &#39;HelloWorld&#39;, props: { msg: String } }&amp;lt;/script&amp;gt;&amp;lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&amp;gt;&amp;lt;style scoped&amp;gt; h3 { margin: 40px 0 0; } ul { list-style-type: none; padding: 0; } li { display: inline-block; margin: 0 10px; } a { color: #42b983; }&amp;lt;/style&amp;gt;2.4 解析public​ public文件夹位于项目架构主文件夹下，其下有一个index.html，作为vue项目的容器。即是上面那行精髓代码 render: h =&amp;gt; h(App)的神奇组合。public/index.html&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;&quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt; &amp;lt;!-- 针对IE浏览器的一个特殊配置，含义是让IE浏览器以最高的渲染级别渲染页面 --&amp;gt; &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&amp;gt; &amp;lt;!-- 开启移动端的理想视口 --&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&amp;gt; &amp;lt;!-- 配置标签图标 --&amp;gt; &amp;lt;link rel=&quot;icon&quot; href=&quot;&amp;lt;%= BASE_URL %&amp;gt;favicon.ico&quot;&amp;gt; &amp;lt;!-- 配置网站标题 --&amp;gt; &amp;lt;title&amp;gt;&amp;lt;%= htmlWebpackPlugin.options.title %&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;noscript&amp;gt; &amp;lt;strong&amp;gt;We&#39;re sorry but &amp;lt;%= htmlWebpackPlugin.options.title %&amp;gt; doesn&#39;t work properly without JavaScript enabled. Please enable it to continue. &amp;lt;/strong&amp;gt; &amp;lt;/noscript&amp;gt; &amp;lt;!-- 容器 --&amp;gt; &amp;lt;div id=&quot;app&quot;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- built files will be auto injected --&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;2.5 解析神奇函数的render​ 由于import Vue from &quot;vue&quot;这一句话，引入的是模块其实是vue/dist/vue.runtime.esm.js.​ 而这个文件中是精简版的vue.js(文件中没有模板解析器complier)，显然直接运行原来的代码会报错。// 引入vue对象、App对象import Vue from &#39;vue&#39;// 关闭生产模式Vue.config.productionTip = false// 创建Vue实例对象new Vue({ el:&quot;#app&quot;, template:`&amp;lt;h1&amp;gt;你好啊&amp;lt;/h1&amp;gt;` //render: h =&amp;gt; h(App),})上述代码报错，解析器给出两个解决方案 使用vue.js文件（因为他有模板编译器） // 引入完整版的vueimport Vue from &#39;vue/dist/vue&#39; // 关闭生产模式Vue.config.productionTip = false // 创建Vue实例对象new Vue({ el:&quot;#app&quot;, template:`&amp;lt;h1&amp;gt;你好啊&amp;lt;/h1&amp;gt;` //render: h =&amp;gt; h(App),}) 这样就可以成功渲染页面 使用render函数 ​ vue.runtime.esm.js(精简版的vue)，优势在于其文件小，打包的时候就没有模板解析器，可减小打包后的文件；所以后面直接使用精简版的vue，但必须通过render来渲染模板。 // 引入完整版的vueimport Vue from &#39;vue/dist/vue&#39; // 关闭生产模式Vue.config.productionTip = false // 创建Vue实例对象new Vue({ el:&quot;#app&quot;, render(createElement){ return createElement(&#39;h1&#39;,&#39;你好啊&#39;) }}) render(createElement){ return createElement(&#39;h1&#39;,&#39;你好啊&#39;)} 可以写成render:(createElement) =&amp;gt; {return createElement(&#39;h1&#39;,&#39;你好啊&#39;)}可以写成render:createElement =&amp;gt; createElement(&#39;h1&#39;,&#39;你好啊&#39;)可以写成render:h =&amp;gt; h(&#39;h1&#39;,&#39;你好啊&#39;) 最终写成 // 引入vue对象、App对象import Vue from &#39;vue&#39;import App from &#39;./App.vue&#39; // 关闭生产模式Vue.config.productionTip = false // 创建Vue实例对象new Vue({ // 此行代码很精髓，用来将App组件放入容器中 render: h =&amp;gt; h(App),}).$mount(&#39;#app&#39;) 2.6 vue.config.js​ vue.config.js 是一个可选的配置文件，如果项目的 (和 package.json 同级的) 根目录中存在这个文件，那么它会被 @vue/cli-service 自动加载。你也可以使用 package.json 中的 vue 字段，但是注意这种写法需要你严格遵照 JSON 的格式来写。vue.config.jsmodule.exports = { lintOnSave: false, devServer: { proxy: { &#39;/api&#39;: { target: &#39;&amp;lt;url&amp;gt;&#39;, ws: true, changeOrigin: true }, &#39;/foo&#39;: { target: &#39;&amp;lt;other_url&amp;gt;&#39; } } }}平时配置的时候，用的最多的就是关闭语法检查和配置路由(跨域)vue.config.js配置参考3.Tolist案例3.1 bootstrap-vue样式库vue 引入boostrapnpm i bootstrap-vuemain.jsimport Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;Vue.config.productionTip = falseimport BootstrapVue from &quot;bootstrap-vue&quot;Vue.use(BootstrapVue)import &quot;bootstrap/dist/css/bootstrap.css&quot;import &quot;bootstrap-vue/dist/bootstrap-vue.css&quot;new Vue({ render: h =&amp;gt; h(App), beforeCreate() { Vue.prototype.$bus = this }}).$mount(&#39;#app&#39;)3.2 父子通信​ 在vue中的父子通信有多种方式，此处介绍两种 props父子传参 全局事件总线3.2.1 props父子传参​ 在父组件中，需要将todolist传入子组件MyList中，在父组件调用子组件的地方写入数据绑定:todolist = todolist，第一个todolist是组件中变量名（相当于形参），第二个todolist是父组件中的todolist变量。App.vue&amp;lt;template&amp;gt; &amp;lt;div id=&quot;app&quot;&amp;gt; &amp;lt;MyList :todolist=&quot;todolist&quot; /&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt; export default { name: &#39;App&#39;, components: { MyHeader, MyFooter, MyList }, data() { return { todolist: [{ &quot;id&quot;:&quot;0&quot;, &quot;name&quot;: &quot;吃饭&quot;, &quot;check&quot;: false }, { &quot;id&quot;:&quot;1&quot;, &quot;name&quot;: &quot;睡觉&quot;, &quot;check&quot;: false }, { &quot;id&quot;:&quot;2&quot;, &quot;name&quot;: &quot;打豆豆&quot;, &quot;check&quot;: false }, ], complete_sum: 0, sum: 0, } } }&amp;lt;/script&amp;gt;在子组件中，使用props来承接变量，这样就可以直接使用todolist变量了。MyList.vue&amp;lt;template&amp;gt; &amp;lt;div id=&quot;items&quot; &amp;gt; &amp;lt;MyItem v-for=&quot;(item,index) in todolist&quot; :thing = &quot;item&quot; :key=&quot;item.id&quot;/&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt; import MyItem from &quot;./MyItem.vue&quot; export default { name: &quot;MyList&quot;, components:{MyItem}, props:[&quot;todolist&quot;], }&amp;lt;/script&amp;gt;3.2.2 全局事件总线​ 全局事件总线是一种组件间通信的方式，适用于任意组件间通信。第一步： 在main.js中安装事件总线import Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;Vue.config.productionTip = falseimport BootstrapVue from &quot;bootstrap-vue&quot;Vue.use(BootstrapVue)import &quot;bootstrap/dist/css/bootstrap.css&quot;import &quot;bootstrap-vue/dist/bootstrap-vue.css&quot;new Vue({ render: h =&amp;gt; h(App), // 安装全局事件总线 beforeCreate() { Vue.prototype.$bus = this }}).$mount(&#39;#app&#39;)第二步：使用事件总线1.接收数据：A事件需要接受数据，则在A组件中给$bus 绑定自定义事件。App.vue&amp;lt;script&amp;gt; methods: { delete_item(index) { this.todolist.forEach((todo)=&amp;gt;{ if (todo.id ==index){ this.todolist.splice(index,1) } }) }, add_item(hobby) { this.todolist.push({ &quot;id&quot;:String(this.sum), &quot;name&quot;: hobby, &quot;check&quot;: false }); }, mod_check(index) { this.todolist.forEach((todo)=&amp;gt;{ if (todo.id ==index){ this.todolist[index].check = !this.todolist[index].check } }) } }, mounted() { this.$bus.$on(&#39;addItem&#39;, this.add_item) this.$bus.$on(&#39;delItem&#39;, this.delete_item) this.$bus.$on(&#39;modCheck&#39;, this.mod_check) },&amp;lt;/script&amp;gt; 2.提供数据​ 在提供数据的B组件中，写入 this.$bus.$emit(&#39;注册的事件名&#39;,数据)，则将提供数据的B组件中的数据传入A组件，并触发A组件中的函数。MyList.vue&amp;lt;script&amp;gt; export default { name: &quot;MyItem&quot;, data(){ return{ show:false } }, props:[&quot;thing&quot;], methods:{ display(){ this.show = !this.show }, del(){ this.$bus.$emit(&#39;delItem&#39;,this.thing.id) }, mod_check(){ this.$bus.$emit(&#39;modCheck&#39;,this.thing.id) } }, }&amp;lt;/script&amp;gt;3.3 本地数据存储webStorage存储内容大小一般支持5MB左右（不同的浏览器可能还不一样）。浏览器端通过windows.sessionStorage和window.localStorage属性来实现本地存储机制。 localStorage会一直保存，除非手动删除 sessionStorage操作的方法与localStorage是一样的，区别在于 sessionStorage 当前页面有效`，在关闭页面后即被清空 xxxxxStorage.getItem(&#39;person&#39;)。如果获取不到对应的value，会返回null JSON.parse(null)的结果依然是null 操作方式 存储方式 说明 存储设置 xxxxxStorage.setItem(&#39;key&#39;,&#39;value&#39;) 该方法接收一个键值对对位参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值 读取数据 xxxxxStorage.getItem(&#39;person&#39;) 该方法接收一个键名作为参数，返回键名对应的值 清除数据 xxxxxStorage.removeItem(&#39;person&#39;) 该方法接收一个键名作为参数，并把该键名从存储中删除 清空所有数据 xxxxxStorage.clear() 该方法会清空存储中的所有数据 window.localStorage.setItem(&#39;myCat&#39;, &#39;Tom&#39;); // 设置let cat = window.localStorage.getItem(&#39;myCat&#39;); // 读取window.localStorage.removeItem(&#39;myCat&#39;); // 移除window.localStorage.clear(); // 清空所有window.localStorage.key(1); // 读取索引为1的值window.localStorage.length; // 数目&amp;lt;script&amp;gt; watch: { hobbys:{ deep:true, handler(value){ localStorage.setItem(&#39;hobbys&#39;, JSON.stringify(value)) }, } }&amp;lt;/script&amp;gt;&amp;lt;script&amp;gt; data() { return { // 解决初始化没有数组返回null的问题，添加 |[] hobbys: JSON.parse(localStorage.getItem(&#39;hobbys&#39;)) || [] } }&amp;lt;/script&amp;gt;参考链接1.浏览器存储 的几种方式" }, { "title": "Vue组件", "url": "/posts/%E5%89%8D%E7%AB%AF-Vue%E7%BB%84%E4%BB%B6/", "categories": "前端", "tags": "前端Vue", "date": "2021-05-19 00:00:00 +0800", "snippet": "1. 组件1.1 定义​ 组件的定义：实现应用中局部功能代码和资源的集合​ 作用：复用编码、简化项目编码、提高后台运行效率 传统方式编写应用 组件方式编写应用 1.2 组件化编程 单文件组件：一个文件中包含n个组件 单文件组件：一个文件只包含1个组件1.3 使用步骤 定义组件 注册组件 使用组件（写组件标签）使用Vue.extend(options)创建，其中options和new Vue(options)中传入的options几乎一样，但有点区别，区别如下： el不要写，为什么？ 最终所有的组件都要经过vm的管理，由vm的el决定服务哪个容器 data必须写成函数，为什么？ 避免组件被复用时，数据存在引用关系 如何注册组件？ 局部注册： new Vue的时候传入components选项 全局注册： Vue.component(&#39;组件名&#39;，组件) 编写组件 第一种写法：&amp;lt;school&amp;gt;&amp;lt;/school&amp;gt; 第二种写法（脚手架必用）注意：这种写法叫做自闭标签，推荐在脚手架中使用； 不使用脚手架时，自闭标签会导致后续组件不能渲染&amp;lt;school/&amp;gt; // 定义组件const school = Vue.extend(options)可简写为：const school = options &amp;lt;body&amp;gt; &amp;lt;div id=&quot;root1&quot;&amp;gt; &amp;lt;!-- 第三步 编写组件标签 --&amp;gt; &amp;lt;school&amp;gt;&amp;lt;/school&amp;gt; &amp;lt;student&amp;gt;&amp;lt;/student&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div id=&quot;root2&quot;&amp;gt; &amp;lt;hello&amp;gt;&amp;lt;/hello&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;script src=&quot;./vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt; Vue.config.productionTip = false // 第一步 创建组件 const school = Vue.extend({ template: `&amp;lt;div&amp;gt;学校： 地址： &amp;lt;button type=&quot;button&quot;@click=&quot;showSchoolName&quot;&amp;gt;点击出现学校名&amp;lt;/button&amp;gt;&amp;lt;/div&amp;gt;`, data() { return { schoolName: &#39;尚硅谷&#39;, address: &#39;北京昌平&#39; } }, methods: { showSchoolName() { alert(this.schoolName) } } }); const student = Vue.extend({ template: `&amp;lt;div&amp;gt;学生： 年龄：&amp;lt;/div&amp;gt;`, data() { return { studentName: &#39;张三&#39;, age: &#39;19&#39; } } }); const hello = Vue.extend({ template: `&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;`, data() { return { msg: &#39;你好啊&#39; } } }) // 第二步 全局注册 Vue.component(&#39;hello&#39;, hello) //第二步 注册组件【局部】 new Vue({ el: &#39;#root1&#39;, components: { school, student }, }) new Vue({ el: &#39;#root2&#39;, })&amp;lt;/script&amp;gt;1.4 关于VueCompnent school组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，而是Vue.extend生成的【源码可查】 我们只需要写 &amp;lt;school/&amp;gt; 或者&amp;lt;school&amp;gt;&amp;lt;/school&amp;gt;,Vue解析时会帮我们创建school组件的实例对象，即vue帮我们执行的是 new VueComponent(options) 特别注意：每次调用Vue.extend,返回的都是一个全新(New)的VueComponent！！！ 关于this的指向 组件配置中： data函数、methods中的函数、watch中的函数、computed中的函数，它们的this均是 【VueComponent实例对象】 new Vue()配置中： data函数、methods中的函数、watch中的函数、computed中的函数，它们的this均是 【Vue实例对象】 VueComponent的实例对象，以后简称为vc（组件实例对象） Vue实例对象，以后简称vm 1.5 一个重要的内置关系 一个重要的内置关系： VueComponent.prototype.__proto__ === Vue.prototype 为什么要有这个关系? 让组件实例对象（vc)可以访问到Vue原型上的属性、方法。 函数 对应才有 prototype，实例对象有的是 __prototype__。 1.6 单文件组件Vue三大件&amp;lt;template&amp;gt;&amp;lt;/template&amp;gt; 写结构&amp;lt;script&amp;gt;&amp;lt;/script&amp;gt; 写交互&amp;lt;style&amp;gt;&amp;lt;/style&amp;gt; 写样式2.组件通信1. ref属性 被用来给元素或子组件注册引用信息（id的替代者） 应用在html标签上获取的是真实的DOM元素，应用在标签上是组件实例对象 使用方式： 打标识 &amp;lt;h1 ref=&#39;xxx&#39;&amp;gt; .....&amp;lt;h1&amp;gt; 或者 &amp;lt;School ref=&quot;xxx&quot;&amp;gt;&amp;lt;School&amp;gt; 获取：this.$refs.xxx 2. props属性(☆☆☆☆☆)​ 功能： 让组件接收外部传过来的数据 传递数据： &amp;lt;Demo name=&quot;xxx&quot;&amp;gt;&amp;lt;/Demo&amp;gt; 接收数据 //第一种方式（只接收）props：[&#39;name&#39;]//第二种方式（限制类型） props:{ name:String}; //第三种方式（限制类型、限制必要性、指定默认值）props：{ name:{ type:string,//类型 required：true, //必要性,必须得传name属性 default:&#39;老王&#39; //默认值，如果必要性不满足，默认选择这个，一般不和required一起用 }} 备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告; ​ 若业务需求确实需要修改，那么请复制props的内容到data中一份，然后修改data中的数据。 此处注意从外部传来值得顺序： ​ ` 外部值 (如年龄age) —&amp;gt; props (age放到vc）—&amp;gt;data (age赋值到myage中 myage：age)—&amp;gt; methods (操作myage)` 功能：props广泛用于父子组件的传值，需要扎实掌握 3. mixin属性​ 混入功能：可以把多个组件公用的配置提取到一个混入对象中（一个js文件中）//第一步：定义混合，例如export const m = { data(){...}, methods:{...}, ....};//第二步:使用混入，例如1. 全局混入 ： Vue.mixin(xxx) //在main.js中配置,即vm中配置了mixin的属性,使得该vue项目中所有的组件都有了mixin中的属性 Vue.mixin(hunhe1); Vue.mixin(hunhe2);2. 局部混入 ： mixins:[&#39;xxx&#39;]mixin.jsexport const hunhe1 = { methods:{ showName(){ alert(this.name) } }}export const hunhe2={ data(){ return { x:100, y:200 } }}School.vue&amp;lt;template&amp;gt;&amp;lt;div&amp;gt; &amp;lt;h2 @click=&quot;showName&quot;&amp;gt;学校名称： &amp;lt;/h2&amp;gt; &amp;lt;h2&amp;gt;学校地址：&amp;lt;/h2&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt; import {hunhe1,hunhe2} from &quot;mixin.js&quot; export default{ name:&quot;School&quot;, data(){ name:&quot;shangguigu&quot;, adress:&#39;beijing&#39;, x:666 }, // 引入后，该组件就具有了showName方法 // 引入了新的x，y值，由于原组件有x值，所以以原组件为主，x值为666 mixin:[hunhe1,hunhe2] }&amp;lt;/script&amp;gt;4. 插件​ 插件功能：用于增强Vue功能​ 本质：包含install方法的一个对象，install的第一个参数---Vue,第二个参数---插件使用者传递的数据​ 插件在Vue中应用比较广泛，在使用第三方插件，如elementUI等plugins.js// 定义插件export default{ install(Vue) = function (Vue,options){ // 1.添加全局过滤器 Vue.filter(&quot;myfilter&quot;,function(value){ return value.slice(0,4) // 过滤器保留四位有效数字 }); // 2.添加全局指令 //自定义v-fbind指令,指令与元素成功绑定时 Vue.directive(&quot;fbind&quot;,{ bind(element,binding){ element.value = binding.value } }) // 3.配置全局混入 Vue.mixin(...) // 4. 添加实例方法(给vue原型上添加方法，vm和vc都能用) Vue.prototype.$myMethod = function (){...} Vue.prototype.$myPrototype = xxx }}main.js// 使用插件,plugin.jsimport plugins from &#39;plugins.js&#39;Vue.use(plugins)Student.vue&amp;lt;template&amp;gt;&amp;lt;div&amp;gt; &amp;lt;h2&amp;gt; 学生姓名： &amp;lt;/h2&amp;gt; &amp;lt;h2&amp;gt; 学生性别： &amp;lt;/h2&amp;gt; &amp;lt;input type=&quot;text&quot; v-fbind:value=&quot;name&quot;&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt; export default{ name:&#39;Student&#39;, data(){ return{ name:&#39;张三&#39;, sex:&#39;男&#39; } } }&amp;lt;/script&amp;gt;5. scoped属性​ 作用：让样式在局部生效，防止冲突​ 写法 &amp;lt;style scoped&amp;gt;&amp;lt;template&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;style scoped&amp;gt;&amp;lt;/style&amp;gt;" }, { "title": "Vue指令", "url": "/posts/%E5%89%8D%E7%AB%AF-Vue%E6%8C%87%E4%BB%A4/", "categories": "前端", "tags": "前端Vue", "date": "2021-05-18 00:00:00 +0800", "snippet": "1. 概念​ vue常用指令有：v-once指令、v-show指令、v-if指令、v-else指令、v-else-if指令、v-for指令、v-html指令、v-text指令、v-bind指令、v-on指令、v-model指令等等。​ 前一节中对v-if指令、v-else指令、v-else-if指令已经有过介绍，本节记录其他的指令。2. v-text​ 相当于定义了 innerText，这个指令的使用率不高​ 作用：向其所在的节点中渲染文本内容​ 与插值语法的区别：v-text会替换节点中的内容，插值语法则不会&amp;lt;div&amp;gt;你好，&amp;lt;/div&amp;gt;&amp;lt;!-- 等价--&amp;gt;&amp;lt;div v-text=&#39;name&#39;&amp;gt;&amp;lt;/div&amp;gt; 3. v-html​ 相当于innerHtml&amp;lt;div v-html=&quot;&amp;lt;h3&amp;gt;你好&amp;lt;/h3&amp;gt;&quot;&amp;gt;&amp;lt;/div&amp;gt;​ 作用：向指定的节点渲染包含html结构的代码与插值语法的区别： v-html会替换节点中所有的内容，``则不会 v-html可以识别html结构严重注意：v-html有安全性问题！！！ 在网站上动态渲染任意html是非常危险的，容易导致XSS攻击 一定要在可信的内容上使用v-html，用不要用在用户提交的内容上4. v-once v-once所在的节点在初次动态渲染后，就视为静态内容了 以后的数据改变不会引起v-once所在结构的更新，可以用于优化性能 &amp;lt;div id =&quot;root&quot;&amp;gt; &amp;lt;h2 v-once&amp;gt; 初始化的n值为：&amp;lt;/h2&amp;gt; &amp;lt;h2 v-once&amp;gt; 当前n值为：&amp;lt;/h2&amp;gt; &amp;lt;button @click=&quot;n++&quot;&amp;gt; 点击+1 &amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;script&amp;gt; new Vue({ el:&#39;#root&#39;, data:{ n:1 } })&amp;lt;/script&amp;gt; 5. v-pre v-pre指令可以跳过其所在节点的编译过程 可以利用它跳过：没有使用指令的语法、没有使用插值语法的节点，达到加快编译的效果&amp;lt;div id=&quot;root&quot;&amp;gt; &amp;lt;h2 v-pre&amp;gt; Vue 其实就这么简单 &amp;lt;/h2&amp;gt; &amp;lt;h2&amp;gt; 当前n值为：&amp;lt;/h2&amp;gt;&amp;lt;/div&amp;gt;6. 自定义指令 定义语法： 局部指令 new Vue({ directives:{指令名：配置对象}});// 或new Vue({ directives{指令名：回调函数} }) 配置对象中常用的3个回调 bind：指令与元素成功绑定时调用 inserted：指令所在元素被插入页面时调用 update：指令所在模板结构被重新解析时调用 // 注册一个全局自定义指令 `v-focus`Vue.directive(&#39;focus&#39;, { // 当被绑定的元素插入到 DOM 中时…… inserted: function (el) { // 聚焦元素 el.focus() }}) 可以在模板中任何元素上使用新的 v-focus property，如下： &amp;lt;input v-focus&amp;gt; 备注 指令定义时不加v-，但使用时要加v- 指令名如果多个单词，要使用kebab-case命名方式，不要用camelCase命名 7. 生命周期 又名：生命周期回调函数、生命周期函数、生命周期钩子 是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数 生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的 生命周期函数中的this指向是vm 或者 组件实例对象Vue 2.x中定义了8个常用的钩子：beforeCreated、created，beforeMount、mounted、beforeUpdate、updated、beforeDestroy、destroyed（还有其余3个钩子后面讲）常用的生命周期钩子： mount：发送ajax请求、启动定时器、绑定自定义时间、订阅消息等 【初始化操作】 beforeDestroy：清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】 关于销毁Vue实例 销毁后借助Vue开发者工具看不到任何信息 销毁后自定义事件会失效，但原生DOM事件依然有效 一般不会在beforeDestroy操作数据，因为即便操作数据，也不会触发更新流程&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt; &amp;lt;title&amp;gt;生命周期函数&amp;lt;/title&amp;gt; &amp;lt;style type=&quot;text/css&quot;&amp;gt; div { margin-top: 10px; font-size: larger; } &amp;lt;/style&amp;gt; &amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&quot;root&quot;&amp;gt; &amp;lt;h2 :style=&quot;{opacity}&quot;&amp;gt;欢迎学习vue&amp;lt;/h2&amp;gt; &amp;lt;button type=&quot;button&quot; @click=&quot;opacity=1&quot;&amp;gt;透明度设置为1&amp;lt;/button&amp;gt; &amp;lt;button type=&quot;button&quot; @click=&quot;stop&quot;&amp;gt;点我停止变换&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script src=&quot;./vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script type=&quot;text/javascript&quot;&amp;gt; Vue.config.productionTip =false new Vue({ el: &#39;#root&#39;, data: { opacity:1, }, methods:{ stop(){ this.$destroy() } }, mounted(){ // 写一个定时器，用来调节文字透明度 this.timer = setInterval(()=&amp;gt;{ this.opacity -=0.01 if(this.opacity &amp;lt;=0) this.opacity = 1 },16) }, beforeDestroy(){ clearInterval(this.timer) //在销毁vue对象前，销毁定时器 } }) &amp;lt;/script&amp;gt;&amp;lt;/html&amp;gt;参考链接1.Vue 实例 — Vue.js (vuejs.org)" }, { "title": "Vue基础", "url": "/posts/%E5%89%8D%E7%AB%AF-Vue%E5%9F%BA%E7%A1%80/", "categories": "前端", "tags": "前端Vue", "date": "2021-05-17 00:00:00 +0800", "snippet": "1.概念​ Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。​ Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。​ 本节内容及后续，均采用Vue v2.6.14版本进行记录。如果有用到vue3.x，会着重说明。2.安装2.1 直接cdn引入开发环境和生产环境两个版本&amp;lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&amp;gt;&amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;或者：&amp;lt;!-- 生产环境版本，优化了尺寸和速度 --&amp;gt;&amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&amp;gt;&amp;lt;/script&amp;gt;2.2 下载js和引入​ 同常规的js文件引入2.3 npm安装​ 基于脚手架，通过node.js进行安装3. 开发案例 创建一个Vue实例，且要传入一个配置对象 &amp;lt;div&amp;gt; &amp;lt;h1 id =&quot;root&quot;&amp;gt; hello, &amp;lt;!-- 注意：这里使用了js的表达式，在vue中依然有效的，直接使用 --&amp;gt; 时间： &amp;lt;/h1&amp;gt; &amp;lt;input type=&#39;text&#39; :value=&quot;num&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; Vue.config.productionTip = false new VUE({ el:&quot;#root&quot;, data: function(){ return{ name:&#39;xiaoming&#39;, num: &quot;hello&quot; } } })&amp;lt;/script&amp;gt; root容器里的代码符合html代码规范 root容器里的代码被称为【vue模板】 容器和vue实例对象必须是一一对应关系 中xxx可以使用js表达式，且xxx可以自动读取到data中的所有属性 一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新 4. 模板语法 插值语法 1. 功能： 用于解析标签体内容2. 写法：，xxx是js表达式，且可以直接读取data中的所有属性,如1.2中的h1标签 指令语法 1. 功能：用于解析标签（包括：标签属性、标签体内容、绑定事件...)2. 指令如 v-bind、v-model... 数据绑定语法 1. 单项绑定（v-bind）：数据只能从data流向页面,一般应用到样式2. 双向绑定（v-model）：数据不仅能从data流向页面，也能从页面流向data 备注： 1. 双向绑定一般都用在表单元素上（如：input，select等） 2. v-model：value 可以简写为v-model，因为v-model默认收集的就是value值 挂载el与data写法 1. el的2种写法 1. new Vue的时候配置el的属性 2. 先创建Vue实例，随后通过vm.$mount(&#39;#root&#39;)指定el的值 2. data的2种写法 1. 对象式 2. 函数式【统一使用函数式】，即 data(){return {}} 3. 一个重要的原则 由Vue管理的函数，一定不要写箭头函数；因为一旦使用了箭头函数，this就不再是Vue实例了，而是window的作用域，指向window。 5. 数据代理​ 通过一个对象代理对另一个对象中的属性的操作。&amp;lt;script type=&quot;text/javascript&quot;&amp;gt; let obj = {x:100} let obj2 = {y:200} Object.defineProperty(obj2,&#39;x&#39;,{ get(){ return obj.x }, set(value){ obj.x = value } })&amp;lt;/script&amp;gt; Vue中的数据代理 通过vm对象来代理data对象中属性的操作（读/写） Vue中数据代理的好处 更加方便的操作data中的数据 基本原理 通过Object.defineProperty()把data对象中的所有属性添加到vm上，为每一个添加到vm上的属性都指定一个getter/setter。在getter/setter内部去操作（读/写）data中对应的属性 6. 事件处理 事件基本使用： 使用v-on:xxx或者@xxx绑定对象，其中xxx是事件名 事件的回调需要配置在methods对象中，最终会在vm上 methods中配置的函数，不要用箭头函数！否则this就不是vm了 methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或者 组件实例对象 @click = &quot;demo&quot; 和@click = &quot;demo($event)&quot;效果一致，都能获取event事件对象，但是后者的括号内可以写其他参数传参 事件修饰符 &amp;lt;button @click.prevent=&#39;run&#39;&amp;gt; &amp;lt;/button&amp;gt; prevent： 阻止默认事件（常用） stop：阻止事件冒泡（常用） once： 事件只触发一次（常用） capture：在事件捕获阶段就处理 （事件触发 ： 先捕获 –&amp;gt; 后冒泡执行） self： 只有event.target是当前操作的元素时才触发 passive：事件的默认行为立即执行，无需登台事件回调执行完毕 （@scroll滚动条事件，@wheel滚轮事件） 键盘事件 &amp;lt;div&amp;gt; &amp;lt;input type=&#39;text&#39; @keyup.enter = &quot;showInfo&quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;script&amp;gt; Vue.config.productionTip = false new VUE({ el:&quot;#root&quot;, data: function(){ return{ name:&#39;xiaoming&#39;, num: &quot;hello&quot; } }, methods:{ showInfo(e){ console.log(e.keyCode) } } })&amp;lt;/script&amp;gt; Vue常见的按键别名 按键 别名 按键 别名 enter 回车 delete 删除（捕获“删除”和“退格”键） esc 退出 space 空格 tab 换行 up 上 down 下 left 左 right 右     Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名 ，如CapsLock 写为 caps-lock） 系统修饰键（用法特殊）： ctrl、alt、shift、meta 配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发 配合keydown使用：正常触发事件 也可以使用keyCode去指定具体的按键（不推荐） Vue.config.keyCodes.自定义建名 = 键码 ，可以去定制按键别名 7. 计算属性 定义：要用的属性不存在，需要通过已有的属性计算得来 原理：底层借助了Object.defineProperty方法提供的getter和setter get函数什么时候执行？ 初次读取时会执行一次 当依赖的数据发生改变时会被再次调用 优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便 备注： 计算属性最终会出现在vm上，直接读取使用即可 如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变 &amp;lt;div id=&quot;root&quot;&amp;gt; 姓 &amp;lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&amp;gt; &amp;lt;br&amp;gt; 名 &amp;lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&amp;gt; &amp;lt;br&amp;gt; 全名 &amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;script&amp;gt; Vue.config.productionTip = false new VUE({ el:&quot;#root&quot;, data: function(){ return{ firstName:&#39;张&#39;, lastName: &quot;三&quot; } }, computed:{ fullName(){ return this.firstName + this.lastName //计算属性是靠返回值进行数据的修改；如果设置延迟，那就不能用计算属性了，因为返回不到原来模型中了。可以考虑使用watch } } })&amp;lt;/script&amp;gt;8. 监视属性 监视 当被监视的属性发生变化时，回调函数自动调用，进行相关操作 监视的属性必须存在，才能进行监视 监视的两种写法： new Vue时传入watch配置 通过vm.$watch进行监视配置 &amp;lt;div id=&quot;root&quot;&amp;gt; &amp;lt;div&amp;gt; 今天天气很 &amp;lt;/div&amp;gt; 数据 &amp;lt;/div&amp;gt;&amp;lt;script&amp;gt; Vue.config.productionTip = false new Vue({ el:&quot;#root&quot;, data:{ ishot:true }, watch:{ &quot;number.a&quot;:{ console.log(&quot;a值发生了改变&quot;)} // 监视多级结构中的单个值变化 }, &quot;number&quot;:{ deep:true, //深度监视开启，多级结构中的数据发生变化，均能够监视 console.log(&quot;number发生了变化&quot;) }, ishot(newvalue,oldvalue){ // 这儿底层使用了handler方法 console.log(&quot;ishot的值被修改了&quot;,&quot;新值为&quot;,newvalue,&#39;旧值为&#39;,oldvalue) } })&amp;lt;/script&amp;gt; 深度监视 Vue中的watch默认不监测对象内部值的改变（只监视第一层数据） 配置deep：true 可以监测对象内部值的改变（多层） 备注： 1. Vue本身可以监测对象内部值得改变，但Vue提供的watch默认不可以2. 使用watch时可以根据数据的具体结构，决定是否采用深度监视 immediate属性 上来就监听：就是挂载后，没有变化，就已经开始监听了 // 完整写法watch:{ sum:{ immediate:true, // watch 中必须通过handler函数来处理 handler(newValue,oldValue){ console.log(&#39;sum值变化了&#39;,newValue,oldValue) } }} 9. 计算属性和监视属性区别 computed能完成的功能，watch都可以完成。 watch能完成的功能，computed不一定能完成。例如：watch可以进行异步操作，如定时之后再返回值。两个重要的小原则： 所有被Vue管理的函数(即methods中的函数)，最好写成普通函数`，这样this的指向才是vm 或 组件实例对象 所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、promise的回调函数），最好写成箭头函数，这样this的指向才是vm 或 组件实例对象这两个原则都是将函数置于vm中，方便后续使用this进行调用。&amp;lt;div&amp;gt; 姓：&amp;lt;input type = &quot;text&quot; v-model=&quot;firstName&quot;&amp;gt; 名：&amp;lt;input type = &quot;text&quot; v-model=&quot;lastName&quot;&amp;gt; 全名：&amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;script text=&quot;text/javascript&quot;&amp;gt; Vue.config.productionTip = false const vm = Vue({ el:&quot;#root&quot;, data:{ firstName:&quot;张&quot;, lastName:&quot;三&quot;, }, watch:{ firstName(val){ setTimeout( // 箭头函数向外查找是firstName，而firstName是普通函数，隶属于$vm, // 所以,箭头函数隶属于vm ，箭头函数中的this指向vm ()=&amp;gt;{ this.fullName = val + &#39;-&#39;+this.lastName },1000); } } })&amp;lt;/script&amp;gt;&amp;lt;div&amp;gt; 姓：&amp;lt;input type = &quot;text&quot; v-model=&quot;firstName&quot;&amp;gt; 名：&amp;lt;input type = &quot;text&quot; v-model=&quot;lastName&quot;&amp;gt; 全名：&amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;script text=&quot;text/javascript&quot;&amp;gt; const vm = Vue({ el:&quot;#root&quot;, data:{ firstName:&quot;张&quot;, lastName:&quot;三&quot;, }, watch:{ firstName(val){ setTimeout( // 如果改成普通函数,普通函数式setTimeout的内部函数，而setTimeout隶属于window // 所以this是window,而window中没有lastName和fullName属性，导致出错 function(){ console.log(this) this.fullName = val + &#39;-&#39;+this.lastName },1000); } } })&amp;lt;/script&amp;gt;10. 样式绑定​ v-bind语法糖是冒号:&amp;lt;style&amp;gt; .happy:{...}, .sad:{...}, .normal:{...}&amp;lt;/style&amp;gt;&amp;lt;div id = &quot;root&quot;&amp;gt; &amp;lt;!--绑定class样式-- 字符串写法，适用于：样式的类名不确定，需要动态指定--&amp;gt; &amp;lt;div class = &quot;basic&quot; :class = &quot;mood&quot; @click= &quot;changeMode&quot;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!--绑定class样式-- 数组写法，适用于：样式的类名不确定，名字也不确定--&amp;gt; &amp;lt;div class = &quot;basic&quot; :class = &quot;classArr&quot;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!--绑定class样式--对象写法，适用于：样式个数确定、名字也确定，但是要动态决定用不用--&amp;gt; &amp;lt;div class = &quot;basic&quot; :class = &quot;classObj&quot;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;script&amp;gt; Vue.config.productionTip = false const vm = new Vue({ el:&quot;#root&quot;, data:{ name:&quot;尚硅谷&quot;, mood:&quot;normal&quot;, classArr:[&#39;atguigu1&#39;,&#39;atguigu2&#39;,&#39;atguigu3&#39;], classObj:{ atguigu1:false, atguigu2:false, } }, methods:{ // 点击切换 changeMode(){ this.mood = &quot;happy&quot; } } })&amp;lt;/script&amp;gt;11. 条件渲染 v-if 写法： v-if = &quot;表达式&quot; v-else-if = &quot;表达式&quot; v-else = “表达式 适用于：切换频率较低的场景 特点：不展示的DOM直接被移除 （类似css中的display属性） 注意：v-if 和 v-else-if、v-else一起使用，但要求结构不能被“打断” v-show写法 v-show = &quot;表达式&quot; 适用于：切换频率较高的场景 特点：不展示DOM元素未被移除，仅仅是使用样式隐藏掉 (类似css中的visibility属性) 备注：使用v-if时，元素可能无法获得，但使用v-show一定可以获取到 &amp;lt;!-- 使用template标签，可以不改变DOM的结构（使用div包裹就改变了结构），但是只能与v-if使用，不能配合v-show使用 --&amp;gt;&amp;lt;template v-if =true&amp;gt; &amp;lt;h2&amp;gt;你好&amp;lt;/h2&amp;gt; &amp;lt;h2&amp;gt;北京&amp;lt;/h2&amp;gt; &amp;lt;/template&amp;gt; 12. 列表渲染12.1 v-for指令 1. 用于展示列表数据 2. 语法v-for = &quot;(item,index) in xxx&quot; :key = &quot;yyy&quot; · 注意此处的key绑定，key为元素的唯一标识，非常重要 3. 可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）12.2 _key的作用和原理12.3 面试题react、vue中的key有什么作用？（key的内部原理） 虚拟DOM中key的作用 key是虚拟DOM对象的标识，当状态中的数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】。随后Vue进行【新的虚拟DOM】与【旧的虚拟DOM】差异比较，比较规则如下： 对比规则2.1. 旧的虚拟DOM中找到了与新的虚拟DOM相同的key： 1. 若虚拟DOM中的内容没变，直接使用之前的真实DOM —— 复用 2. 若虚拟DOM中的内容变了，则生成新的真实的DOM。 随后 替换掉页面中之前的真实DOM2.2 旧的虚拟DOM中未找到与新虚拟DOM相同的key 创建新的虚拟DOM 用index作为key可能引发的问题：1. 若对数据进行：逆序添加、逆序删除等破坏顺序的操作，会产生没有必要的真实DOM更新 ==&amp;gt; 导致界面效果没有问题且效率低（因为没有使用复用而重新生成）2. 如果结构中包含输入类的DOM： 会产生错误的DOM更新 ==&amp;gt;界面有问题 开发中如何选择key？1. 最好使用每条数据唯一标识作为key，比如ID、手机号、身份证号、学号等唯一值2. 如果不存在对数据的逆序添加、逆序删除等破坏顺序的操作，仅用于渲染列表，使用index作为key没有问题12.4 列表过滤&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt; &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&quot;root&quot;&amp;gt; &amp;lt;h2&amp;gt; 人员列表 &amp;lt;/h2&amp;gt; &amp;lt;input type =&#39;text&#39; placeholder=&quot;请输入名字&quot; v-model=&quot;keyWord&quot;&amp;gt; &amp;lt;button type=&quot;button&quot; @click=&quot;sortType=2&quot;&amp;gt;年龄升序&amp;lt;/button&amp;gt; &amp;lt;button type=&quot;button&quot; @click=&quot;sortType=1&quot;&amp;gt;年龄降序&amp;lt;/button&amp;gt; &amp;lt;button type=&quot;button&quot; @click=&quot;sortType=0&quot;&amp;gt;原顺序&amp;lt;/button&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li v-for=&quot;(p,index) of filPersons&quot; :key = &quot;p.id&quot; &amp;gt; ---- &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script type=&quot;text/javascript&quot;&amp;gt; Vue.config.productionTip =false new Vue({ el:&#39;#root&#39;, data:{ keyWord:&#39;&#39;, sortType:0 ,//0 原顺序 ，1 降序，2 升序 persons:[ { id:&#39;001&#39;,name:&#39;马冬梅&#39;,age:19,sex:&#39;女&#39;}, { id:&#39;002&#39;,name:&#39;周冬雨&#39;,age:50,sex:&#39;女&#39;}, { id:&#39;003&#39;,name:&#39;周杰伦&#39;,age:11,sex:&#39;男&#39;}, { id:&#39;004&#39;,name:&#39;温兆伦&#39;,age:20,sex:&#39;男&#39;}, ] }, computed:{ filPersons(){ // 先过滤 const arr = this.persons.filter((p)=&amp;gt;{ return p.name.indexOf(this.keyWord) !== -1 }) // 再排序，sort影响原数组顺序的 if (this.sortType){ arr.sort((p1,p2)=&amp;gt;{ return this.sortType === 1 ? p2.age-p1.age :p1.age-p2.age }) } return arr } } }) &amp;lt;/script&amp;gt;&amp;lt;/html&amp;gt;13.数据监测 Vue会监视data中所有层次的数据 如何监测对象中的数据？ 通过setter实现监视，且要在new Vue时就传入要监测的数据。 对象中后追加的属性，Vue默认不做响应式处理 如需要给后添加的属性做响应式，请使用一下API: Vue.set(target,propertyName/index,value) 或Vue.$set(target,propertName/index.value) 如何数组中的数据 通过包裹数组更新元素的方法实现，本质就是做了两件事： 调用原生对应的方法对数组进行更新 重新解析模板，进而更新页面 在Vue中修改数组中的某个元素一定要使用如下方法： 使用这些数组操作的API: push()、pop()、shift()、unshift()、splice()、sort()、reserve() Vue.set() 或 vm.$set() 注意：Vue.set() 和vm.$set() 不能给vm 或 vm的根数据添加属性，只能对data进行操作。 &amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt; &amp;lt;title&amp;gt;数据监测&amp;lt;/title&amp;gt; &amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&quot;root&quot;&amp;gt; &amp;lt;table border=&quot;0px soild&quot; cellspacing=&quot;5px&quot; cellpadding=&quot;30px&quot;&amp;gt; &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;姓名：&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt; &amp;lt;tr v-if=&quot;student.sex&quot;&amp;gt;&amp;lt;td&amp;gt;性别：&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;年龄：&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt;&amp;lt;td &amp;gt; 爱好:&amp;lt;span id=&quot;&quot; v-for=&quot;hobby in student.hobbys&quot;&amp;gt; &amp;amp;nbsp;&amp;lt;span&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt;&amp;lt;td v-for=&quot;friend in student.friends&quot;&amp;gt;朋友：--&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt; &amp;lt;/table&amp;gt; &amp;lt;div&amp;gt;&amp;lt;button type=&quot;button&quot; @click=&quot;student.age++&quot; &amp;gt;年龄+1 &amp;lt;/button&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;&amp;lt;button type=&quot;button&quot; @click=&quot;addSex()&quot; &amp;gt;加入性别 &amp;lt;/button&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;&amp;lt;button type=&quot;button&quot; @click=&quot;addFriend()&quot; &amp;gt;加入朋友 &amp;lt;/button&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;&amp;lt;button type=&quot;button&quot; @click=&quot;updateFirstFriendName()&quot; &amp;gt;修改第一个朋友名字 &amp;lt;/button&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div&amp;gt;&amp;lt;button type=&quot;button&quot; @click=&quot;updateFirstHobby()&quot; &amp;gt;修改第一个爱好是开车 &amp;lt;/button&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script src=&quot;./vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script type=&quot;text/javascript&quot;&amp;gt; Vue.config.productionTip =false new Vue({ el:&quot;#root&quot;, data:{ student:{ name:&#39;Tom&#39;, age:0, sex:&quot;&quot;, hobbys:[&#39;抽烟&#39;,&#39;喝酒&#39;,&#39;烫头&#39;], friends:[ {name:&#39;jerry&#39;,age:30,}, {name:&#39;jack&#39;,age:40,}, ] } }, methods:{ addSex(){ // 这两种方法皆可 // Vue.set(this.student,&#39;sex&#39;,&#39;男&#39;) this.$set(this.student,&#39;sex&#39;,&#39;男&#39;) }, addFriend(){ this.student.friends.unshift({&#39;name&#39;:&#39;Shit&#39;,&quot;age&quot;:100}) }, updateFirstFriendName(){ this.student.friends[0].name = &#39;张三&#39; }, updateFirstHobby(){ // 这两种方法皆可 this.student.hobbys.splice(0,1,&#39;开车&#39;) // this.$set(this.student.hobbys,0,&#39;开车&#39;) } } }) &amp;lt;/script&amp;gt;&amp;lt;/html&amp;gt;14 收集表单​ 收集表单数据：​ 若： input type=&#39;text&#39;/&amp;gt;，则v-model收集的是value值，用户输入的就是value值​ 若： input type=&#39;radio&#39;/&amp;gt;，则v-model收集的是value值，且需要给标签配置value值​ 若： input type=&#39;checkbox&#39;/&amp;gt;： 没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值） 配置input 的value属性： v-model初始值非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值） v-model的初始值是数组，那么收集的就是value组成的数组 备注： v-model的三个修饰符： lazy：失去焦点再收集数据 number：输入字符串转为有效的数字 trim：输入收尾空格过滤 案例：收集用户信息（☆☆☆☆☆）&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt; &amp;lt;title&amp;gt;数据收集&amp;lt;/title&amp;gt; &amp;lt;style type=&quot;text/css&quot;&amp;gt; div { margin-top: 10px; font-size: larger; } &amp;lt;/style&amp;gt; &amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&quot;root&quot;&amp;gt; &amp;lt;form @submit.prevent=&quot;demo&quot;&amp;gt; &amp;lt;div &amp;gt;&amp;lt;label for=&quot;account&quot;&amp;gt;账号&amp;lt;/label&amp;gt; &amp;lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;account&quot; value=&quot;&quot; v-model.trim=&quot;userInfo.account&quot; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div &amp;gt;&amp;lt;label for=&quot;password&quot;&amp;gt;密码&amp;lt;/label&amp;gt; &amp;lt;input type=&quot;password&quot; name=&quot;&quot; id=&quot;password&quot; value=&quot;&quot; v-model=&quot;userInfo.password&quot; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div &amp;gt;&amp;lt;label for=&quot;password&quot;&amp;gt;年龄&amp;lt;/label&amp;gt; &amp;lt;input type=&quot;number&quot; name=&quot;&quot; id=&quot;age&quot; value=&quot;&quot; v-model.number=&quot;userInfo.age&quot; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div &amp;gt;&amp;lt;label&amp;gt;性别&amp;lt;/label&amp;gt; 男&amp;lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot; v-model=&quot;userInfo.sex&quot; /&amp;gt; 女&amp;lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot; v-model=&quot;userInfo.sex&quot; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div id=&quot;&quot;&amp;gt;&amp;lt;label for=&quot;sex&quot;&amp;gt;爱好&amp;lt;/label&amp;gt; 抽烟&amp;lt;input type=&quot;checkbox&quot; name=&quot;&quot; value=&quot;smoke&quot; v-model=&#39;userInfo.hobbys&#39;/&amp;gt; 喝酒&amp;lt;input type=&quot;checkbox&quot; name=&quot;&quot; value=&quot;drink&quot; v-model=&#39;userInfo.hobbys&#39;/&amp;gt; 烫头&amp;lt;input type=&quot;checkbox&quot; name=&quot;&quot; value=&quot;hair&quot; v-model=&#39;userInfo.hobbys&#39;/&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div id=&quot;&quot;&amp;gt; 所属校区 &amp;lt;select v-model=&quot;userInfo.school&quot;&amp;gt; &amp;lt;option value=&quot;&quot;&amp;gt;请选择校区&amp;lt;/option&amp;gt; &amp;lt;option value=&quot;shenzhen&quot;&amp;gt;深圳&amp;lt;/option&amp;gt; &amp;lt;option value=&quot;guangzhou&quot;&amp;gt;广州&amp;lt;/option&amp;gt; &amp;lt;option value=&quot;wuhan&quot;&amp;gt;武汉&amp;lt;/option&amp;gt; &amp;lt;option value=&quot;beijing&quot;&amp;gt;北京&amp;lt;/option&amp;gt; &amp;lt;/select&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div id=&quot;&quot; &amp;gt; 其他信息 &amp;lt;div id=&quot;&quot;&amp;gt; &amp;lt;textarea rows=&quot;&quot; cols=&quot;&quot; v-model.lazy=&quot;userInfo.info&quot;&amp;gt;&amp;lt;/textarea&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div id=&quot;&quot;&amp;gt; &amp;lt;input type=&quot;checkbox&quot; name=&quot;&quot; v-model=&quot;userInfo.agree&quot; /&amp;gt;阅读并接收&amp;lt;a href=&quot;www.baidu.com&quot;&amp;gt;《用户协议》&amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script src=&quot;./vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script type=&quot;text/javascript&quot;&amp;gt; Vue.config.productionTip =false new Vue({ el: &#39;#root&#39;, data: { userInfo: { account: &#39;&#39;, password: &quot;&quot;, age:&#39;&#39;, sex: &quot;&quot;, hobbys: [], school: &quot;&quot;, info: &#39;&#39;, agree: &quot;&quot; } }, methods:{ demo(){ console.log(JSON.stringify(this.userInfo)) } } }) &amp;lt;/script&amp;gt;&amp;lt;/html&amp;gt;参考链接1.v2.x 及更早版本的参考手册2.尚硅谷Vue2.0+Vue3.0全套教程丨vuejs从入门到精通_哔哩哔哩_bilibili" }, { "title": "JS-ES6新增语法", "url": "/posts/%E5%89%8D%E7%AB%AF-JSES6%E6%96%B0%E5%A2%9E%E8%AF%AD%E6%B3%95/", "categories": "前端", "tags": "前端JS", "date": "2021-05-16 00:00:00 +0800", "snippet": "1.ES6相关概念（★★）​ ES 的全称是 ECMAScript , 它是由 ECMA 国际标准化组织,制定的一项脚本语言的标准化规范。每一次标准的诞生都意味着语言的完善，功能的加强。JavaScript语言本身也有一些令人不满意的地方。 变量提升特性增加了程序运行时的不可预测性 语法过于松散，实现相同的功能，不同的人可能会写出不同的代码2.ES6新增语法2.1 let（★★★）​ ES6中新增了用于声明变量的关键字，let声明的变量只在所处于的块级有效if (true) { let a = 10;}console.log(a) // a is not defined注意：let——块级作用域，var——全局作用域。// 利用let声明的变量会绑定在这个块级作用域，不会受外界的影响var tmp = 123;if (true) { let tmp = &#39;abc&#39;; console.log(&quot;内部tmp：&quot;+tmp)} console.log(&quot;外部tmp：&quot;+tmp)//内部tmp：abc//外部tmp：1232.2 const（★★★）​ const用于声明常量，即值（内存地址）不能变化的量。// 块级作用域if (true) { const a = 10;}console.log(a) // a is not defined// 声明时候必须赋值（不赋值报错）const PI; // Uncaught SyntaxError: Missing initializer in const declaration// 常量赋值后不能更改（更改报错）const PI = 3.14;PI = 100; //Uncaught TypeError: Assignment to constant variable.const ary = [100, 200];ary[0] = &#39;a&#39;;ary[1] = &#39;b&#39;;console.log(ary); // [&#39;a&#39;, &#39;b&#39;]; ary = [&#39;a&#39;, &#39;b&#39;]; // Assignment to constant variable.let、const、var 的区别 使用 var 声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象 使用 let 声明的变量，其作用域为该语句所在的代码块内，不存在变量提升 使用 const 声明的是常量，在后面出现的代码中不能再修改该常量的值2.3 解构赋值（★★★）​ ES6中允许从数组中提取值，按照对应位置，对变量赋值，对象也可以实现解构 (这个和python一样)。// 数组解构 let [a, b, c] = [1, 2, 3]; console.log(a)//1 console.log(b)//2 console.log(c)//3// 如果解构不成功，变量的值为undefined// 对象解构 let person = { name: &#39;zhangsan&#39;, age: 20 }; let { name, age } = person;console.log(name); // &#39;zhangsan&#39; console.log(age); // 20let {name: myName, age: myAge} = person; // myName myAge 属于别名console.log(myName); // &#39;zhangsan&#39; console.log(myAge); // 20 解构赋值就是把数据结构分解，然后给变量进行赋值 如果结构不成功，变量跟数值个数不匹配的时候，变量的值为undefined 数组解构用中括号包裹，多个变量用逗号隔开；对象解构用花括号包裹，多个变量用逗号隔开 利用解构赋值能够让我们方便的去取对象中的属性跟方法2.4 箭头函数（★★★）​ ES6中新增的定义函数的方式。() =&amp;gt; {} //()：代表是函数； =&amp;gt;：必须要的符号，指向哪一个代码块；{}：函数体const fn = () =&amp;gt; {}//代表把一个函数赋值给fnfunction sum(num1, num2) { return num1 + num2; }// es6写法// 函数体中只有一句代码，且代码的执行结果就是返回值，可以省略大括号const sum = (num1, num2) =&amp;gt; num1 + num2; function fn (v) { return v;} // es6写法// 如果形参只有一个，可以省略小括号const fn = v =&amp;gt; v;const obj = { name: &#39;张三&#39;} function fn () { console.log(this);// this 指向 是obj对象 return () =&amp;gt; { console.log(this); //this 指向 的是箭头函数定义的位置，那么这个箭头函数定义在fn里面，而这个fn指向是的obj对象，所以这个this也指向是obj对象 } } const resFn = fn.call(obj); resFn();// 上面两个this均指向obj 箭头函数中不绑定this，箭头函数中的this指向是它所定义的位置。箭头函数的this指向箭头函数被创建时，外部作用域的this指向的对象。 箭头函数的优点在于解决了this执行环境所造成的一些问题。比如：解决了匿名函数this指向的问题（匿名函数的执行环境具有全局性），包括setTimeout和setInterval中使用this所造成的问题 对象没有作用域var age = 100;var obj = { age: 20, say: () =&amp;gt; { alert(this.age) }}obj.say(); //箭头函数this指向的是被声明的作用域里面，而对象没有作用域的，所以箭头函数虽然在对象中被定义，但是this指向的是全局作用域var name = &#39;xx&#39;;let fun1 = function () { let name = &#39;lmm&#39;; console.log(this); // Window {window: Window, self: Window, document: document, name: &quot;xx&quot;, location: Location, …} let normalGetName = function () { console.log(&#39;name: &#39;, name); // name: lmm console.log(&#39;this.name: &#39;, this.name); // this.name: xx console.log(this); // Window {window: Window, self: Window, document: document, name: &quot;xx&quot;, location: Location, …} } let arrowGetName = () =&amp;gt; { console.log(&#39;name: &#39;, name); // name: lmm console.log(&#39;this.name: &#39;, this.name); // this.name: xx console.log(this); // Window {window: Window, self: Window, document: document, name: &quot;xx&quot;, location: Location, …} } normalGetName(); arrowGetName();};fun1();​ JS中查找变量是按照链式作用域来查找，即先找自己的作用域是否有该变量，如无继续向父作用域找，直到全局作用域window，如果都没有则报错抛出异常。箭头函数的作用域作用传统的非箭头函数现在，箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者Person2.5 剩余参数（★★）​ 剩余参数语法允许我们将一个不定数量的参数表示为一个数组。（同python中的*args,**kwargs)function sum (first, ...args) { console.log(first); // 10 console.log(args); // [20, 30] }sum(10, 20, 30)剩余参数解构let students = [&#39;wangwu&#39;, &#39;zhangsan&#39;, &#39;lisi&#39;];let [s1, ...s2] = students; console.log(s1); // &#39;wangwu&#39; console.log(s2); // [&#39;zhangsan&#39;, &#39;lisi&#39;]3.ES6 的内置对象扩展3.1 Array 扩展（★★）扩展运算符可以将数组或者对象转为用逗号分隔的参数序列let ary = [1, 2, 3];[...ary] // [1, 2, 3]console.log([...ary]); // 1 2 3,相当于下面的代码console.log([1,2,3]);数组合并// 方法一 let ary1 = [1, 2, 3]; let ary2 = [3, 4, 5]; let ary3 = [...ary1, ...ary2]; // 方法二 ary1.push(...ary2);数组遍历let oDivs = document.getElementsByTagName(&#39;div&#39;); oDivs = [...oDivs];3.1.1 构造函数方法：Array.from()将伪数组或可遍历对象转换为真正的数组//定义一个集合let arrayLike = { &#39;0&#39;: &#39;a&#39;, &#39;1&#39;: &#39;b&#39;, &#39;2&#39;: &#39;c&#39;, length: 3}; //转成数组let arr2 = Array.from(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]方法还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组let arrayLike = { &quot;0&quot;: 1, &quot;1&quot;: 2, &quot;length&quot;: 2}let newAry = Array.from(arrayLike, item =&amp;gt; item *2)//[2,4]注意：如果是对象，那么属性需要写对应的索引3.1.2 实例方法：find()用于找出第一个符合条件的数组成员，如果没有找到返回undefinedlet ary = [{ id: 1, name: &#39;张三&#39;}, { id: 2, name: &#39;李四&#39;}]; let target = ary.find((item, index) =&amp;gt; item.id == 2);//找数组里面符合条件的值，当数组中元素id等于2的查找出来，注意，只会匹配第一个3.1.3 实例方法：findIndex()用于找出第一个符合条件的数组成员的位置，如果没有找到返回-1let ary = [1, 5, 10, 15];let index = ary.findIndex((value, index) =&amp;gt; value &amp;gt; 9); console.log(index); // 23.1.4 实例方法：includes()判断某个数组是否包含给定的值，返回布尔值。[1, 2, 3].includes(2) // true [1, 2, 3].includes(4) // false3.1.5 排序方法sort()方法升序：a-b；降序：b-avar arr = [123,203,23,13,34,65,65,45,89,13,1];function func(a,b){ return a-b;}console.log(arr.sort(func)); //(11) [1, 13, 13, 23, 34, 45, 65, 65, 89, 123, 203]选择排序基本思想： 首先在未排序数组中找到最小(大)元素，存放在数组的起始位置。 再从剩余数组元素中继续寻找最小(大)元素，返回放在已排序数组的末尾 重复第二步，直到所有元素都排序完成动画演示：var arr = [123,203,23,13,34,65,65,45,89,13,1];for(var i=0;i&amp;lt;arr.length;i++){ for(var j=i+1;j&amp;lt;arr.length;j++){ //如果第一个比第二个大，就交换他们两个位置 if(arr[i]&amp;gt;arr[j]){ var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } }}console.log(arr); //(11) [1, 13, 13, 23, 34, 45, 65, 65, 89, 123, 203]冒泡排序基本思想： 一次比较两个相邻的数，如果不符合规则互换位置，一次比较就能够将最大或最小的值放在数组最后一位 继续对除【最后一位】之外的所有元素重复上述过程动画演示：var arr = [123,203,23,13,34,65,65,45,89,13,1];for(var i=0; i&amp;lt;arr.length-1; i++){ //每一轮比较要比多少次 for(var j=0; j&amp;lt;arr.length-1-i; j++){ //如果第一个比第二个大，就交换他们两个位置 if(arr[j]&amp;gt;arr[j+1]){ var temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } } }console.log(arr); 插入排序基本思想： 将数组第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。var arr = [123,203,23,13,34,65,65,45,89,13,1];var preIndex, current;for(var i=1;i&amp;lt;arr.length;i++){ preIndex = i-1; current = arr[i]; while(preIndex&amp;gt;=0 &amp;amp;&amp;amp; arr[preIndex]&amp;gt;current) { arr[preIndex+1] = arr[preIndex]; preIndex--; } arr[preIndex+1] = current;}console.log(arr); 快速排序(依托递归函数)基本思想：在已知数据集合中随便去一个基准(pivot) 将其余数据以基准为中心，大于分放右边，小于的放左边 将左右两个子集重复以上两个步骤动画演示：var arr = [123,203,23,13,34,65,65,45,89,13,1]; //创建快速排序函数function quickSort(tempArr){ //递归终止条件 if(tempArr.length&amp;lt;=1){ return tempArr; }; //取基准 var pivotIndex = Math.floor(tempArr.length/2); var pivot = tempArr.splice(pivotIndex,1); //分左右 var leftArr = []; var rightArr = []; for(var i=0;i&amp;lt;tempArr.length;i++){ if(tempArr[i]&amp;gt;pivot){ rightArr.push(tempArr[i]); }else{ leftArr.push(tempArr[i]); }; }; return quickSort(leftArr).concat(pivot,quickSort(rightArr));};console.log(quickSort(arr)); //(11) 3.2 String 扩展3.2.1 模板字符串（★★★）// ES6新增的创建字符串的方式，使用反引号定义// 类似于mysql的写法let name = `zhangsan`;// 模板字符串中可以解析变量let name = &#39;张三&#39;; let sayHello = `hello,my name is ${name}`; // hello, my name is zhangsan// 模板字符串中可以换行 let result = { name: &#39;zhangsan&#39;, age: 20, sex: &#39;男&#39; } let html = ` &amp;lt;div&amp;gt; &amp;lt;span&amp;gt;${result.name}&amp;lt;/span&amp;gt; &amp;lt;span&amp;gt;${result.age}&amp;lt;/span&amp;gt; &amp;lt;span&amp;gt;${result.sex}&amp;lt;/span&amp;gt; &amp;lt;/div&amp;gt; `;// 模板字符串中可以调用函数const sayHello = function () { return &#39;哈哈哈哈 追不到我吧 我就是这么强大&#39;; }; let greet = `${sayHello()} 哈哈哈哈`; console.log(greet); // 哈哈哈哈 追不到我吧 我就是这么强大 哈哈哈哈3.2.2 startsWith() 和 endsWith() startsWith()：表示参数字符串是否在原字符串的头部，返回布尔值 endsWith()：表示参数字符串是否在原字符串的尾部，返回布尔值// 类似python字符串处理中的startsWith和endsWithlet str = &#39;Hello world!&#39;;str.startsWith(&#39;Hello&#39;) // true str.endsWith(&#39;!&#39;) // true3.2.3 repeat()repeat方法表示将原字符串重复n次，返回一个新字符串// 类似于python中的乘号 *&#39;x&#39;.repeat(3) // &quot;xxx&quot; &#39;hello&#39;.repeat(2) // &quot;hellohello&quot;3.3 Set 数据结构（★★）​ ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。（类似于python中的set）// Set本身是一个构造函数，用来生成 Set 数据结构const s = new Set();// Set函数可以接受一个数组作为参数，用来初始化。const set = new Set([1, 2, 3, 4, 4]);//{1, 2, 3, 4}实例方法 add(value)：添加某个值，返回 Set 结构本身 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功 has(value)：返回一个布尔值，表示该值是否为 Set 的成员 clear()：清除所有成员，没有返回值 const s = new Set(); s.add(1).add(2).add(3); // 向 set 结构中添加值 s.delete(2) // 删除 set 结构中的2值 s.has(1) // 表示 set 结构中是否有1这个值 返回布尔值 s.clear() // 清除 set 结构中的所有值 //注意：删除的是元素的值，不是代表的索引// Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。s.forEach(value =&amp;gt; console.log(value))参考链接1.JS 作用域，闭包，箭头函数，普通函数中this指向问题2.js中数组排序的五种方式" }, { "title": "JS正则表达式", "url": "/posts/%E5%89%8D%E7%AB%AF-JS%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/", "categories": "前端", "tags": "前端JS", "date": "2021-05-15 00:00:00 +0800", "snippet": "1.正则表达式概述1.1 什么是正则表达式​ 正则表达式（ Regular Expression ）是用于匹配字符串中字符组合的模式。在JavaScript中，正则表达式也是对象。​ 正则表通常被用来检索、替换那些符合某个模式（规则）的文本。例如： 验证表单：用户名表单只能输入英文字母、数字或者下划线， 昵称输入框中可以输入中文(匹配)。 正则表达式还常用于过滤掉页面内容中的一些敏感词(替换) 从字符串中获取我们想要的特定部分(提取)等其他语言也会使用正则表达式，本阶段我们主要是利用JavaScript 正则表达式完成表单验证。1.2 特点 灵活性、逻辑性和功能性非常的强。 可以迅速地用极简单的方式达到字符串的复杂控制。 对于刚接触的人来说，比较晦涩难懂。比如：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ 实际开发,一般都是直接复制写好的正则表达式. 但是要求会使用正则表达式并且根据实际情况修改正则表达式. 比如用户名: ` /^[a-z0-9_-]{3,16}$/`2.正则表达式在js中的使用2.1 正则表达式的创建​ 在 JavaScript 中，可以通过两种方式创建一个正则表达式。方式一：通过调用RegExp对象的构造函数创建var regexp = new RegExp(/123/);console.log(regexp);方式二：利用字面量创建 正则表达式 var rg = /123/;2.2 测试正则表达式​ test() 正则对象方法，用于检测字符串是否符合该规则，该对象会返回 true 或 false，其参数是测试字符串。var rg = /123/;console.log(rg.test(123));//匹配字符中是否出现123 出现结果为trueconsole.log(rg.test(&#39;abc&#39;));//匹配字符中是否出现123 未出现结果为false2.3 模式修饰符 模式符 说明 g 用于在目标字符串中实现全局匹配 i 忽略大小写 m 实现多行匹配 u 以Unicode编码执行正则表达式 y 粘性匹配，仅仅匹配目标字符串中此正则表达式的lastIndex属性指示的索引 2.4 边界符​ 正则表达式中的边界符（位置符）用来提示字符所处的位置，主要有两个字符 边界符 说明 ^ 表示匹配行首的文本（以谁开始） $ 表示匹配行尾的文本（以谁结束） ​ 如果 ^和 $ 在一起，表示必须是精确匹配。2.5 量词符​ 量词符用来设定某个模式出现的次数。 量词 说明 * 重复0次或更多次 + 重复1次或更多次 ? 重复0次或1次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 2.6 括号 括号 说明 大括号 量词符. 里面表示重复次数 中括号 字符集合匹配方括号中的任意字符 小括号 表示优先级 2.7 案例：用户表单验证案例:验证座机号码功能需求: 如果用户名输入合法, 则后面提示信息为: 用户名合法,并且颜色为绿色 如果用户名输入不合法, 则后面提示信息为: 用户名不符合规范, 并且颜色为红色分析: 用户名只能为英文字母、数字、下划线或者短横线组成，并且用户名长度为6~16位 首先准备好这种正则表达式模式/$[a-zA-Z0-9-_]{6,16}^/ 当表单失去焦点就开始验证 如果符合正则规范, 则让后面的span标签添加 right类 如果不符合正则规范, 则让后面的span标签添加 wrong类&amp;lt;input type=&quot;text&quot; class=&quot;uname&quot;&amp;gt; &amp;lt;span&amp;gt;请输入用户名&amp;lt;/span&amp;gt;&amp;lt;script&amp;gt; // 量词是设定某个模式出现的次数 var reg = /^[a-zA-Z0-9_-]{6,16}$/; // 这个模式用户只能输入英文字母 数字 下划线 中划线 var uname = document.querySelector(&#39;.uname&#39;); var span = document.querySelector(&#39;span&#39;); uname.onblur = function() { if (reg.test(this.value)) { console.log(&#39;正确的&#39;); span.className = &#39;right&#39;; span.innerHTML = &#39;用户名格式输入正确&#39;; } else { console.log(&#39;错误的&#39;); span.className = &#39;wrong&#39;; span.innerHTML = &#39;用户名格式输入不正确&#39;; } }&amp;lt;/script&amp;gt;2.8 案例：正则替换​ replace() 方法可以实现替换字符串操作，用来替换的参数可以是一个字符串或是一个正则表达式。var str = &#39;andy和red&#39;;var newStr = str.replace(&#39;andy&#39;, &#39;baby&#39;);console.log(newStr) //baby和red//等同于 此处的andy可以写在正则表达式内var newStr2 = str.replace(/andy/, &#39;baby&#39;);console.log(newStr2) //baby和red//替换一个var str = &#39;abcabc&#39;var nStr = str.replace(/a/,&#39;哈哈&#39;)console.log(nStr) //哈哈bcabc//全部替换gvar nStr = str.replace(/a/g,&#39;哈哈&#39;)console.log(nStr) //哈哈bc哈哈bc//忽略大小写ivar str = &#39;aAbcAba&#39;;var newStr = str.replace(/a/gi,&#39;哈哈&#39;)//&quot;哈哈哈哈bc哈哈b哈哈&quot;2.9 案例：过滤敏感词汇&amp;lt;textarea name=&quot;&quot; id=&quot;message&quot;&amp;gt;&amp;lt;/textarea&amp;gt; &amp;lt;button&amp;gt;提交&amp;lt;/button&amp;gt;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;script&amp;gt; var text = document.querySelector(&#39;textarea&#39;); var btn = document.querySelector(&#39;button&#39;); var div = document.querySelector(&#39;div&#39;); // /g 为global，全局替换 btn.onclick = function() { div.innerHTML = text.value.replace(/激情|gay/g, &#39;**&#39;); }&amp;lt;/script&amp;gt;2.10 案例：表单验证案例//手机号验证:/^1[3|4|5|7|8][0-9]{9}$/;//验证通过与不通过更换元素的类名与元素中的内容var res = /^1[3|4|5|7|8][0-9]{9}$/;if (reg.test(this.value)) { // console.log(&#39;正确的&#39;); this.nextElementSibling.className = &#39;success&#39;; this.nextElementSibling.innerHTML = &#39;&amp;lt;i class=&quot;success_icon&quot;&amp;gt;&amp;lt;/i&amp;gt; 恭喜您输入正确&#39;;} else { // console.log(&#39;不正确&#39;); this.nextElementSibling.className = &#39;error&#39;; this.nextElementSibling.innerHTML = &#39;&amp;lt;i class=&quot;error_icon&quot;&amp;gt;&amp;lt;/i&amp;gt;格式不正确,请从新输入 &#39;;}//QQ号验证: /^[1-9]\\d{4,}$/; //昵称验证:/^[\\u4e00-\\u9fa5]{2,8}$///验证通过与不通过更换元素的类名与元素中的内容 ,将上一步的匹配代码进行封装,多次调用即可var res = /^[1-9]\\d{4,}$/; function regexp(ele, reg) { ele.onblur = function() { if (reg.test(this.value)) { // console.log(&#39;正确的&#39;); this.nextElementSibling.className = &#39;success&#39;; this.nextElementSibling.innerHTML = &#39;&amp;lt;i class=&quot;success_icon&quot;&amp;gt;&amp;lt;/i&amp;gt; 恭喜您输入正确&#39;; } else { // console.log(&#39;不正确&#39;); this.nextElementSibling.className = &#39;error&#39;; this.nextElementSibling.innerHTML = &#39;&amp;lt;i class=&quot;error_icon&quot;&amp;gt;&amp;lt;/i&amp;gt; 格式不正确,请从新输入 &#39;; } } };//密码验证:/^[a-zA-Z0-9_-]{6,16}$///再次输入密码只需匹配与上次输入的密码值 是否一致" }, { "title": "JS函数", "url": "/posts/%E5%89%8D%E7%AB%AF-JS%E5%87%BD%E6%95%B0/", "categories": "前端", "tags": "前端JS", "date": "2021-05-14 00:00:00 +0800", "snippet": "1.函数的定义和调用1.1 函数的定义方式 方式1 函数声明方式 function 关键字 (命名函数) // 最常用function fn(){} 方式2 函数表达式(匿名函数) var fn = function(){} 方式3 new Function() var f = new Function(&#39;a&#39;, &#39;b&#39;, &#39;console.log(a + b)&#39;);f(1, 2); var fn = new Function(&#39;参数1&#39;,&#39;参数2&#39;..., &#39;函数体&#39;)注意/*Function 里面参数都必须是字符串格式第三种方式执行效率低，也不方便书写，因此较少使用所有函数都是 Function 的实例(对象) 函数也属于对象*/ 1.2 函数的调用/* 1. 普通函数 */function fn() { console.log(&#39;人生的巅峰&#39;);} fn(); /* 2. 对象的方法 */var o = { sayHi: function() { console.log(&#39;人生的巅峰&#39;); }}o.sayHi();/* 3. 构造函数*/function Star() {};new Star();/* 4. 绑定事件函数*/ btn.onclick = function() {}; // 点击了按钮就可以调用这个函数/* 5. 定时器函数*/setInterval(function() {}, 1000); 这个函数是定时器自动1秒钟调用一次/* 6. 立即执行函数(自调用函数)*/(function() { console.log(&#39;人生的巅峰&#39;);})();2.this2.1 函数内部的this指向这些 this 的指向，是当我们调用函数的时候确定的。调用方式的不同决定了this 的指向不同一般指向我们的调用者.2.2 改变函数内部 this 指向2.2.1 call方法​ call()方法调用一个对象。简单理解为调用函数的方式，但是它可以改变函数的 this 指向应用场景: 经常做继承.var o = { name: &#39;andy&#39;}function fn(a, b) { console.log(this); console.log(a+b)};fn(1,2) // 此时的this指向的是window 运行结果为3fn.call(o,1,2) // 此时的this指向的是对象o,参数使用逗号隔开,运行结果为3以上代码运行结果为:2.2.2 apply方法​ apply() 方法调用一个函数。简单理解为调用函数的方式，但是它可以改变函数的 this 指向。应用场景: 经常跟数组有关系var o = { name: &#39;andy&#39;}function fn(a, b) { console.log(this); console.log(a+b)};fn() // 此时的this指向的是window 运行结果为3fn.apply(o,[1,2]) //此时的this指向的是对象o,参数使用数组传递 运行结果为32.2.3 bind方法​ bind() 方法不会调用函数,但是能改变函数内部this 指向，返回的是原函数改变this之后产生的新函数。​ 如果只是想改变 this 指向，并且不想调用这个函数的时候，可以使用bind。应用场景:不调用函数,但是还想改变this指向var o = { name: &#39;andy&#39;};function fn(a, b) { console.log(this); console.log(a + b);};var f = fn.bind(o, 1, 2); //此处的f是bind返回的新函数f(); //调用新函数 this指向的是对象o 参数使用逗号隔开2.2.4 call、apply、bind三者的异同 共同点 : 都可以改变this指向 不同点: call 和 apply 会调用函数, 并且改变函数内部this指向 call 和 apply传递的参数不一样,call传递参数使用逗号隔开,apply使用数组传递 bind 不会调用函数, 可以改变函数内部this指向 应用场景 call 经常做继承 apply 经常跟数组有关系. 比如：借助于数学对象实现数组最大值最小值 bind 不调用函数，但是还想改变this指向，比如改变定时器内部的this指向 3.高阶函数​ 高阶函数是对其他函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出（类似于python中的装饰器）。​ 此时fn 就是一个高阶函数​ 函数也是一种数据类型，同样可以作为参数，传递给另外一个参数使用。最典型的就是作为回调函数，同理函数也可以作为返回值传递回来。4.闭包4.1 变量的作用域复习变量根据作用域的不同分为两种：全局变量和局部变量。 函数内部可以使用全局变量。 函数外部不可以使用局部变量。 当函数执行完毕，本作用域内的局部变量会销毁。4.2 什么是闭包​ 闭包（closure）指有权访问另一个函数作用域中变量的函数。简单理解就是 ，一个作用域可以访问另外一个函数内部的局部变量。4.3 闭包的作用​ 作用：延伸变量的作用范围。function fn() { var num = 10; function fun() { console.log(num); } return fun;}var f = fn();f();4.4 闭包的案例 利用闭包的方式得到当前li 的索引号for (var i = 0; i &amp;lt; lis.length; i++) { // 利用for循环创建了4个立即执行函数 // 立即执行函数也成为小闭包因为立即执行函数里面的任何一个函数都可以使用它的i这变量 (function(i) { lis[i].onclick = function() { console.log(i); } })(i);} 闭包应用：3秒钟之后,打印所有li元素的内容for (var i = 0; i &amp;lt; lis.length; i++) { (function(i) { setTimeout(function() { console.log(lis[i].innerHTML); }, 3000) })(i);} 闭包应用：计算打车价格/* 需求分析 打车起步价13(3公里内), 之后每多一公里增加 5块钱. 用户输入公里数就可以计算打车价格 如果有拥堵情况,总价格多收取10块钱拥堵费*/var car = (function() { var start = 13; // 起步价 局部变量 var total = 0; // 总价 局部变量 return { // 正常的总价 price: function(n) { if (n &amp;lt;= 3) { total = start; } else { total = start + (n - 3) * 5 } return total; }, // 拥堵之后的费用 yd: function(flag) { return flag ? total + 10 : total; } }})();console.log(car.price(5)); // 23console.log(car.yd(true)); // 334.5 案例var name = &quot;The Window&quot;;var object = { name: &quot;My Object&quot;, getNameFunc: function() { return function() { console.log(this) // 匿名函数的环境具有全局性,指向Window return this.name; }; }};console.log(object.getNameFunc()())// 返回值：The Window// -----------------------------------------------------------------------------------var name = &quot;The Window&quot;;　　var object = {　　　　 name: &quot;My Object&quot;, getNameFunc: function() { var that = this; // 具名函数，this指向其创建对象，即object对象 console.log(this) return function() { console.log(this) // 匿名函数的环境具有全局性,指向Window return that.name; }; }};console.log(object.getNameFunc()())//返回值：My Object5.递归5.1 什么是递归​ 递归：如果一个函数在内部可以调用其本身，那么这个函数就是递归函数。简单理解:函数内部自己调用自己。​ 注意：递归函数的作用和循环效果一样，由于递归很容易发生“栈溢出”错误（stack overflow），所以必须要加退出条件return。5.2 利用递归求1~n的阶乘//利用递归函数求1~n的阶乘 1 * 2 * 3 * 4 * ..nfunction fn(n) { if (n == 1) { //结束条件 return 1; } return n * fn(n - 1);}console.log(fn(3));5.3 利用递归求斐波那契数列// 利用递归函数求斐波那契数列(兔子序列) 1、1、2、3、5、8、13、21...// 用户输入一个数字 n 就可以求出 这个数字对应的兔子序列值// 我们只需要知道用户输入的n 的前面两项(n-1 n-2)就可以计算出n 对应的序列值function fb(n) { if (n === 1 || n === 2) { return 1; } return fb(n - 1) + fb(n - 2);}console.log(fb(3));5.4 利用递归遍历数据// 我们想要做输入id号,就可以返回的数据对象var data = [{ id: 1, name: &#39;家电&#39;, goods: [{ id: 11, gname: &#39;冰箱&#39;, goods: [{ id: 111, gname: &#39;海尔&#39; }, { id: 112, gname: &#39;美的&#39; }, ] }, { id: 12, gname: &#39;洗衣机&#39; }]}, { id: 2, name: &#39;服饰&#39;}];//1.利用 forEach 去遍历里面的每一个对象function getID(json, id) { var o = {}; json.forEach(function(item) { // console.log(item); // 2个数组元素 if (item.id == id) { // console.log(item); o = item; return o; // 2. 我们想要得里层的数据 11 12 可以利用递归函数 // 里面应该有goods这个数组并且数组的长度不为 0 } else if (item.goods &amp;amp;&amp;amp; item.goods.length &amp;gt; 0) { o = getID(item.goods, id); } }); return o;}" }, { "title": "JS构造函数", "url": "/posts/%E5%89%8D%E7%AB%AF-JS%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/", "categories": "前端", "tags": "前端JS", "date": "2021-05-13 00:00:00 +0800", "snippet": "1.构造函数和原型1.1 对象的三种创建方式 字面量方式 var obj = {}; new关键字 var obj = new Object(); 构造函数方式 function Person(name,age){ this.name = name; this.age = age;}var obj = new Person(&#39;zs&#39;,12); 1.2 静态成员和实例成员1.2.1 实例成员​ 实例成员就是构造函数内部通过this添加的成员 ，如下列代码中uname ,age, sing 就是实例成员。*实例成员只能通过实例化的对象来访问 function Star(uname, age) { this.uname = uname; this.age = age; this.sing = function() { console.log(&#39;我会唱歌&#39;); }}var ldh = new Star(&#39;刘德华&#39;, 18);console.log(ldh.uname);//实例成员只能通过实例化的对象来访问1.2.2 静态成员​ 静态成员 在构造函数本身上添加的成员 ， 如下列代码中 sex 就是静态成员，静态成员只能通过构造函数来访问 function Star(uname, age) { this.uname = uname; this.age = age; this.sing = function() { console.log(&#39;我会唱歌&#39;); }}Star.sex = &#39;男&#39;;var ldh = new Star(&#39;刘德华&#39;, 18);console.log(Star.sex); //静态成员只能通过构造函数来访问1.3 构造函数的问题​ 构造函数方法很好用，但是存在浪费内存的问题。1.4 构造函数原型prototype​ 构造函数通过原型分配的函数是所有对象所共享的。​ JavaScript 规定，每一个构造函数都有一个prototype 属性，指向另一个对象。注意这个prototype本身也是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。​ 我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。function Star(uname, age) { this.uname = uname; this.age = age;}Star.prototype.sing = function() { console.log(&#39;我会唱歌&#39;);}var ldh = new Star(&#39;刘德华&#39;, 18);var zxy = new Star(&#39;张学友&#39;, 19);ldh.sing();//我会唱歌zxy.sing();//我会唱歌1.5 对象原型​ 对象都会有一个属性 __proto__ 指向构造函数的原型对象prototype 。​ __proto__对象原型和原型对象 prototype 是等价的。__proto__对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线。​ 但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype。1.6 constructor构造函数​ JavaScript语言使用构造函数（constructor）作为对象的模版。所谓“构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。​ constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。​ 对象原型（ __proto__）和构造函数原型对象（prototype）里面都有一个属性 — constructor 属性​ 一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。​ 如果我们修改了原来的原型对象，给原型对象赋值的是一个对象，则必须手动的利用constructor指回原来的构造函数如: function Star(uname, age) { this.uname = uname; this.age = age; } // 很多情况下,我们需要手动的利用constructor 这个属性指回 原来的构造函数 Star.prototype = { // 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数 // 手动设置指回原来的构造函数 constructor: Star, sing: function() { console.log(&#39;我会唱歌&#39;); }, movie: function() { console.log(&#39;我会演电影&#39;); }}var zxy = new Star(&#39;张学友&#39;, 19);console.log(zxy)以上代码运行结果，设置constructor属性如图:如果未设置constructor属性,如图:1.7 原型链​ 每一个实例对象都有__proto__属性，指向的构造函数的原型对象。构造函数的原型对象也是一个对象，所以也有__proto__属性，这样一层一层往上找就形成了原型链。​ 任何对象都有原型对象，也就是prototype属性。​ 任何对象都有__proto__属性，这样一层一层往上找,就形成了一条链，我们称此为原型链。1. 当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。2. 如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象）。3. 如果还没有,就查找原型对象的原型（Object的原型对象）。 依此类推一直找到 Object 为止（null）。__proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。1.8 构造函数实例和原型对象三角关系 构造函数的prototype属性指向了构造函数原型对象 实例对象的__proto__属性指向了构造函数的原型对象（实例对象是由构造函数创建的） 构造函数原型对象的constructor属性指向了构造函数，实例对象的原型的constructor属性也指向了构造函数1.9 原型对象中this指向​ 构造函数中的this和原型对象的this，都指向我们new出来的实例对象function Star(uname, age) { this.uname = uname; this.age = age;}var that;Star.prototype.sing = function() { console.log(&#39;我会唱歌&#39;); that = this;}var ldh = new Star(&#39;刘德华&#39;, 18);// 1. 在构造函数中,里面this指向的是对象实例 ldhconsole.log(that === ldh);//true// 2.原型对象函数里面的this 指向的是 实例对象 ldh1.10通过原型为数组扩展内置方法 Array.prototype.sum = function() { var sum = 0; for (var i = 0; i &amp;lt; this.length; i++) { sum += this[i]; } return sum; }; // 此时数组对象中已经存在sum()方法了 ， 可以使用 数组.sum() 进行数据的求和2.构造函数继承JS 常见的 6 种继承方式2.1 第一种：原型链继承​ 原型链继承是比较常见的继承方式之一，其中涉及的构造函数、原型和实例，三者之间存在着一定的关系，即每一个构造函数都有一个原型对象，原型对象又包含一个指向构造函数的指针，而实例则包含一个原型对象的指针。function Parent1() { this.name = &#39;parent1&#39;; this.play = [1, 2, 3] }function Child1() { this.type = &#39;child2&#39;;}Child1.prototype = new Parent1();console.log(new Child1());​ 上面的代码看似没有问题，虽然父类的方法和属性都能够访问，但其实有一个潜在的问题，我再举个例子来说明这个问题。let s1 = new Child1();let s2 = new Child2();s1.play.push(4);console.log(s1.play, s2.play);​ 这段代码在控制台执行之后，可以看到结果如下：​ 明明我只改变了 s1 的 play 属性，为什么 s2 也跟着变了呢？​ 原因很简单，因为两个实例使用的是同一个原型对象。它们的内存空间是共享的，当一个发生变化的时候，另外一个也随之进行了变化，这就是使用原型链继承方式的一个缺点。那么要解决这个问题的话，我们就得再看看其他的继承方式，下面我们看看能解决原型属性共享问题的第二种方法。2.2 第二种 ：call() call()可以调用函数 call()可以修改this的指向,使用call()的时候 参数一是修改后的this指向，参数2,参数3..使用逗号隔开连接 function fn(x, y) { console.log(this); console.log(x + y);} var o = { name: &#39;andy&#39; }; fn.call(o, 1, 2);//调用了函数此时的this指向了对象o,子构造函数继承父构造函数中的属性 先定义一个父构造函数 再定义一个子构造函数 子构造函数继承父构造函数的属性(使用call方法) // 1. 父构造函数 function Father(uname, age) { // this 指向父构造函数的对象实例 this.uname = uname; this.age = age; } // 2 .子构造函数 function Son(uname, age, score) { // this 指向子构造函数的对象实例 // 3.使用call方式实现子继承父的属性 Father.call(this, uname, age); this.score = score;}var son = new Son(&#39;刘德华&#39;, 18, 100);console.log(son);2.3 借用原型对象继承方法 先定义一个父构造函数 再定义一个子构造函数 子构造函数继承父构造函数的属性(使用call方法)// 1. 父构造函数function Father(uname, age) { // this 指向父构造函数的对象实例 this.uname = uname; this.age = age;}Father.prototype.money = function() { console.log(100000); }; // 2 .子构造函数 function Son(uname, age, score) { // this 指向子构造函数的对象实例 Father.call(this, uname, age); this.score = score; }// Son.prototype = Father.prototype; 这样直接赋值会有问题,如果修改了子原型对象,父原型对象也会跟着一起变化Son.prototype = new Father();// 如果利用对象的形式修改了原型对象,别忘了利用constructor 指回原来的构造函数Son.prototype.constructor = Son;// 这个是子构造函数专门的方法Son.prototype.exam = function() { console.log(&#39;孩子要考试&#39;);}var son = new Son(&#39;刘德华&#39;, 18, 100);console.log(son);如上代码结果如图:2.4 ES6 的 extends 关键字实现逻辑​ 我们可以利用 ES6 里的 extends 的语法糖，使用关键词很容易直接实现 JavaScript 的继承，但是如果想深入了解 extends 语法糖是怎么实现的，就得深入研究 extends 的底层逻辑。class Person { constructor(name) { this.name = name } // 原型方法 // 即 Person.prototype.getName = function() { } // 下面可以简写为 getName() {...} getName = function () { console.log(&#39;Person:&#39;, this.name) }} class Gamer extends Person { constructor(name, age) { // 子类中存在构造函数，则需要在使用“this”之前首先调用 super()。 super(name) this.age = age }} const asuna = new Gamer(&#39;Asuna&#39;, 20)asuna.getName() // 成功访问到父类的方法3.ES5新增方法3.1 forEach遍历数组 arr.forEach(function(value, index, array) { //参数一是:数组元素 //参数二是:数组元素的索引 //参数三是:当前的数组 }) //相当于数组遍历的 for循环 没有返回值3.2 filter过滤数组 var arr = [12, 66, 4, 88, 3, 7]; var newArr = arr.filter(function(value, index,array) { //参数一是:数组元素 //参数二是:数组元素的索引 //参数三是:当前的数组 return value &amp;gt;= 20; }); console.log(newArr);//[66,88] //返回值是一个新数组3.3 some// some 查找数组中是否有满足条件的元素 var arr = [10, 30, 4]; var flag = arr.some(function(value,index,array) { //参数一是:数组元素 //参数二是:数组元素的索引 //参数三是:当前的数组 return value &amp;lt; 3; });console.log(flag);//false返回值是布尔值,只要查找到满足条件的一个元素就立马终止循环3.4 筛选商品案例 定义数组对象数据 var data = [{ id: 1, pname: &#39;小米&#39;, price: 3999 }, { id: 2, pname: &#39;oppo&#39;, price: 999 }, { id: 3, pname: &#39;荣耀&#39;, price: 1299 }, { id: 4, pname: &#39;华为&#39;, price: 1999 }, ]; 使用forEach遍历数据并渲染到页面中 data.forEach(function(value) { var tr = document.createElement(&#39;tr&#39;); tr.innerHTML = &#39;&amp;lt;td&amp;gt;&#39; + value.id + &#39;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&#39; + value.pname + &#39;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&#39; + value.price + &#39;&amp;lt;/td&amp;gt;&#39;; tbody.appendChild(tr); }); 根据价格筛选数据 获取到搜索按钮并为其绑定点击事件 search_price.addEventListener(&#39;click&#39;, function() {}); 使用filter将用户输入的价格信息筛选出来 search_price.addEventListener(&#39;click&#39;, function() { var newDate = data.filter(function(value) { //start.value是开始区间 //end.value是结束的区间 return value.price &amp;gt;= start.value &amp;amp;&amp;amp; value.price &amp;lt;= end.value; }); console.log(newDate); }); 将筛选出来的数据重新渲染到表格中 将渲染数据的逻辑封装到一个函数中 function setDate(mydata) { // 先清空原来tbody 里面的数据 tbody.innerHTML = &#39;&#39;; mydata.forEach(function(value) { var tr = document.createElement(&#39;tr&#39;); tr.innerHTML = &#39;&amp;lt;td&amp;gt;&#39; + value.id + &#39;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&#39; + value.pname + &#39;&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&#39; + value.price + &#39;&amp;lt;/td&amp;gt;&#39;; tbody.appendChild(tr); }); } 将筛选之后的数据重新渲染 search_price.addEventListener(&#39;click&#39;, function() { var newDate = data.filter(function(value) { return value.price &amp;gt;= start.value &amp;amp;&amp;amp; value.price &amp;lt;= end.value; }); console.log(newDate); // 把筛选完之后的对象渲染到页面中 setDate(newDate);}); 根据商品名称筛选 获取用户输入的商品名称 为查询按钮绑定点击事件,将输入的商品名称与这个数据进行筛选 search_pro.addEventListener(&#39;click&#39;, function() { var arr = []; data.some(function(value) { if (value.pname === product.value) { // console.log(value); arr.push(value); return true; // return 后面必须写true } }); // 把拿到的数据渲染到页面中 setDate(arr);}) 3.5 some和forEach区别 如果查询数组中唯一的元素, 用some方法更合适,在some 里面 遇到 return true 就是终止遍历 迭代效率更高 在forEach 里面 return 不会终止迭代3.6 trim方法​ trim方法用来去除字符串两端的空格。var str = &#39; hello &#39;console.log(str.trim()） //hello 去除两端空格var str1 = &#39; he l l o &#39;console.log(str.trim()） //he l l o 去除两端空格3.7 Object.keys​ Object.keys(对象) 获取到当前对象中的属性名 ，返回值是一个数组 var obj = { id: 1, pname: &#39;小米&#39;, price: 1999, num: 2000};var result = Object.keys(obj)console.log(result)//[id，pname,price,num]3.8 Object.defineProperty​ Object.defineProperty设置或修改对象中的属性Object.defineProperty(对象，修改或新增的属性名，{ value:修改或新增的属性的值, writable:true/false,//如果值为false 不允许修改这个属性值 enumerable: false,//enumerable 如果值为false 则不允许遍历 configurable: false //configurable 如果为false 则不允许删除这个属性 属性是否可以被删除或是否可以再次修改特性}) " }, { "title": "JS面向对象编程", "url": "/posts/%E5%89%8D%E7%AB%AF-JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/", "categories": "前端", "tags": "前端JS", "date": "2021-05-12 00:00:00 +0800", "snippet": "1.面向过程与面向对象1.1 面向过程​ 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。1.2 面向对象​ 面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作。1.3 面向过程与面向对象对比   面向过程 面向对象 优点 性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程编程。 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护 缺点 不易维护、不易复用、不易扩展 性能比面向过程低 2.对象与类2.1 对象​ 对象是由属性和方法组成的，是一个无序键值对的集合，指的是一个具体的事物 属性：事物的特征，在对象中用属性来表示（常用名词） 方法：事物的行为，在对象中用方法来表示（常用动词）//以下代码是对对象的复习//字面量创建对象var ldh = { name: &#39;刘德华&#39;, age: 18}console.log(ldh);//构造函数创建对象 function Star(name, age) { this.name = name; this.age = age; }var ldh = new Star(&#39;刘德华&#39;, 18)//实例化对象console.log(ldh);2.2 类​ 在 ES6 中新增加了类的概念，可以使用 class 关键字声明一个类，之后以这个类来实例化对象。​ 类抽象了对象的公共部分，它泛指某一大类（class）对象特指某一个，通过类实例化一个具体的对象。2.2.1 创建类 语法://步骤1 使用class关键字class name { // class body} //步骤2 使用定义的类创建实例 注意new关键字var xx = new name(); 示例 // 1. 创建类 class 创建一个 明星类 class Star { // 类的共有属性放到 constructor 里面 constructor(name, age) { this.name = name; this.age = age; } } // 2. 利用类创建对象 new var ldh = new Star(&#39;刘德华&#39;, 18); console.log(ldh);以上代码运行结果:通过结果我们可以看出,运行结果和使用构造函数方式一样2.2.2 类创建添加属性和方法 // 1. 创建类 class 创建一个类class Star { // 类的共有属性放到 constructor 里面 constructor是 构造器或者构造函数 constructor(uname, age) { this.uname = uname; this.age = age; } //-------------------------------------------&amp;gt;注意,方法与方法之间不需要添加逗号 sing(song) { console.log(this.uname + &#39;唱&#39; + song); }}// 2. 利用类创建对象 newvar ldh = new Star(&#39;刘德华&#39;, 18);console.log(ldh); // Star {uname: &quot;刘德华&quot;, age: 18}ldh.sing(&#39;冰雨&#39;); // 刘德华唱冰雨以上代码运行结果:注意哟: 通过class 关键字创建类, 类名我们还是习惯性定义首字母大写 类里面有个constructor 函数,可以接受传递过来的参数,同时返回实例对象 constructor 函数 只要 new 生成实例时,就会自动调用这个函数, 如果我们不写这个函数,类也会自动生成这个函数 多个函数方法之间不需要添加逗号分隔 生成实例 new 不能省略 语法规范, 创建类 类名后面不要加小括号,生成实例 类名后面加小括号, 构造函数不需要加function2.2.3 类的继承 语法// 父类class Father{ } // 子类继承父类class Son extends Father { } 示例class Father { constructor(surname) { this.surname= surname; } say() { console.log(&#39;你的姓是&#39; + this.surname); }}class Son extends Father{ // 这样子类就继承了父类的属性和方法}var damao= new Son(&#39;刘&#39;);damao.say(); //结果为 你的姓是刘以上代码运行结果: 子类使用super关键字访问父类的方法 //定义了父类class Father { constructor(x, y) { this.x = x; this.y = y; } sum() { console.log(this.x + this.y); }} //子元素继承父类class Son extends Father { constructor(x, y) { super(x, y); // 使用super调用了父类中的构造函数 }} var son = new Son(1, 2); son.sum(); //结果为3 注意: 继承中,如果实例化子类输出一个方法,先看子类有没有这个方法,如果有就先执行子类的 继承中,如果子类里面没有,就去查找父类有没有这个方法,如果有,就执行父类的这个方法(就近原则) 如果子类想要继承父类的方法，同时在自己内部扩展自己的方法,利用super 调用父类的构造函数,super 必须在子类this之前调用 // 父类有加法方法 class Father { constructor(x, y) { this.x = x; this.y = y; } sum() { console.log(this.x + this.y); } } // 子类继承父类加法方法 同时 扩展减法方法 class Son extends Father { constructor(x, y) { // 利用super 调用父类的构造函数 super 必须在子类this之前调用,放到this之后会报错 super(x, y); this.x = x; this.y = y; } subtract() { console.log(this.x - this.y); }} var son = new Son(5, 3);son.subtract(); //2son.sum();//8 以上代码运行结果为: 时刻注意this的指向问题,类里面的共有的属性和方法一定要加this使用. constructor中，this指向的是new出来的实例对象 自定义的方法，一般也指向的new出来的实例对象 绑定事件之后，this指向的就是触发事件的事件源 在 ES6 中类没有变量提升，所以必须先定义类，才能通过类实例化对象 3.应用案例​ 项目名称：面向对象版tab 栏切换​ 功能需求： 点击 tab栏,可以切换效果 点击 + 号, 可以添加 tab 项和内容项 点击 x 号, 可以删除当前的tab项和内容项 双击tab项文字或者内容项文字可以修改里面的文字内容案例思路： 将页面完全解析到程序变量中，使得页面中的每个元素都能够可控； 在类中指定元素的方法和属性，实现功能" }, { "title": "JS执行机制", "url": "/posts/%E5%89%8D%E7%AB%AF-JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/", "categories": "前端", "tags": "前端JS", "date": "2021-05-11 00:00:00 +0800", "snippet": "1.概述​ JavaScript语言的一大特点就是单线程，即同一个时间只能做一件事。​ 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。​ 这样所导致的问题是： 如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。2.同步任务和异步任务​ 为了解决单线程问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制。于是，JS 中出现了同步任务和异步任务。2.1同步​ 前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。比如做饭的同步做法：我们要烧水煮饭，等水开了（10分钟之后），再去切菜，炒菜。2.2异步​ 你在做一件事情时，因为这件事情会花费很长时间，在做这件事的同时，你还可以去处理其他事情。比如做饭的异步做法，我们在烧水的同时，利用这10分钟，去切菜，炒菜。3.事件循环3.1 setTimeout大名鼎鼎的setTimeout无需再多言，大家对他的第一印象就是异步可以延时执行，我们经常这么实现延时3秒执行：setTimeout(() =&amp;gt; { console.log(&#39;延时3秒&#39;);},3000)​ 渐渐的setTimeout用的地方多了，问题也出现了，有时候明明写的延时3秒，实际却5，6秒才执行函数，这又咋回事啊？先看一个例子：setTimeout(() =&amp;gt; { task();},3000)console.log(&#39;执行console&#39;)​ 根据前面我们的结论，setTimeout是异步的，应该先执行console.log这个同步任务，所以我们的结论是：//执行console//task()复制代码去验证一下，结果正确！然后我们修改一下前面的代码：setTimeout(() =&amp;gt; { task()},3000)sleep(10000000)​ 乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行task()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？​ 这时候我们需要重新理解setTimeout的定义。我们先说上述代码是怎么执行的： task()进入Event Table并注册,计时开始。 执行sleep函数，很慢，非常慢，计时仍在继续。 3秒到了，计时事件timeout完成，task()进入Event Queue，但是sleep也太慢了吧，还没执行完，只好等着。 sleep终于执行完了，task()终于从Event Queue进入了主线程执行。​ 我们还经常遇到setTimeout(fn,0)这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？​ 答案是不会的，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明：//代码1console.log(&#39;先执行这里&#39;);setTimeout(() =&amp;gt; { console.log(&#39;执行啦&#39;)},0);//代码2console.log(&#39;先执行这里&#39;); setTimeout(() =&amp;gt; { console.log(&#39;执行啦&#39;)},3000);代码1的输出结果是：//先执行这里//执行啦代码2的输出结果是：//先执行这里// ... 3s later// 执行啦​ 关于setTimeout要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。3.2 setInterval​ setInterval会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。​ 唯一需要注意的一点是，对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。" }, { "title": "JS对象、BOM与DOM", "url": "/posts/%E5%89%8D%E7%AB%AF-JS-DOM%E5%92%8CBOM/", "categories": "前端", "tags": "前端JS", "date": "2021-05-10 00:00:00 +0800", "snippet": "1.内置对象1.1 对象​ JS中所有的事物都是对象，字符串、数值、数组、函数… 每个对象都带有属性和方法。1.2 自定义对象1. 定义并创建对象实例2. 使用函数来定义对象，然后创建新的对象实例&amp;lt;body&amp;gt; &amp;lt;script&amp;gt; people = new Object(): people.name = &#39;liming&#39; people.age = &#39;26&#39; document.write(&quot;name:&quot;+ people.name + &quot;age&quot;+son.age) //也可以采用下面的一种方式复制（字典） people = {name:&quot;iwen&quot;,age:&quot;30&quot;} &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt;通过函数&amp;lt;body&amp;gt; &amp;lt;script&amp;gt; function people(name,age){ this.name = name; this.age = age; //注意，这儿需要this来索引 } son = new people(&quot;liming&quot;,30) document.write(&quot;name:&quot;+ people.name + &quot;age&quot;+son.age) &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt;1.3 String字符串对象 成员 作用 length 获取字符串长度 charAt(index) 获取index处的字符 indexOf(searchValue) 获取searchValue在字符串中的首次出现的位置 lastIndexOf(searchValue) 获取searchValue在字符串中的最后出现的位置 substring(start,end) 截取原字符串start到end之间的字符串 substr(start,length) 截取原字符串start开始往后length长度的字符串 toLowerCase() 字符串小写 toUpperCase() 字符串大写 split(sepetator,limit) 通过seperator来分割原字符串，limit为切割次数限制 replace(str1,str2) 用str2来替换str1,返回替换结果 var str = &#39;helloworld&#39;;str.length; // 字符串长度，返回结果：10str.charAt(5);//获取索引为5处的元素，返回结果：wstr.indexOf(&#39;o&#39;);//获取字母o第一次出现的位置，返回结果：4str.lastIndexOf(&#39;o&#39;);// 获取字母o最后一次出现的位置，返回结果：6str.substring(5);//获取索引5开始以后的所有元素，返回结果：worldstr.substring(5,7);// 获取索引5开始到索引7之间的元素，返回结果：wostr.substr(5);//获取索引5开始以后的所有元素，返回结果：worldstr.substr(5,3);//获取索引5开始往后3个元素，返回结果：worstr.toLowerCase();// 小写 helloworldstr.toUpperCase();//大写 HELLOWORLDstr.splite(&#39;l&#39;);// 使用字符串的l分割字符串，返回结果：[&quot;he&quot;,&quot;&quot;,&quot;owor&quot;,&quot;d&quot;]str.splite(&#39;l&#39;,3);// 切割三次，返回结果：[&quot;he&quot;,&quot;&quot;,&quot;owor&quot;]str.replace(&#39;World&#39;,&#39;JavaScript&#39;);// 返回结果：helloJavaScript1.4 Date日期对象 Date对象 ：用于处理日期和时间 方法 作用 getFullYear() 获取年份的四位数字，如2022 getMonth() 获取月份，范围0~11（0 --- 一月份，1 --- 二月份） getDate() 获取月份中的某一天，范围 1~31 getHours() 获取小时数，范围0~23 getMinutes() 获取分钟数，范围0~59 getSeconds() 获取秒数，范围0~59 getMilliSeconds() 获取毫秒数，范围0~999 getTime() 获取从1970-01-01 00:00:00距离Date对象中的时间的毫秒数 setFullYear(value) 设置年份 setMonth() 设置月份 setDate() 设置月份中的某一天 setHours() 设置小时数 setMinutes() 设置分钟数 setSeconds() 设置秒数 setMilliSeconds() 设置毫秒数 setTime(value) 设置从1970-01-01 00:00:00后value毫秒数的时间 &amp;gt; var d = new Date(2021,4,25,3,12,23)&amp;gt; console.log(d) Tue May 25 2021 03:12:23 GMT+0800 (中国标准时间)&amp;gt; console.log(d.getDate()) 25&amp;lt;body onLoad=&quot;startTime()&quot;&amp;gt; &amp;lt;script&amp;gt; // var date = new Date(); // document.write(date); // document.write(date.getFullYear()); // document.write(date.getTime()); // date.setFullYear(2020, 7, 20); function startTime() { var today = new Date(); var h = today.getHours(); var m = today.getMinutes(); var s = today.getSeconds(); m = checkTime(m); s = checkTime(s); document.getElementById(&quot;timetxt&quot;).innerHTML = h + &quot;:&quot; + m + &quot;:&quot; + s; t = setTimeout(function () { startTime() }, 1000); //通过时间设定输出，设定时间间隔为1000s } function checkTime(i) { if (i &amp;lt; 10) { i = &quot;0&quot; + i //控制格式为 08:27:30 } return i } &amp;lt;/script&amp;gt; &amp;lt;div id=&quot;timetxt&quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt;1.5 数组对象​ 数组对象在基本概念中讲过，此处再讲一次。 Array对象： 使用单独的变量名来存储一系列的值 数组的创建： 第一种方式： 使用直接赋值创建 &amp;lt;script&amp;gt; var myArray = [&quot;hello&quot;,&quot;world&quot;,&quot;love&quot;]&amp;lt;/script&amp;gt; 第二种方式：使用关键字Array创建 值得注意的是，此处对数组初始化后的长度，不影响数组继续添加元素，同时，添加元素后length也会发生相应的改变。 // 一维数组的创建var myarray = new Array(3); //二维数组的创建var myarray = [new Array(3), new Array(3) ]var myarray = [[],[]] 数组的访问：通过指定数组名以及索引号码访问。JS与python一样，从0开始，myArray[0]代表第一个元素 // 遍历数组for (let i in myarray){ console.log(i)} // 元素的添加,其中没有赋值的位置为emptylet height =[];height[1] = 10; // 元素的修改let arr =[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]arr[1] = &#39;abc&#39;console.log(arr) //此时的输出值为[&#39;a&#39;,&#39;abc&#39;,&#39;c&#39;] // 删除let arr =[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]delete arr[0] // delete只是删除了元素值，元素位置仍然存在console.log(arr) //此时的输出值为[empty,&#39;abc&#39;,&#39;c&#39;] // 二维数组的访问 -- 采用遍历的方式； 后面的排序思想都是一样的，此处不敲代码了let arr = [[1,2,3],[4,5,6]];for (i in arr){ for (j in arr[i]){ console.log(arr[i][j]); }} 数组内容检索 // includes() 方法var data = [&#39;peach&#39;,&#39;pear&#39;,26,&#39;216&#39;,&#39;grape&#39;]console.log(data.includes(26,3)) // 从数组下标为3 的位置检索数字26，此时返回值为falseconsole.log(data.includes(26,-3)) // 从倒数第三个位置开始检索数字26，此时返回值为true// Array.isArray() 判断数据类型是否为数组类型console.log(Array.isArray(data)) // 此时的返回值为true 数组转字符串 // join() 方法，将所有元素连接成一个字符串console.log([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;].join()); // 此时输出结果为 a,b,cconsole,log([[&#39;a&#39;,&#39;b&#39;],[&#39;c&#39;,&#39;d&#39;]].join(&#39;-&#39;)); // 此时输出结果为 a,b-c,d 数组常用方法： concat() 合并数组 &amp;lt;script&amp;gt; var a=[&quot;hello&quot;,&quot;world&quot;]; var b=[&quot;love&quot;,&quot;sukhoi&quot;] var c=a.concat(b)&amp;lt;/script&amp;gt; sort() 排序 &amp;lt;script&amp;gt; var a =[&quot;a&quot;,&quot;c&quot;,&quot;d&quot;,&quot;g&quot;,&quot;w&quot;] document.write(a.sort()); ---------------------------------- var a= [&quot;5,&quot;6&quot;,&quot;3&quot;,&quot;4&quot;,&quot;8&quot;] document.write(a.sort(function(a,b){ return b-a; // b-a :降序排列;a-b:即为升序排列 }))&amp;lt;/script&amp;gt; push() 末尾追加 &amp;lt;script&amp;gt; var a =[&quot;a&quot;,&quot;c&quot;] document.write(a.push(&quot;b&quot;)) //在a的末尾增加字母c&amp;lt;/script&amp;gt; reverse() 翻转 &amp;lt;script&amp;gt; var a =[&quot;a&quot;,&quot;c&quot;，&quot;b&quot;] document.write(a.reverse()) //将数组内的元素翻转，翻转后为b,c,a&amp;lt;/script&amp;gt; splice() var arr= [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]console.log(arr.splice(2,2)) // 从下标为2的位置开始删除后面2个元素 ，此时返回的结果为[&#39;a&#39;,&#39;b&#39;]console.log(arr.splice(1,1,&#39;element&#39;)) // 由于上面的返回值为[&#39;a&#39;,&#39;b&#39;]，此时的返回值为[&#39;a&#39;,&#39;element&#39;] 1.6 Math对象 成员 作用 PI 圆周率,3.1415926543 abs(x) 绝对值 max([…]) 数组最大值 min([…]) 数组最小值 pow(base,exponent) 基数base的exponent次幂，如pow(2,5)即2的5次幂 sqrt(x) 获取x的平方根 ceil(x) x向上取整 floor(x) x向下取整 round(x) x四舍五入 random() 获取0.0~1.0之间的随机值 document.write(Math.round(2.4)) //四舍五入返回2document.write(Math.random()) //返回0-1之间的值document.write(parseInt(Math.random()*10)) //返回0-10之间的整数值document.write(Math.min(10,25,25,36,51,48)) //返回最小值10document.write(Math.abs(-10)) //返回绝对值101.7 Number对象 成员 作用 MAX_VALUE JS所能表征的最大值 MIN_VALUE JS所能表征的最小值 toFixed(digits) 使用定点表示法来格式化一个值，digits为保留的小数位数 var num = 1234.5678num.toFixed() // 四舍五入，返回结果：1234num.toFixed(1) // 四舍五入，保留一位小数，返回结果：1234.5num.toFixed(6) // 四舍五入，保留六位小数，返回结果：1234.5678002. BOM对象 (Brower Object Model )​ BOM对象是指浏览器对象模型。BOM结构图如下：window |-- document -- DOM |-- history |-- location |-- navigator |-- screen这就是说，window是BOM的顶层对象，其他对象添加到window下，作为window的子对象 对象名称 说明 document (文档对象) 即DOM对象，是html页面当前窗体的内容 history（历史对象） 访问浏览器历史记录，也就是浏览器前进后退的功能 location（地址栏对象） 用于获取浏览器中URL地址栏的相关内容 navigator （浏览器对象） 用于获取浏览器版本、名称等 screen（屏幕对象） 用于获取屏幕相关的信息，如分辨率、坐标信息等 2.1 顶级对象 - window对象2.1.1 输入框对象 – prompt()var str1 =prompt(&#39;请输入测试的选项&#39;)var str1 =prompt(&#39;请输入测试的选项&#39;,&#39;用户名和密码&#39;)// 第一个参数是提示语，第二个参数是输入框中的内容，相当于placeholder2.1.2 确认对话框 – confirm()function del(){ if (comfirm(&#39;确认删除吗？&#39;){ // 按下确认后的执行 } else{ // 按下取消后的执行 })}2.1.3 打开与关闭窗口 open() 和 close()open(URL,name,spacs,replace) 参数 说明 URL 需要打开的网址 name 这里有很多属性，直接写字符为窗口名称；_blank,指URL打开到新的页面； _self加载到当前页面；还有两种，自己百度 spacs 新窗口的浏览器窗口属性，大小、位置、滚动条等；height，width，left，location，menubar，scrollbars，status var mywindow = window.open(&#39;&#39;,&#39;newwin&#39;,&#39;width=400,height=200,left = 200&#39;)// 也可以使用close方法来关闭窗口window.close()2.1.4 窗口位置和大小这个很重要，详细记载一下 属性 说明 screenLeft 返回窗口相对左边的x坐标 - screenX screenTop 返回窗口相对顶部的y坐标 - screenY innerHeight 返回窗口文档显示区的高度 innerWidth 返回窗口文档显示区的宽度 outerHeight 返回窗口的高度【包括工具栏和滚动条】 - 控制窗口大小就用这个来检查 outerWidth 返回窗口的宽度【包括工具栏和滚动条】 方法 说明 moveBy() 移动窗口到相对的位置 moveTo() 移动窗口到指定位置 resizeBy() 调整窗口到相对宽高 resizeTo() 调整窗口到指定宽高 – 这个就可以与outerHeight联系起来了，一般这个用的多 function openWin(){ myWindow=window.open(&#39;&#39;,&#39;&#39;,&#39;width=200,height=100&#39;); myWindow.document.write(&quot;&amp;lt;p&amp;gt;这是我的窗口&amp;lt;/p&amp;gt;&quot;);}function moveWin(){ myWindow.moveBy(250,250); // 在现有的位置，往右移动250px，往下移动250px myWindow.moveTo(250,250); // 移动到屏幕的 （250，250）处 myWindow.resizeTo(300,100); // 将窗口尺寸调整到宽为300，高为100 myWindow.focus();}// 调整窗口大小// window.onresize 是调整窗口大小加载事件, 当触发时就调用的处理函数。window.onresize = function(){};window.addEventListener(&quot;resize&quot;,funciton(){});注意： 只要窗口大小发生像素变化，就会触发这个事件 我们经常利用这个事件完成响应式布局。 window.innerWidth 当前屏幕的宽度&amp;lt;div&amp;gt; 响应式活动展示模块&amp;lt;/div&amp;gt;&amp;lt;script&amp;gt; // 注册页面加载事件 window.addEventListener(&#39;load&#39;, function() { var div = document.querySelector(&#39;div&#39;); // 注册调整窗口大小事件 window.addEventListener(&#39;resize&#39;, function() { // window.innerWidth 获取窗口大小 console.log(&#39;变化了&#39;); if (window.innerWidth &amp;lt;= 800) { div.style.display = &#39;none&#39;; } else { div.style.display = &#39;block&#39;; } }) }) &amp;lt;/script&amp;gt;2.1.5 定时器这个用的比较多，着重理解setTimeOut(func,1000) //指定的时间后执行其他函数操作 ，时间为毫秒;func为函数体，1000毫秒 = 1秒setInterval(func,1000) // 指定周期运行一次函数clearTimeout(timer) // 取消setTimeOut ,timer = setTimeOut(func,1000)clearInterval(timer) // 取消Interval, timer = setInterval(func,1000) &amp;lt;button&amp;gt;点击停止定时器&amp;lt;/button&amp;gt; &amp;lt;script&amp;gt; var btn = document.querySelector(&#39;button&#39;); // 开启定时器 var timer = setTimeout(function() { console.log(&#39;爆炸了&#39;); }, 5000); // 给按钮注册单击事件 btn.addEventListener(&#39;click&#39;, function() { // 停止定时器 clearTimeout(timer); }) &amp;lt;/script&amp;gt;2.1.6 加载​ 如果页面的图片很多的话, 从用户访问到onload触发可能需要较长的时间, 交互效果就不能实现，必然影响用户的体验，此时用 DOMContentLoaded 事件比较合适。 &amp;lt;script&amp;gt; window.addEventListener(&#39;load&#39;, function() { var btn = document.querySelector(&#39;button&#39;); btn.addEventListener(&#39;click&#39;, function() { alert(&#39;点击我&#39;); }) }) window.addEventListener(&#39;load&#39;, function() { alert(22); }) document.addEventListener(&#39;DOMContentLoaded&#39;, function() { alert(33); }) &amp;lt;/script&amp;gt;2.2 Location对象2.2.1 URL解析http://www.baidu.com:80/web/index.html?a=3&amp;amp;b=4#reshttp // 代表数据传输协议www.baidu.com // 代表主机名80 // 代表端口index.html // 代表要请求的资源a=3&amp;amp;b=4 // 代表用户传递的参数#res //代表锚点2.2.2 获取URL参数 属性 说明 href 返回完成的URL protocol 返回其中的数据传输协议 hostname 返回主机名 port 返回端口 host 返回主机名和端口 hash 返回锚点 // 用的最多的就是href，使用方式如下1. 获取URL : location.href2. 改变当前加载的页面 location.href = &#39;www.baidu.com&#39; 三个方法 assign() // 载入一个新的文档reload() // 重新载入文档replace() // 用新的文档替换当前文档 综合案例来一个 点击加载新的内容&amp;lt;body&amp;gt; &amp;lt;input type=&quot;button&quot; value=&quot;载入新文档&quot; onclick=&quot;newDoc()&quot;&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;script&amp;gt; function newDoc(){ window.location.assign(&quot;https://www.runoob.com&quot;) }&amp;lt;/script&amp;gt; 定时跳转页面 // 下面这么写，有一定的效果，但是还是建议通过vue来解决这样的倒计时跳转问题此处主要学会页面的location跳转&amp;lt;body&amp;gt; &amp;lt;div id=&quot;seconds&quot;&amp;gt;3&amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;script&amp;gt; function sleep(delay) { var start = (new Date()).getTime(); while ((new Date()).getTime() - start &amp;lt; delay) { continue; } } function timing(secs) { var seconds = document.getElementById(&#39;seconds&#39;); if (secs &amp;gt; 0) { secs -= 1 seconds.innerHTML = --secs; sleep(1000) console.log(secs) timing(secs) } else { location.assign(&#39;http://www.baidu.com&#39;) } } timing(10) &amp;lt;/script&amp;gt; 2.3 history对象 属性和方法 说明 length 返回历史记录的长度 back() 加载前一个URL forward() 加载后一个URL go(num) 加载到第num个页面，如前进为1，后退为-1 history.go(1)history.go(-1)2.4 navigator对象​ navigator 对象包含有关浏览器的信息，它有很多属性，我们最常用的是 userAgent，该属性可以返回由客户机发送服务器的 user-agent 头部的值。下面前端代码可以判断用户那个终端打开页面，实现跳转if((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) { window.location.href = &quot;&quot;; //手机 } else { window.location.href = &quot;&quot;; //电脑 }参考链接：Navigator 对象2.5 screen对象​ 主要对当前窗口和屏幕的信息，如屏幕的高度，宽度等，用来查询屏幕的属性screen.height // 结果为900，即整个屏幕的高度screen.width // 结果为500 ，整个屏幕的宽度screen.availHeight // 结果为870 ，浏览器窗口可占用的垂直高度screen.colorDepth // 结果为24 ，屏幕颜色深度3. DOM对象（Document Object Model）​ 当网页被加载时，浏览器会创建页面的文档对象模型(DOM).3.1 DOM 操作HTML JS 改变HTML元素 JS改变HTML属性 JS改变CSS样式 JS对页面中的事件作出反应 改变HTML输出流 注意：绝对不要加载完文档后，使用document.write DOM对象的继承关系 Node|-- Document| |-- HTMLDocument| |-- document --&amp;gt; document.getElementById(&#39;test&#39;)|-- Element |--HTMLElement |-- HTMLDivElement --&amp;gt; &amp;lt;div id = &#39;test&#39;&amp;gt; &amp;lt;/div&amp;gt; 3.1.1 创建对象document.write()document.innerHTMLdocument.createElement3.1.2 增加对象 方法 说明 appendChild() 父级元素中加入子集元素 insertBefore() 父级元素下，元素前插入兄弟元素前 insertAdjacentHTML(position, text) 在指定的地方插入html标签语句 insertAdjacentText 在指定的地方插入文本语句 // appendChild()var ul = document.querySelector(&quot;ul&quot;);// 1. 创建节点 元素节点// 2. 添加节点 node.appendChild(child) node父级 child 子级 元素追加到最后面（即追加元素）var li = document.createElement(&quot;li&quot;);ul.appendChild(li);// insertBefore()var ok = document.getElementById(&quot;ok&quot;); //获取按钮元素的引用ok.onclick = function () { //为按钮注册一个鼠标单击事件处理函数 var red = document.getElementById(&quot;red&quot;); //获取红色盒子的引用 var blue = document.getElementById(&quot;blue&quot;); //获取蓝色盒子的引用 var h1 = document.getElementsByTagName(&quot;h1&quot;)[0]; //获取标题元素的引用 red.insertBefore(blue, h1); //把蓝色盒子移动到红色盒子内，且位于标题前面}position是相对于元素的位置，并且必须是以下字符串之一：beforebegin: 元素自身的前面。afterbegin: 插入元素内部的第一个子节点之前。beforeend: 插入元素内部的最后一个子节点之后。afterend: 元素自身的后面。text是要被解析为HTML或XML,并插入到DOM树中的字符串&amp;lt;!-- beforebegin --&amp;gt; &amp;lt;p&amp;gt; &amp;lt;!-- afterbegin --&amp;gt; foo&amp;lt;!-- beforeend --&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;!-- afterend --&amp;gt;3.1.3 删除对象removeChild3.1.4 修改对象1. 修改属性,src、href、title等2. 修改普通元素,innerHTML、innerText3. 修改表单元素,value、type、disabled等4. 修改元素样式,style、className 属性 说明 innerHTML 设置或者返回两个标签之间的html内容 =&amp;gt; 推荐使用该方法进行元素的内容设置 标签+纯文本 innerText 设置或者返素中去掉所有标签后的内容，纯文本【爬虫可以用这个】 textContent 设置或者返回指定节点的文本内容 attributes 返回一个元素的属性集合，这个可以查看当前元素的属性及属性值 方法 说明 setAttribute(name,value) 设置或者改变元素name的属性值value getAttribute(name) 获取元素的属性值【系统属性+自定义属性】 removeAttribute(name) 删除元素中的属性 &amp;lt;a id=&quot;aid&quot; href = &quot;http://www.baidu.com&quot;&amp;gt;百度&amp;lt;/a&amp;gt;&amp;lt;img id=&#39;imgid&#39; src = &#39;a.jpg&#39;&amp;gt;&amp;lt;p id = &quot;pid&quot;&amp;gt;Hello&amp;lt;/p&amp;gt;&amp;lt;button onclick =&quot;demo()&quot;&amp;gt;按钮&amp;lt;/button&amp;gt;&amp;lt;script&amp;gt; function setAttr(){ let text = document.getElementById(&#39;pid&#39;) text.setAttribute(&#39;align&#39;,&#39;center&#39;) text.setAttribute(&#39;title&#39;,&#39;测试文字&#39;) text.setAttribute(&#39;style&#39;,&#39;font-size：24px;border:1px solid yellow&#39;) console.log(text.attributes.length) } function demo(){ //点击后，将 百度 的地址改变成了 即可学院 的地址； 将图片 a.jpg 改变为 7.jpg document.getElementById(&quot;aid&quot;).href = &quot;http://www.jikexueyuan.com&quot;; document.getElementById(&quot;aid&quot;).src = &quot;7.jpg&quot;; }&amp;lt;/script&amp;gt;3.1.5 查找对象 方法 说明 document.getElementById() 根据id查找元素 document.getElementsByTagName() 根据标签名查找元素 document.getElementByName() 根据指定的name查找元素 document.getElementsByClassName() 根据类名查找元素 document.querySelector() 匹配指定元素或者css选择器的第一个对象 document.querySelectAll() 匹配指定元素或者css选择器的所有对象 通过标签名找到HTML元素&amp;lt;p id = &quot;pid&quot;&amp;gt;Hello&amp;lt;/p&amp;gt;&amp;lt;button onclick =&quot;demo()&quot;&amp;gt;按钮&amp;lt;/button&amp;gt;&amp;lt;script&amp;gt; function demo(){ var test = document.getElementById(&quot;pid&quot;); // 此时返回的对象为Element对象 // 在get到元素后，可以采用__proto__查看元素继承的原型,此时输出为HTMLDivElement{...} console.log(test.__proto__) // 改变HTML内容 （innerHTML) nv.innerHTML = &quot;world&quot; }&amp;lt;/script&amp;gt;// 此处着重对querySelector 和querySelectorAll() 进行解释// 这两个选择器比较强大，后面需要多用用console.log(document.querySeletor(&#39;div&#39;)) // 选中第一个标签为div的元素console.log(document.querySeletor(&#39;.bat&#39;)) // 选中第一个类为bat的元素console.log(document.querySeletor(&#39;#box&#39;)) // 选中第一个id为box 的元素console.log(document.querySeletor(&#39;div[name]&#39;)) // 选中第一个含有name属性的divconsole.log(document.querySeletor(&#39;div.bar&#39;)) // 选中第一个含有类为bar的divconsole.log(document.querySeletor(&#39;div#box&#39;)) // 选中第一个id为box的divdocument提供一些属性，用的比较少 属性 说明 document.body 返回文档的body元素 document.documentElement 返回文档的html元素 document.forms 返回文档中所有的Form对象 document.images 返回文档中所有的image对象 var body = docuemnt.getElementByTagName(&#39;body&#39;)[0]console.log(body == document.body) // 结果为true 3.2 DOM操作CSS​ 除了上面通过setAttribute()的方式来修改元素的样式外，最为常用的还是使用style属性来进行修改。此时，需要注意的是，样式操作中，去掉css样式名中间的 ‘ - ‘,并将第二个英文字母的首字母大写如 css中的background-color 写成 backgroundColor常用的属性如下，比较重要，需要扎实掌握 属性 说明 background 设置或返回背景属性 backgroundColor 设置或返回背景颜色 display 设置或返回显示类型 height 设置或返回高度 width 设置或返回宽度 left 设置或返回定位元素的左部位置，（right，top，buttom同理） listStyleType 设置或返回列表标记 overflow 设置或返回处理框外元素的方式 textAlign 设置或返回文本的水平对齐方式 textDecoration 设置或返回文本的修饰方式 textIndent 设置或返回文本的第一行缩进 transform 向元素应用2D或3D转换 document.getElementById(id).style.property = new stylestyle.css文件内容.div{ width : 100px; height :200px; background-color : red;}index.html文件内容&amp;lt;head lang=&#39;en&#39;&amp;gt; &amp;lt;meta charset=&#39;UTF-8&#39;&amp;gt; &amp;lt;title&amp;gt;测试专用&amp;lt;/title&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot;&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;div id=&quot;div&quot; class=&quot;div&quot;&amp;gt;hello&amp;lt;/div&amp;gt; &amp;lt;button onclick=&quot;demo()&quot;&amp;gt;&amp;lt;/button&amp;gt; &amp;lt;script&amp;gt; function demo() { var ele = document.getElementById(&quot;div&quot;) ele.style.backgroundColor =&quot;blue&quot;; ele.style.width = &quot;100px&quot;; ele.style.transform = &#39;rotate(7deg)&#39;; } &amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;​ 值得一提的是，在进行style属性调用时，常常将属性写在css文件下的类中，这个时候就需要进行类属性的统一添加，方便快捷。此处用到元素的类列表，即 classList 属性 说明 length 获取元素所拥有的类的个数 add() 为元素添加类 remove() 移出元素的类 toggle() 切换元素的类；没有就添加，有则移除 contains() 判断元素是否拥有此类，有则返回true，无则返回false &amp;lt;style&amp;gt; .bg{backgound:#ccc } .strong{font-size:24px;color:red} .smooth{height:30px;width:12px;border-radius:10px}&amp;lt;/style&amp;gt;&amp;lt;ui&amp;gt; &amp;lt;li&amp;gt;PHP&amp;lt;/li&amp;gt; &amp;lt;li class=&quot;bg&quot;&amp;gt;JavaScripy&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;C&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;Python&amp;lt;/li&amp;gt;&amp;lt;/ui&amp;gt;&amp;lt;script&amp;gt; var ele = document.getElementByTagName(&#39;li&#39;)[1] // 判断元素ele是否有strong这个类，没有就添加 if (!ele.classList.contains(&#39;strong&#39;)){ ele.classList.add(&#39;strong&#39;) } // ele中若有smooth类，则删除；没有则添加； 状态切换 ele.classList.toggle(&#39;smooth&#39;)&amp;lt;/script&amp;gt; 3.3 DOM节点操作将HTML文档看作一棵节点树，可以使用节点方法操作HTML中的元素 节点类型 节点名称 nodeType 1 元素节点 nodeType 2 属性节点 nodeType 3 文本节点 nodeType 8 注释节点 nodeType 9 文档节点 常用获取节点的方法 方法 说明 firstChild 获取元素的第一个子节点 lastChild 获取元素的最后一个子节点 nodeName 获取当前节点的名称 nodeValue 获取当前节点的值 nextSibling 获取同一树层级中指定节点的后一个节点 previousSibling 获取同一树层级中指定节点的前一个节点 parentNode 获取当前节点的父节点 childNodes 获取当前节点下的所有子节点 // 这些方法只是对节点的选择，一般情况下，需要对元素节点进行操作，即 document.nextElementSiblingdocument.firstChild //返回值为 &amp;lt;!DOCTYPE html&amp;gt; document.firstchild.nextSibling; // 返回值为 &amp;lt;html&amp;gt; ... &amp;lt;/html&amp;gt;function getNextElementSibling(element) { var el = element; while (el = el.nextSibling) { if (el.nodeType === 1) { return el; } } return null; } 节点操作 方法 说明 document.createElement() 创建元素节点 document.createTextNode() 创建文本节点 document.createAttributeNode() 创建属性节点 appendChild() 在指定元素子节点的末尾追加节点 insertBefore() 在当前元素之前插入节点 getAttributeNode() 返回指定名称的属性节点 setAttributeNode() 设置或改变指定名称的属性 removeChild() 移出元素节点 removeAttributeNode() 移出属性节点 下面的例子比较重要，仔细看看var h2 = document.createElement(&#39;h2&#39;) // 创建标签名为h2的元素节点var text = document.createTextNode(&#39;hello javascript&#39;) // 创建文本内容为 &#39;hello javascript&#39; 的文本节点var attr = document.createAttributeNode(&#39;align&#39;) // 创建align的属性节点attr.value = &#39;center&#39; // 给属性节点赋值，必须要赋值h2.setAttributeNode(attr) // 为h2元素添加属性节点h2.appendChild(text) // 为h2添加文本节点document.body.appendChild(h2) // 在body中添加子元素h2（添加在所有子元素的末尾）这个时候获取h2，会看到document.getElementByTagName(&#39;h2&#39;)[0]; &amp;lt;h2 align=&quot;center&quot;&amp;gt;hello javasript&amp;lt;/h2&amp;gt;// 移出节点，首先找到节点，然后移出var child = document.getElementByTagName(&#39;li&#39;)[2]var attr = document.getAttributeNode(&#39;class&#39;)child.removeAttributeNode(attr)child.parentNode.removeChild(child) // 叫自己的爸爸干掉自己 ^_^&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt; &amp;lt;title&amp;gt;node&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;p name = &quot;pn&quot;&amp;gt;Hello&amp;lt;/p&amp;gt;&amp;lt;a id =&quot;aid&quot; title = &quot;这是一个标题属性&quot;&amp;gt;aid&amp;lt;/a&amp;gt;&amp;lt;a id =&quot;aid2&quot; &amp;gt;aid2&amp;lt;/a&amp;gt;&amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;1&amp;lt;/li&amp;gt;&amp;lt;li&amp;gt;2&amp;lt;/li&amp;gt;&amp;lt;li&amp;gt;3&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&amp;lt;div id = &quot;div&quot;&amp;gt; &amp;lt;p id=&quot;pid&quot;&amp;gt;div的p元素&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;script&amp;gt; function getName(){ var count = document.getElementByName(&quot;p&quot;); alert(count.length); var p = count[2]; p.innerHTML =&quot;world&quot;;} function getAttr(){ var anode =document.getElementById(&quot;aid&quot;); //根据id访问元素 var attr = anode.getAttribute(&quot;id&quot;); alert(attr); } function setAttr(){ var anode = document.getElementById(&quot;aid2&quot;); anode.setAttribute(&quot;title&quot;,&quot;这是一个设置的标题&quot;); //设置属性 var attr = anode.getAttribute(&quot;title&quot;); alert(attr); } function getChildNode(){ var childnode = document.getElementByTagName(&quot;ul&quot;)[0].childnode; // 获取子节点 alert(childnode.length) alert(childnode[0],nodeType) } function getPatentNode(){ var div = document.getElementById(&quot;pid&quot;);// 获取父节点 alert(div.parentNode.nodename); } function createNode(){ var body = docuemnt.body; var input = document.createElement(&quot;input&quot;); input.type = &quot;button&quot;; input.value=&quot;按钮&quot;; body.appendChild(input); //往末尾插入节点 } function addNode(){ var div =document.getElementById(&quot;div&quot;); var node=document.getElementById(&quot;pid&quot;); var newnode = document.createElement(&quot;p&quot;); newnode.innerHTML=&quot;动态添加第一个p元素&quot; div.insertBefore(newnode,node) // 在div下的node前面添加一个newnode } function removeNode(){ var div = document.getElementById(&quot;div&quot;); var p =div.removeChild(div.childNodes[1]); // 删除子节点 } function getSize(){ var width = document.body.offsetWidth; var height = document.body.offsetHeight; //获取元素body的尺寸 alert(width+&quot;,&quot;+height) } addNode(); removeNode(); getSize();&amp;lt;/script&amp;gt;节点的增删改查 增 删 改 查 appendChild removeChild 元素属性src，href，title等 传统 getElementsByTagName，getElementById等 insertBefore   修改普通元素属性 innerHtml，innerText等 推荐 querySelector，querySelectAll     修改表单元素 type，value，disable等 节点操作 parentNode，children，previousElementSibling     修改元素样式 style，className   3.事件​ 事件时JS与网页交互的桥梁。当事件发生时，可以通过JS代码执行相关操作。2.1 事件流​ JavaScript中，每当发生事件时，都会产生一个事件对象event，这个对象包含所有与事件相关的信息，如事件的DOM、事件类型以及与事件相关的参数。 事件流：描述的是页面中接收时间的顺序 事件冒泡：最具体的元素接收，然后逐级向上传播到最不具体的元素 事件捕获：最不具体的元素先接收事件，而最具体的节点最后接收事件2.2 事件监听 监听方式（IE 9 以后） 说明 addEventListener() 将某事件加入事件监听 removeEventListener() 将某事件移出事件监听 监听方式（IE 9 以前） 说明 attachEvent() 监听事件 detachEvent() 删除事件 // 【ie9以后的版本支持】eventTarget.addEventListener(type,listener)// type - 事件类型，如click，mouseover，所以这儿没有on的前缀[IE9 版本以上]// listener - 事件函数document.getElementById(&quot;btn&quot;).addEventListener(&quot;click&quot;,function(){ alert(&quot;hello&quot;) });document.getElementById(&quot;btn&quot;).removeEventListener(&quot;click&quot;,function(){ alert(&quot;hello&quot;) });// 【ie9以前的版本支持】 attachEvent ,这里有on的前缀btns[2].attachEvent(&#39;onclick&#39;, function() { alert(11);})btns[2].detachEvent(&#39;onclick&#39;, function() { alert(11);})// 为了兼容，一般写下面的方式进行判断function addListener(element,eventName,fn){ //首先判断浏览器是否支持addEventListener方法 if(element.addEventListener){ element.addEventListener(eventName,fn); }else if(element.attachEvent) { element.attachEvent(&#39;on&#39;+ eventName,fn); }else{ // 相当于element.onclick = fn element[&#39;on&#39;+eventName]=fn; }}// 同理，删除事件一般也这么写function removeListener(element,eventName,fn){ //首先判断浏览器是否支持addEventListener方法 if(element.removeEventListener){ element.removeEventListener(eventName,fn); }else if(element.detachEvent) { element.detachEvent(&#39;on&#39;+ eventName,fn); }else{ // 相当于element.onclick = fn element[&#39;on&#39;+eventName]=null; }}2.3 事件对象​ 事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象。​ 比如： 鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置。 键盘触发事件的话，会得到键盘的相关信息，如按了哪个键。​ 事件触发发生时就会产生事件对象，并且系统会以实参的形式传给事件处理函数。所以，在事件处理函数中声明1个形参用来接收事件对象。eventTatget.onclick = function(event){ // 这个event就是事件对象，通常写作e或者evt}eventTatget.addEventListener(&#39;click&#39;,function(event){ ... )}; ​ 在事件对象中，不同版本的写法不一样，要做到兼容，一般写作下面的格式 &amp;lt;div&amp;gt;123&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var div = document.querySelector(&#39;div&#39;); div.onclick = function(e) { // 事件对象,IE 6~8 中用window.event表示 e = e || window.event; console.log(e); } &amp;lt;/script&amp;gt; 事件对象的属性和方法 说明 e.target 返回触发事件的对象 e.type 返回事件类型，比如 click、mouseover e.preventDefault() 阻止默认事件，比如不让链接跳转 e.stopPropagation() 阻止冒泡 e.eventPhase 返回时间传播的当前阶段：1表示捕获阶段 ；2表示处于目标阶段；3表示冒泡阶段 e.srcElement 返回触发事件的对象【IE 6~8】 e.returnValue() 同e.preventDefault()【IE 6~8】 e.cancelBubble 同stopPropagation() 【IE6~8】 2.3.1 target与this​ 常规情况下terget 和 this是一致的，​ 但有一种情况不同，那就是在事件冒泡时（父子元素有相同事件，单击子元素，父元素的事件处理函数也会被触发执行），这时候this指向的是父元素，因为它是绑定事件的元素对象，而target指向的是子元素，因为他是触发事件的那个具体元素对象。&amp;lt;!-- target 和 this--&amp;gt; &amp;lt;div&amp;gt;123&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var div = document.querySelector(&#39;div&#39;); div.addEventListener(&#39;click&#39;, function(e) { // e.target 和 this指向的都是div console.log(e.target); console.log(this); }); &amp;lt;/script&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;abc&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;abc&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;abc&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;script&amp;gt; // * this - 绑定事件的元素 // * target - 触发事件的元素 var ul = document.querySelector(&#39;ul&#39;); ul.addEventListener(&#39;click&#39;, function(e) { // 我们给ul 绑定了事件 那么this 就指向ul console.log(this); // ul // e.target 触发了事件的对象 我们点击的是li e.target 指向的就是li console.log(e.target); // li }); &amp;lt;/script&amp;gt;2.3.2 阻止默认行为​ html中一些标签有默认行为，例如a标签被单击后，默认会进行页面跳转。 &amp;lt;a href=&quot;http://www.baidu.com&quot;&amp;gt;百度&amp;lt;/a&amp;gt; &amp;lt;script&amp;gt; // 2. 阻止默认行为 让链接不跳转 var a = document.querySelector(&#39;a&#39;); a.addEventListener(&#39;click&#39;, function(e) { e.preventDefault(); // dom 标准写法 }); // 3. 传统的注册方式 a.onclick = function(e) { // 普通浏览器 e.preventDefault(); 方法 e.preventDefault(); // 低版本浏览器 ie678 returnValue 属性 e.returnValue = false; // 我们可以利用return false 也能阻止默认行为 没有兼容性问题 return false; } &amp;lt;/script&amp;gt;2.3.3 阻止冒泡事件 &amp;lt;div class=&quot;father&quot;&amp;gt; &amp;lt;div class=&quot;son&quot;&amp;gt;son儿子&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var son = document.querySelector(&#39;.son&#39;); // 给son注册单击事件 son.addEventListener(&#39;click&#39;, function(e) { alert(&#39;son&#39;); if (e &amp;amp;&amp;amp; e.stopPropagation){ e.stopPropagation(); // stop 停止 Propagation 传播 }else{ window.event.cancelBubble = true; // 非标准 cancel 取消 bubble 泡泡 } }, false); var father = document.querySelector(&#39;.father&#39;); // 给father注册单击事件 father.addEventListener(&#39;click&#39;, function() { alert(&#39;father&#39;); }, false); // 给document注册单击事件 document.addEventListener(&#39;click&#39;, function() { alert(&#39;document&#39;); }) &amp;lt;/script&amp;gt;2.3.4 事件委托​ 事件冒泡本身的特性，会带来的坏处，也会带来的好处。阻止事件冒泡是为了防止冒泡产生的坏处，但是事件委托就是利用冒泡，实现其他的功能。​ 原理：给父元素注册事件，利用事件冒泡，当子元素的事件触发，会冒泡到父元素，然后去控制相应的子元素。 &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;知否知否，点我应有弹框在手！&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;知否知否，点我应有弹框在手！&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;知否知否，点我应有弹框在手！&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;知否知否，点我应有弹框在手！&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;知否知否，点我应有弹框在手！&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;script&amp;gt; // 事件委托的核心原理：给父节点添加侦听器， 利用事件冒泡影响每一个子节点 var ul = document.querySelector(&#39;ul&#39;); ul.addEventListener(&#39;click&#39;, function(e) { // e.target 这个可以得到我们点击的对象 e.target.style.backgroundColor = &#39;pink&#39;; }) &amp;lt;/script&amp;gt;2.4 事件分类​ 下面介绍的都是事件名称，使用的事件都要在前面加上on。如，load事件，使用的时候就要写成window.onload; click事件写成btn.onclick = function(){ ...} 2.4.1 页面事件 事件 事件触发时机 load 页面加载完毕后触发 unload 页面关闭时触发 【一般用于清除引用，防止内存泄露】 2.4.2 鼠标事件 焦点事件 事件触发时机 focus 当获得焦点时触发 【不会冒泡】 blur 当失去焦点时触发 【不会冒泡】 事件 事件触发时机 click 按下并释放 ** **任意鼠标按键时触发 dblclick 当鼠标双击时触发 mouseover 当鼠标进入时触发 mouseout 当鼠标离开时触发 mousedown 当按下鼠标时触发 mouseup 当按下鼠标后弹起时触发 change 当内容发生改变时触发，一般多用于select 位置属性（只读） 描述 clientX / pageX 鼠标指针位于当前浏览器页面窗口可视区的水平坐标 【X轴坐标】 后者不兼容旧版浏览器 clientY / pageY 鼠标指针位于当前浏览器页面窗口可视区的垂直坐标 【Y轴坐标】 后者不兼容旧版浏览器 screenX 鼠标位于屏幕的水平坐标 screenY 鼠标位于屏幕的垂直坐标 案例：跟随鼠标移动的天使 &amp;lt;img src=&quot;images/angel.gif&quot; alt=&quot;&quot;&amp;gt; &amp;lt;script&amp;gt; var pic = document.querySelector(&#39;img&#39;); document.addEventListener(&#39;mousemove&#39;, function(e) { // 1. mousemove只要我们鼠标移动1px 就会触发这个事件 // 2.核心原理： 每次鼠标移动，我们都会获得最新的鼠标坐标， // 把这个x和y坐标做为图片的top和left 值就可以移动图片 var x = e.pageX; var y = e.pageY; console.log(&#39;x坐标是&#39; + x, &#39;y坐标是&#39; + y); //3 . 千万不要忘记给left 和top 添加px 单位 pic.style.left = x - 50 + &#39;px&#39;; pic.style.top = y - 40 + &#39;px&#39;; }); &amp;lt;/script&amp;gt;2.3.3 键盘事件 事件 事件触发时机 keypress 键盘按键按下时触发 【shift、Fn、CapsLock除外】 keydown 键盘按键按下时触发 keyup 键盘按键弹起时触发 ​ 三个事件的执行顺序为 onkeydown -&amp;gt; onkeypress-&amp;gt;onkeyup &amp;lt;script&amp;gt; // 常用的键盘事件 //1. keyup 按键弹起的时候触发 document.addEventListener(&#39;keyup&#39;, function() { console.log(&#39;我弹起了&#39;); }) //3. keypress 按键按下的时候触发 不能识别功能键 比如 ctrl shift 左右箭头啊 document.addEventListener(&#39;keypress&#39;, function() { console.log(&#39;我按下了press&#39;); }) //2. keydown 按键按下的时候触发 能识别功能键 比如 ctrl shift 左右箭头啊 document.addEventListener(&#39;keydown&#39;, function() { console.log(&#39;我按下了down&#39;); }) // 4. 三个事件的执行顺序 keydown -- keypress -- keyup &amp;lt;/script&amp;gt; 属性 说明 keyCode 返回该键的ASCII值 &amp;lt;script&amp;gt; // 键盘事件对象中的keyCode属性可以得到相应键的ASCII码值 document.addEventListener(&#39;keyup&#39;, function(e) { console.log(&#39;up:&#39; + e.keyCode); // 我们可以利用keycode返回的ASCII码值来判断用户按下了那个键 if (e.keyCode === 65) { alert(&#39;您按下的a键&#39;); } else { alert(&#39;您没有按下a键&#39;) } }) document.addEventListener(&#39;keypress&#39;, function(e) { // console.log(e); console.log(&#39;press:&#39; + e.keyCode); }) &amp;lt;/script&amp;gt;2.4.4 表单事件 事件 事件触发时机 submit 当提交表单时触发 reset 当表单重置时触发 submit事件通常绑定在 form 标签上，用户单击submit按钮提交表单触发。" }, { "title": "JS基础概念", "url": "/posts/%E5%89%8D%E7%AB%AF-JS%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/", "categories": "前端", "tags": "前端JS", "date": "2021-05-09 00:00:00 +0800", "snippet": "1.概述​ JavaScript，就是我们通常所说的JS，是一种嵌入到HTML页面中的脚本语言，由浏览器一边解释一边执行。HTML只是一门描述性的语言，实际需求中单纯地使用HTML是无法实现的，而必须使用编程的方式来实现，那就必须使用JavaScript了。HTML、CSS和JavaScript的关系如下：HTML是网页的结构，CSS是网页的外观，而JavaScript是页面的行为2.数据类型1. 基本数据类型 基本数据类型 符号 布尔型 Boolean() 字符型 String() 数值型 Number() 空型 Null() 未定义型 Undefined 2. 引用数据类型 引用数据类型 符号 对象 Object 2.1 数组​ 数组是JS中最常用的数据类型之一，属于对象类型中的内置对象。用途：用来存储各种类型的变量，下标从0开始下标： [0] [1] [2] [3]值： &#39;beijing&#39; &#39;shanghai&#39; &#39;shenzhen&#39; &#39;guangzhou&#39;// 创建数组 new Array方法var area = new Array[&#39;beijing&#39;,&#39;shanghai&#39;,&#39;shenzhen&#39;,&#39;guangzhou&#39;];var score = new Array(56,65,23,45);var mix = new Array(123,&#39;acv&#39;,null,true,undefined);var arr1=new Array();// [] 方法var weather = [&#39;wind&#39;,&#39;fine&#39;];var empty = [];var mood = [&#39;sad&#39;,,,&#39;happy&#39;] // []可以存储空，而new Array不可以2.2 数组长度var arr1 = [78,88,98]console.log(arr1.length) //输出结果为3var arr2 = [&#39;a&#39;,,,,&#39;c&#39;]console.log(arr2.length) //输出结果为5// 数组长度设置var arr1 = []arr1.length = 5console.log(arr1) &amp;gt; (5) [empty × 5] //长度为5var arr2 = [1,2,3]arr2.length = 4console.log(arr2)&amp;gt;(4) [1, 2, 3, empty] //长度为4 缺失值补充为emptyvar arr3 = [1,2,3]arr3.length = 2console.log(arr3)&amp;gt;(2) [1, 2]//长度为2， 截取原数组前两个值2.3 访问数组// 下标取用var arr = [&#39;hello&#39;,&#39;js&#39;,224.25,true];console.log(arr[0])console.log(arr)// 遍历数组var navlist = [&#39;首页&#39;,&#39;免费资源&#39;,&#39;课程资源&#39;,&#39;IT学院&#39;];var str = &#39;&amp;lt;ul&amp;gt;&#39;;for (var i in arr){ str += &quot;&amp;lt;li&amp;gt;&amp;lt;a&amp;gt;&quot; + navlist[i] + &#39;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&#39;}str += &#39;&amp;lt;/ul&amp;gt;&#39;document.getElementById(&#39;navlist&#39;).innerHTML = str;2.4 元素增删改//增： 通过下标添加元素var height = [];height[0] = 185;height[1] = 156;height[5] = 189;console.log(height)// 删delete height[0];console.log(height)// 使用splice(n,m)删除任意位置后任意长度元素// n - 位置索引; m - 索引后长度// 如splice(3,2),即删除索引3开始，后两位数组元素height.splice(3,2)//改var student = [&#39;TOM&#39;,&#39;JACK&#39;,&#39;Lucy&#39;];student[0] = &#39;DING&#39;2.5 数组内置的方法 方法 说明 push() 将元素添加到数组末尾 unshift() 将元素添加到数组开头 pop() 将数组末尾的元素移除，返回值为移除的元素 shift() 将数组开头的元素移除，返回值为移除的元素 // push 返回值是新数组的长度&amp;gt; var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;]; fruit_length = fruits.push(&quot;Kiwi&quot;) console.log(fruits) console.log(fruit_length)&amp;gt; Banana,Orange,Apple,Mango,Kiwi 5// unshift 返回值是新数组的长度&amp;gt; var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;]; fruit_length = fruits.unshift(&quot;Lemon&quot;,&quot;Pineapple&quot;); console.log(fruits) console.log(fruit_length)&amp;gt; Lemon,Pineapple,Banana,Orange,Apple,Mango 6// pop返回值为移除的元素&amp;gt; var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;]; pop_element = fruits.pop(); console.log(fruits) console.log(pop_element)&amp;gt; [&#39;Banana&#39;, &#39;Orange&#39;, &#39;Apple&#39;] Mango// shift返回值为移除的元素 &amp;gt; var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;]; shift_element = fruits.shift(&quot;Lemon&quot;,&quot;Pineapple&quot;); console.log(fruits) console.log(shift_element)&amp;gt; [&#39;Orange&#39;, &#39;Apple&#39;, &#39;Mango&#39;] Banana2.6 数组检索 方法名称 功能 includes(xxxx) 确定数组中含有xxxx元素；有则true，无则false indexOf(xxxx) 数组中第一个值xxxx的索引；存在返回索引，不存在返回-1 lastIndexOf(xxxx) 数组中最后一个值xxxx的索引；存在返回索引，不存在返回-1 Array.isArray(xxxx) 用来确定xxxx是不是数组，是则true，否则false &amp;gt; var data =[&#39;peach&#39;,&#39;pear&#39;,26,&#39;26&#39;.&#39;grape&#39;]; console.log(data.includes(26,3))// 从下标为3的地方检索数值3 &amp;gt; false&amp;gt; var data =[&#39;peach&#39;,&#39;pear&#39;,26,&#39;26&#39;.&#39;grape&#39;]; console.log(data.includes(26,-3))// 从下标为(data.length - 3)的地方检索数值3 &amp;gt; true&amp;gt; console.log(Array.isArray(data)); // 判断data是否为数组&amp;gt; true2.7 数组转字符串 方法名称 功能 join() 将数组所有元素连接成为字符串，默认逗号连接，可设定连接符 toString() 组合所有字符，只能逗号分割 consolo.log([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;].join()); //输出 a,b,cconsolo.log([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;].join(&#39;-&#39;)); // 输出 a-b-cconsole.log([[1,2],[4,5]].toString()); //输出 1,2,4,5// 注意： 当数组元素为undefined，null，或空数组时，对象元素会被转换成为空字符串2.8 其他重要的方法 方法 说明 sort() 对数组元素排序，返回数组 fill()   reverse() 倒序排列数组元素 splice() 对数组指定下标范围内删除或添加元素 slice() 从原数组拷贝元素到新数组 concat() 合并多个数组 // sort&amp;gt; var data = [1,5,6,4,3,8] console.log(data.sort())&amp;gt;  [1, 3, 4, 5, 6, 8]// fill&amp;gt; var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;]; fruits.fill(&quot;Runoob&quot;);&amp;gt; [&#39;Runoob&#39;, &#39;Runoob&#39;, &#39;Runoob&#39;, &#39;Runoob&#39;]// reverse&amp;gt; var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;]; fruits.reverse();&amp;gt; [&#39;Mango&#39;, &#39;Apple&#39;, &#39;Orange&#39;, &#39;Banana&#39;]// splice&amp;gt; var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;]; console.log(fruits.splice(2,1)) // 从下标为2的地方开始，删除后面的1个元素 ，返回 [&#39;Apple&#39;]; console.log(fruits)&amp;gt; [&#39;Apple&#39;] [&#39;Banana&#39;, &#39;Orange&#39;, &#39;Mango&#39;]&amp;gt; fruits.splice(2,0,&#39;Apple&#39;,&#39;Grape&#39;) // 在下标为2的地方开始添加元素到数组 console.log(fruits)&amp;gt; [&#39;Banana&#39;, &#39;Orange&#39;, &#39;Apple&#39;, &#39;Grape&#39;, &#39;Mango&#39;]// slice&amp;gt; var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;]; console.log(fruits.slice(1,3)) // 取下标1到下标3的元素组成新数组&amp;gt;  [&#39;Orange&#39;, &#39;Apple&#39;]// concat&amp;gt; var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;]; var students = [&#39;Jack&#39;,&#39;Tom&#39;,&#39;Lucy&#39;] console.log(fruits.concat(students)) // 拼接两个数组组成新数组&amp;gt;  [&#39;Banana&#39;, &#39;Orange&#39;, &#39;Apple&#39;, &#39;Mango&#39;, &#39;Jack&#39;, &#39;Tom&#39;, &#39;Lucy&#39;]3. 数据类型检测​ JS中数据类型检测使用typeof操作符var num1 = 12,num2 = &quot;34&quot;,sum = 0;sum = num1 + num2 ;console.log(sum) ;&amp;gt; 1234 console.log( typeof(num1) ) // 输出: nunberconsole.log( typeof(num2) ) // 输出: stringconsole.log( typeof(num3) ) // 输出: string&amp;gt; typeof null&#39;object&#39;&amp;gt; NaN===NaNfalse​ 注意： 1. 使用typeof检测null时返回的是object，而不是null​ 2. JS中NaN是一个全局对象的属性；使用NaN==NaN比较时，不一定为true4. 类型转换​ 在上面第三小节的例子中，数值型的num1与字符型的num2相加，由于字符的存在，所有变量都是字符，所以结果是字符型1234。要实现正常的相加，可以转换数据类型，将字符型的num2转换为数值型。var num1 = 12,num2 = &quot;34&quot;,sum = 0;sum = num1 + Number(num2) ;console.log(sum) ;&amp;gt; 46 转布尔型 var con = prompt()console.log(Boolean(con)) 转数值型 Number() 方法parseInt() 方法parseFloat() 方法 // parseInt 第二个参数是进制转换，默认是10，即十进制转换&amp;gt; console.log(parseInt(&#39;F&#39;,16))15 待转数据 Number（） parseInt（） parseFloat（） 纯数字字符 &quot;1234&quot; 1234 1234 1234 数字开头 &quot;1234aa&quot; NaN 1234 1234 非数字开头 &quot;aa1234&quot; NaN NaN NaN undefined NaN NaN NaN 空字符 &quot; &quot; 0 NaN NaN null 0 NaN NaN false 0 NaN NaN true 1 NaN NaN 转字符型 ​ JS转字符型提供两种方法 String 方法和toString 方法 // String 方法&amp;gt; var num = 20;&amp;gt; console.log(String(num))20 // toString 方法// toString()提供进制转换参数。默认是10，即十进制// 示例中先把数字转换为二进制，再转换为字符&amp;gt; var num1 = 20;&amp;gt; console.log(num1.toString(2)) 11010 注意： null 和 undefined没有toString 方法 3.运算符3.1 算术运算符 运算符 运算 示例 结果 + 加 5+5 10 - 减 5-5 0 * 乘 5*5 25 / 除 3/2 1.5 % 取余 3%2 1 ** 幂运算 3**2 9 ++ 自增（前置) a=2; b=++a; a=3;b=3 ++ 自增（后置) a=2; b=a++; a=3;b=2 – 自减（前置） a=2; b=–a; a=1;b=1 – 自减（后置） a=2; b=a–; a=1;b=2 注意： 取余（取模）运算时，符号取决于左边那个数的符号(-8)%7=-1、8%(-7)=1 JS对小数有偏差，1.66+1.77=3.429999999999999，建议将小数转换为整数运算(1.66*100+1.77*100 )/100=3.43 自增自减只对数值类型（Number）和布尔型（Boolen）有效 // true的值为1，false的值为0&amp;gt; var a = true&amp;gt; a++1&amp;gt; a++2 3.2 字符串运算符​ 字符串运算符+，当变量或值与字符串进行+运算，变量或值就会被自动转换为字符型，与字符串进行拼接var num1 = 12,num2 = &quot;34&quot;;sum = num1 + num2 ;console.log(sum) ;&amp;gt; 12343.3 赋值运算符 运算符 运算 示例 结果 = 赋值 a=2;b=3 a=2;b=3 += 加并赋值 a=3;b=2;a+=b a=5;b=2 -= 减并赋值 a=3;b=2;a-=b a=1;b=2 *=       /=       %=       += 连接并赋值 a=’abc’;a+=’def’ a=’abcdef’ **=       «= 左移位运算 a=9；b=2;a«=b a=36;b=2 »= 右移位运算 a=-9;b=2;a»=b a=-3;b=2 »&amp;gt;= 无符号右移位运算     &amp;amp;= 按位与赋值     ^= 按位异或赋值     != 按位或赋值     ​ 位运算见3.73.4 比较运算符 运算符 运算 示例(x=5) 结果 == 等于 x==4 false != 不等于 x!=4 true === 全等于（类型和数据都相等） x===5 true !== 不全等 x!==’5’ true &amp;gt; 大于 x&amp;gt;5 false &amp;lt; 小于 x&amp;lt;5 false &amp;gt;= 小于等于 x&amp;lt;=5 true &amp;lt;= 大于等于 x&amp;gt;=5 true 3.5 逻辑运算符 运算符 运算 示例 结果 &amp;amp;&amp;amp; 与 a&amp;amp;&amp;amp;b a,b均为true，结果为true，否则false || 或 a||b a,b至少一个为true，结果为true，否则false ！ 非 !a a为false，结果为true，否则false 3.6 三元运算符// 格式条件表达式 ? 表达式1 ：表达式2// 示例var age = prompt(&quot;请输入需要判断的年龄：&quot;)var status=age &amp;gt; 18? &#39;已成年&#39;:&#39;未成年&#39;console.log(status)3.7 位运算​ 位运算时将数字转换成为二进制，后对二进制数据的每一位进行运算。JS将每个数字解析成为二进制的32位的串// 与运算,计算15&amp;amp;9的结果15 --- 1111; 9 ---1011 00000000 00000000 00000000 00001111&amp;amp; 00000000 00000000 00000000 00001001-------------------------------------------- 00000000 00000000 00000000 00001001结果为9// 或运算,计算 15|9 的结果 00000000 00000000 00000000 00001111| 00000000 00000000 00000000 00001001-------------------------------------------- 00000000 00000000 00000000 00001111结果为15// 非运算,计算 ~15 的结果~ 00000000 00000000 00000000 00001111-------------------------------------------- 11111111 11111111 11111111 11110000结果为-16（第一个数字为1，则为负号；后对数据【取反+1添负号】）// 异或运算,计算 15^9 的结果 00000000 00000000 00000000 00001111| 00000000 00000000 00000000 00001001-------------------------------------------- 00000000 00000000 00000000 00000110结果是6// 左移位运算，计算 9&amp;lt;&amp;lt;2 结果00000000 00000000 00000000 00001001 &amp;lt;&amp;lt;2--------------------------------------------00000000 00000000 00000000 00100100结果是36// 右移位运算，计算 9&amp;gt;&amp;gt;2 结果00000000 00000000 00000000 00001001 &amp;lt;&amp;lt;2--------------------------------------------00000000 00000000 00000000 00000010结果是2//无符号右移位 计算9右移动两位00000000 00000000 00000000 00001001 &amp;lt;&amp;lt;2--------------------------------------------00000000 00000000 00000000 00000010结果是24.变量使用1.变量名 语句末尾必须加分号； 定义变量用var,变量名称 小写字母、大写字母，特殊符号 数字不能放在变量前 变量与函数库不能重名&amp;lt;script&amp;gt; var kaopu = &quot;靠谱学院&quot;; alert(kaopu)&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; var number = 100; number = number+200; document.write(&quot;&amp;lt;h1&amp;gt;&quot;+ number + &quot;&amp;lt;h1&amp;gt;&quot;)&amp;lt;/script&amp;gt; 进行弹框输入&amp;lt;script&amp;gt; var name = prompt(&quot;你的名字是&quot;，&quot;&quot;) document.write(&quot;&amp;lt;h1&amp;gt;&quot;+ name+ &quot;&amp;lt;h1&amp;gt;&quot;)&amp;lt;/script&amp;gt; 5.条件判断if - else&amp;lt;script&amp;gt;var pwd = prompt(&quot;请输入您的密码&quot;,&quot;&quot;);if (pwd==&quot;123456&quot;){ document.write(&quot;登录成功&quot;)}else{ document.write(&quot;登录失败&quot;)}&amp;lt;/script&amp;gt; if - else if&amp;lt;script&amp;gt;var number = prompt(&quot;请输入一个数字（1-100）&quot;,&quot;&quot;);if (number==50){ document.write(&quot;恭喜您答对了&quot;)}else if(number&amp;lt;50){ document.write(&quot;您猜的数字小了点，换个大的&quot;)} else (number&amp;gt;50){ document.write(&quot;您猜的数字大了点，换个小的&quot;)}&amp;lt;/script&amp;gt; 6.while 循环// whilevar pwd = prompt(&quot;请输入您的密码&quot;,&quot;&quot;); if (pwd == &#39;123456&#39;){ document.write(&quot;登录成功&quot;)}while(!==&quot;123456&quot;){ pwd = document.write(&quot;密码输入错误，请重新输入&quot;,&quot;&quot;) }// do whilenum = 5;do { console.log(num); num--;}while(num&amp;gt;3);7.for 循环var num = 1;while (num&amp;lt;=10){ document.write(num+&quot;&amp;lt;br&amp;gt;&quot;) num = num + 1}for (var num = 1; num &amp;lt;=10 ; num++){ document.write(num+&quot;&amp;lt;br&amp;gt;&quot;);}8.跳出break 直接跳出当前循环，不再进行下一次循环continue 跳出本次循环，执行下一次循环for (var i=0; i&amp;lt;10;i++){ if (i==5){ break; }}9.函数函数的使用只需要2步：（1）定义函数；（2）调用函数function 函数名(参数1,参数2,….,参数n){ //函数体语句}&amp;lt;script&amp;gt; function demo(a,b){ var sum = a+b; return sum; } var a1 = 10; var a2 = 20; var v1 = demo(a1,a2);&amp;lt;/script&amp;gt;函数可以使用return语句将某个值返回，也可以没有返回值。参数是可选的，可以不带参数，也可以带多个参数。如果是多个参数的话，参数之间要用英文逗号隔开。函数调用： script中调用 html中调用 &amp;lt;body&amp;gt; &amp;lt;script&amp;gt; function demo(a,b){ var sum = a+b; return sum; } &amp;lt;/script&amp;gt; &amp;lt;button&amp;gt; onclick =&quot;demo(10,20)&quot;&amp;gt; 按钮&amp;lt;/button&amp;gt; &amp;lt;/body&amp;gt; 全局变量和局部变量&amp;lt;script&amp;gt; var n =10 ; m =10; //全局变量，位于function外面 function demo(){ var i = 10; //局部变量，运用该函数，局部变量生效 x = 100 // 全局变量，需要等function执行后才能为全局变量 }&amp;lt;/script&amp;gt;异常处理&amp;lt;script&amp;gt;function demo(){ var str = &quot;hello&quot; try{ alert(str) } catch (err){ alert(str) }}&amp;lt;/script&amp;gt;自定义异常&amp;lt;script&amp;gt; try{ var e = document.getElementById(&quot;txt&quot;).values; if (e==&quot;&quot;){ throw(&quot;第一个用户输入异常==空&quot;); } }catch (err){ alert(err) } }&amp;lt;/script&amp;gt;##" }, { "title": "CSS高级技巧", "url": "/posts/%E5%89%8D%E7%AB%AF-CSS%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/", "categories": "前端", "tags": "前端CSS", "date": "2021-05-08 00:00:00 +0800", "snippet": "1.概述​ 在实战中，CSS中有一些技巧，用来解决常见场景中的问题。2.元素显示与隐藏​ 目标：让一个元素在页面中消失或者显示出来​ 场景：类似网站广告，当我们点击关闭就不见了，但是我们重新刷新页面，会重新出现！ 属性 区别 用途 display 隐藏对象，不保留位置 配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛 visibility 隐藏对象，保留位置 使用较少 overflow 只是隐藏超出大小的部分 1. 可以清除浮动 2. 保证盒子里面的内容不会超出该盒子范围 2.1 display 显示（重点）/* 隐藏对象 */display: none/* 除了转换为块级元素之外，同时还有显示元素的意思 */display：block 特点： 隐藏之后，不再保留位置。实际开发场景：配合后面js做特效，比如下拉菜单，原先没有，鼠标经过显示下拉菜单， 应用极为广泛2.2 visibility 可见性 (了解) 设置或检索是否显示对象。 /* 对象可视 */visibility：visible ; 　/* 对象隐藏 */visibility：hidden; 　 特点： 隐藏之后，继续保留原有位置。（停职留薪） 2.3 overflow 溢出(重点) 检索或设置当对象的内容超过其指定高度及宽度时，如何管理内容。 属性值 描述 visible 不剪切内容也不添加滚动条 hidden 不显示超过对象尺寸的内容，超出的部分隐藏掉 scroll 不管超出内容否，总是显示滚动条 auto 超出自动显示滚动条，不超出不显示滚动条 实际开发场景： 清除浮动 隐藏超出内容，隐藏掉, 不允许内容超过父盒子。3. CSS用户界面样式​ 目标：所谓的界面样式， 就是更改一些用户操作样式，以便提高更好的用户体验。 更改用户的鼠标样式 (滚动条因为兼容性非常差，我们不研究) 表单轮廓等 防止表单域拖拽 属性 用途 用途 鼠标样式 更改鼠标样式cursor 样式很多，重点记住 pointer 轮廓线 表单默认outline outline 轮廓线，我们一般直接去掉，border是边框，我们会经常用 防止拖拽 主要针对文本域resize 防止用户随意拖拽文本域，造成页面布局混乱，我们resize:none 3.1 cursor 鼠标样式设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。 属性值 描述 default 小白 默认 pointer 小手 move 移动 text 文本 not-allowed 禁止 鼠标放我身上查看效果哦：&amp;lt;ul&amp;gt; &amp;lt;li style=&quot;cursor:default&quot;&amp;gt;我是小白&amp;lt;/li&amp;gt; &amp;lt;li style=&quot;cursor:pointer&quot;&amp;gt;我是小手&amp;lt;/li&amp;gt; &amp;lt;li style=&quot;cursor:move&quot;&amp;gt;我是移动&amp;lt;/li&amp;gt; &amp;lt;li style=&quot;cursor:text&quot;&amp;gt;我是文本&amp;lt;/li&amp;gt; &amp;lt;li style=&quot;cursor:not-allowed&quot;&amp;gt;我是文本&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;3.2 outline 轮廓线 轮廓线是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。 outline : outline-color ||outline-style || outline-width 但是我们都不关心可以设置多少，我们平时都是去掉的。最直接的写法是 ： outline: 0; 或者 outline: none; &amp;lt;input type=&quot;text&quot; style=&quot;outline: 0;&quot;/&amp;gt;3.3 resize 防止拖拽文本域实际开发中，我们文本域右下角是不可以拖拽：&amp;lt;textarea style=&quot;resize: none;&quot;&amp;gt;&amp;lt;/textarea&amp;gt;4.垂直对齐​ 在介绍文本样式和盒子模型的时候，有水平对齐的概念：1. 有宽度的块级元素居中对齐，是margin: 0 auto;2. 让文字居中对齐，是 text-align: center;​ 但是，我们从来没有讲过有垂直居中的属性。​ vertical-align 垂直对齐，它只针对于行内元素或者行内块元素。vertical-align : baseline |top |middle |bottom 设置或检索对象内容的垂直对其方式。 注意： vertical-align 不影响块级元素中的内容对齐，它只针对于行内元素或者行内块元素， 特别是行内块元素， 通常用来控制图片/表单与文字的对齐。 4.1 图片、表单和文字对齐​ 我们知道，可以通过vertical-align 控制图片和文字的垂直关系，默认的图片会和文字基线对齐。 模式 说明 设置 基线对齐 默认文字和图片的基线对齐 vertical-align:baseline; 垂直居中 默认文字和图片的中线对齐 vertical-align:middle; 顶部对齐 默认文字和图片的顶线对齐 vertical-align:top; 4.2 去除图片底部空白间隙 原因： 图片或者表单等行内块元素，他的底线会和父级盒子的基线对齐。在基线和底线之间还有一段未被填满，就是图片底侧的空白缝隙。 解决方法： 给img vertical-align:middle | top| bottom等等， 让图片不要和基线对齐 给img 添加 display：block;， 转换为块级元素就不会存在问题了 5. 溢出的文字省略号显示5.1 white-space​ white-space设置或检索对象内文本显示方式，通常我们使用于强制一行显示内容 。/* 默认处理方式 */white-space:normal ;/* 强制在同一行内显示所有文本，直到文本结束或者遭遇br标签对象才换行*/white-space:nowrap ;　5.2 text-overflow 文字溢出​ 设置或检索是否使用一个省略标记（…）标示对象内文本的溢出/* 不显示省略标记（...），而是简单的裁切 */text-overflow : clip ;/* 当对象内文本溢出时显示省略标记（...）*/text-overflow：ellipsis ;注意：​ 一定要首先强制一行内显示，再次和overflow属性 搭配使用5.3 一条龙 /*1. 先强制一行内显示文本*/ white-space: nowrap; /*2. 超出的部分隐藏*/ overflow: hidden; /*3. 文字用省略号替代超出的部分*/ text-overflow: ellipsis;6. 精灵技术​ 一个网页中往往会应用很多小的背景图像作为修饰。当网页中的图像过多时，服务器就会频繁地接受和发送请求，这将大大降低页面的加载速度。​ 为了有效地减少服务器接受和发送请求的次数，提高页面的加载速度，CSS精灵技术（也称CSS Sprites、CSS雪碧）应运而生。6.1 精灵技术讲解​ CSS 精灵是将网页中的一些背景图像整合到一张大图（精灵图）中。​ 各个网页元素通常只需要精灵图中不同位置的某个小图，所以精灵技术就是要精确定位到精灵图中的某个小图。这样，当用户访问该页面时，只需向服务发送一次请求，网页中的背景图像即可全部展示出来。我们需要使用CSS： background-image background-repeat background-position属性进行背景定位， 其中最关键的是使用background-position 属性精确地定位。6.2 核心总结​ CSS精灵技术主要针对于背景图片，插入的图片img 是不需要这个技术的。​ CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），那我们要做的，就是把小图拼合成一张大图。大部分情况下，精灵图都是网页美工做。​ 结束语：小公司，背景图片很少的情况，没有必要使用精灵技术，维护成本太高。 如果是背景图片比较多，可以建议使用精灵技术。" }, { "title": "CSS浮动与定位", "url": "/posts/%E5%89%8D%E7%AB%AF-CSS%E6%B5%AE%E5%8A%A8%E4%B8%8E%E5%AE%9A%E4%BD%8D/", "categories": "前端", "tags": "前端CSS", "date": "2021-05-07 00:00:00 +0800", "snippet": "1.浮动​ 网页布局的核心就是用 CSS 来摆放盒子。​ CSS 提供了 3 种机制来设置盒子的摆放位置，分别是普通流（标准流）、浮动和定位 三种机制 说明 普通流 块级元素会独占一行，从上向下顺序排列；行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行 浮动 让盒子从普通流中浮起来,主要作用让多个块级盒子一行显示 定位 将盒子定在浏览器的某一个位置（CSS 离不开定位，特别是后面的 js 特效） 1.1 浮动的诞生我们首先要思考以下2个布局中最常见的问题？ 如何让多个盒子(div)水平排列成一行？ 如何实现盒子的左右对齐？ 行内块（inline-block）的缺陷： 它可以实现多个元素一行显示，但是中间会有空白缝隙，不能满足以上第一个问题 它不能实现以上第二个问题，盒子左右对齐因为一些网页布局要求，标准流不能满足我们的需要了，因此我们需要浮动来完成网页布局。1.2 浮动简介​ 元素的浮动是指设置了浮动属性的元素：1. 脱离标准普通流的控制、2.移动到指定位置选择器 { float: 属性值;} 属性值 描述 none 元素不浮动（默认值） left 元素向左浮动 right 元素向右浮动 ​ 浮动——漂浮在普通流的上面。 脱离标准流， 俗称 “脱标” 。.box1 { width: 200px; height: 200px; background-color: rgba(255, 0, 0, 0.5); float: left;}.box2 { width: 150px; height: 300px; background-color: skyblue;} float 属性会让盒子漂浮在标准流的上面，所以第二个标准流的盒子跑到浮动盒子的底下了 浮动的盒子，把自己原来的位置漏给下面标准流的盒子，就是不占有原来位置 任何元素都可以浮动。浮动元素会生成一个块级框(可以操作间距、大小等属性) 特点 说明 浮 加了浮动的盒子是浮起来的，漂浮在其他标准流盒子的上面。 漏 加了浮动的盒子是不占位置的，它原来的位置漏给了标准流的盒子。 特 特别注意：浮动元素会改变display属性， 类似转换为了行内块，但是元素之间没有空白缝隙 1.3 浮动的扩展1). 浮动元素与父盒子的关系 子盒子的浮动参照父盒子对齐 不会与父盒子的边框重叠，也不会超过父盒子的内边距2). 浮动元素与兄弟盒子的关系在同一个父级盒子中，如果前一个兄弟盒子是： 浮动的，那么当前盒子会与前一个盒子的顶部对齐； 普通流的，那么当前盒子会显示在前一个兄弟盒子的下方相当重要的一句话：浮动只会影响当前的或者是后面的标准流盒子，不会影响前面的标准流建议：如果一个盒子里面有多个子盒子，如果其中一个盒子浮动了，其他兄弟也应该浮动。防止引起问题**2.清除浮动2.1 清除浮动的原因​ 父级盒子很多情况下不方便给高度，这样，父盒子的高度就由子盒子撑起来。然而，子盒子浮动之后就不占有位置，导致父级盒子高度为0，影响下面的标准流盒子。本质： 清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。清除浮动之后， 父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了2.2 清除浮动的方法​ 在CSS中，clear属性用于清除浮动。选择器 { clear:属性值;} 属性值 描述 left 不允许左侧有浮动元素（清除左侧浮动的影响） right 不允许右侧有浮动元素（清除右侧浮动的影响） both 同时清除左右两侧浮动的影响 但是我们实际工作中， 几乎只用 clear: both;1). 父级添加overflow属性方法可以给父级添加： overflow为 hidden| auto| scroll 都可以实现。优点： 代码简洁缺点： 内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。2). 使用after伪元素清除浮动:after 方式为空元素额外标签法的升级版，好处是不用单独加标签了使用方法： .clearfix:after { content: &quot;&quot;; display: block; height: 0; clear: both; visibility: hidden; } .clearfix {*zoom: 1;} /* IE6、7 专有 */ 优点： 符合闭合浮动思想 结构语义化正确 缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。 代表网站： 百度、淘宝网、网易等3). 使用双伪元素清除浮动使用方法：.clearfix:before,.clearfix:after { content:&quot;&quot;; display:table; }.clearfix:after { clear:both;}.clearfix { *zoom:1;} 优点： 代码更简洁 缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。 代表网站： 小米、腾讯等4). 额外标签法(隔墙法)是W3C推荐的做法是通过在浮动元素末尾添加一个空的标签例如 &amp;lt;div style=”clear:both”&amp;gt;&amp;lt;/div&amp;gt;，或则其他标签br等亦可。 优点： 通俗易懂，书写方便 缺点： 添加许多无意义的标签，结构化较差。2.3 清除浮动总结pink老师告诉你我们以后什么时候用清除浮动呢？ 父级没高度 子盒子浮动了 影响下面布局了，我们就应该清除浮动了。 清除浮动的方式 优点 缺点 额外标签法（隔墙法） 通俗易懂，书写方便 添加许多无意义的标签，结构化较差。 父级overflow:hidden; 书写简单 溢出隐藏 父级after伪元素 结构语义化正确 由于IE6-7不支持:after，兼容性问题 父级双伪元素 结构语义化正确 由于IE6-7不支持:after，兼容性问题 后面两种伪元素清除浮动，大家暂且会使用就好， 深入原理，我们后面学完伪元素再讲。3.定位​ 定位即将盒子定在某一个位置 ，自由的漂浮在其他盒子(包括标准流和浮动)的上面 。所以，我们脑海应该有三种布局机制的上下顺序:标准流在最底层 (海底) ------- 浮动 的盒子 在 中间层 (海面) ------- 定位的盒子 在 最上层 （天空）定位也是用来布局的，它有两部分组成：定位 = 定位模式 + 边偏移3.1 边偏移​ 简单说， 我们定位的盒子，是通过边偏移来移动位置的。在 CSS 中，通过 top、bottom、left 和 right 属性定义元素的边偏移：（方位名词） 边偏移属性 示例 描述 top top: 80px 顶端偏移量，定义元素相对于其父元素上边线的距离。 bottom bottom: 80px 底部偏移量，定义元素相对于其父元素下边线的距离。 left left: 80px 左侧偏移量，定义元素相对于其父元素左边线的距离。 right right: 80px 右侧偏移量，定义元素相对于其父元素右边线的距离 定位的盒子有了边偏移才有价值。 一般情况下，凡是有定位地方必定有边偏移。3.2 定位模式 (position)在 CSS 中，通过 position 属性定义元素的定位模式，语法如下：选择器 { position: 属性值; }定位模式是有不同分类的，在不同情况下，我们用到不同的定位模式。 值 语义 static 静态定位 relative 相对定位 absolute 绝对定位 fixed 固定定位 1）静态定位(static) - 了解 静态定位是元素的默认定位方式，无定位的意思。它相当于 border 里面的none， 不要定位的时候用。 静态定位 按照标准流特性摆放位置，它没有边偏移。 静态定位在布局时我们几乎不用的2）相对定位(relative) - 重要​ 相对定位是元素相对于它 原来在标准流中的位置 来说的。（自恋型）效果图：相对定位的特点：（务必记住） 相对于 自己原来在标准流中位置来移动的 原来在标准流的区域继续占有，后面的盒子仍然以标准流的方式对待它。（区别：浮动就不占用以前的位置）3）绝对定位(absolute) - 重要​ 绝对定位是元素以带有定位的父级元素来移动位置 （拼爹型） 完全脱标 —— 完全不占位置 父元素没有定位，则以浏览器为准定位（Document 文档）。 父元素要有定位 将元素依据最近的已经定位（绝对、固定或相对定位）的父元素（祖先）进行定位。绝对定位的特点：（务必记住） 绝对是以带有定位的父级元素来移动位置 （拼爹型）。** 如果父级都没有定位，则以浏览器文档为准移动位置** 不保留原来的位置，完全是脱标的。（区别：相对定位不脱标，绝对定位脱标）用法：​ 因为绝对定位的盒子是拼爹的，所以要和父级搭配一起来使用。​ 定位口诀 —— 子绝父相，即子级是绝对定位，父级要用相对定位。疑问：为什么在布局时，子级元素使用绝对定位时，父级元素就要用相对定位呢？​ 观察下图，思考一下在布局时，左右两个方向的箭头图片以及父级盒子的定位方式。分析： 方向箭头叠加在其他图片上方，应该使用绝对定位，因为绝对定位完全脱标，完全不占位置。 父级盒子应该使用相对定位，因为相对定位不脱标，后续盒子仍然以标准流的方式对待它。 如果父级盒子也使用绝对定位，会完全脱标，那么下方的广告盒子会上移，这显然不是我们想要的。 结论：父级要占有位置，子级要任意摆放，这就是子绝父相的由来。4）固定定位(fixed) - 重要固定定位是绝对定位的一种特殊形式： 完全脱标 —— 完全不占位置； 只认浏览器的可视窗口 —— 浏览器可视窗口 + 边偏移属性 来设置元素的位置；&amp;gt; 固定定位跟父元素没有任何关系，单独使用的&amp;gt; 不随滚动条滚动提示：IE 6 等低版本浏览器不支持固定定位。3.3 定位扩展1） 绝对定位的盒子居中​ 注意：绝对定位/固定定位的盒子不能通过设置 margin: auto 设置水平居中**。在使用绝对定位时要想实现水平居中，可以按照下图的方法： left: 50%;：让盒子的左侧移动到父级元素的水平中心位置； margin-left: -100px;：让盒子向左移动自身宽度的一半。盒子居中定位示意图2） 堆叠顺序（z-index）​ 在使用定位布局时，可能会出现盒子重叠的情况。加了定位的盒子，默认后来者居上， 后面的盒子会压住前面的盒子。应用 z-index 层叠等级属性可以调整盒子的堆叠顺序。如下图所示：z-index 的特性如下： 属性值：正整数、负整数或 0，默认值是 0，数值越大，盒子越靠上； 如果属性值相同，则按照书写顺序，后来居上； 数字后面不能加单位。注意：z-index 只能应用于相对定位、绝对定位和固定定位的元素，其他标准流、浮动和静态定位无效。3） 定位改变display属性前面我们讲过， display 是 显示模式， 可以改变显示模式有以下方式: 可以用inline-block 转换为行内块 可以用浮动 float 默认转换为行内块（类似，并不完全一样，因为浮动是脱标的） 绝对定位和固定定位也和浮动类似， 默认转换的特性 转换为行内块。所以说， 一个行内的盒子，如果加了浮动、固定定位和绝对定位，不用转换，就可以给这个盒子直接设置宽度和高度等。同时注意：​ 浮动元素、绝对定位(固定定位）元素的都不会触发外边距合并的问题。 （我们以前是用padding border overflow解决的）​ 也就是说，我们给盒子改为了浮动或者定位，就不会有垂直外边距合并的问题了。3.4 定位小结 定位模式 是否脱标占有位置 移动位置基准 模式转换（行内块） 使用情况 静态static 不脱标，正常模式 正常模式 不能 几乎不用 相对定位relative 不脱标，占有位置 相对自身位置移动 不能 基本单独使用 绝对定位absolute 完全脱标，不占有位置 相对于定位父级移动位置 能 要和定位父级元素搭配使用 固定定位fixed 完全脱标，不占有位置 相对于浏览器移动位置 能 单独使用，不需要父级 注意： 边偏移需要和定位模式联合使用，单独使用无效； top 和 bottom 不要同时使用； left 和 right 不要同时使用。4.网页布局总结​ 一个完整的网页，有标准流 、 浮动 、 定位 一起完成布局的。每个都有自己的专门用法。1). 标准流​ 可以让盒子上下排列 或者 左右排列的2). 浮动​ 可以让多个块级元素一行显示 或者 左右对齐盒子 浮动的盒子就是按照顺序左右排列3). 定位​ 定位最大的特点是有层叠的概念，就是可以让多个盒子 前后 叠压来显示。 但是每个盒子需要测量数值。" }, { "title": "CSS标签显示模式与盒子模型", "url": "/posts/%E5%89%8D%E7%AB%AF-CSS%E6%A0%87%E7%AD%BE%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F%E4%B8%8E%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/", "categories": "前端", "tags": "前端CSS", "date": "2021-05-06 00:00:00 +0800", "snippet": "1.标签显示模式​ 标签显示模式是指标签以什么方式进行显示，比如div 自己占一行， 比如span 一行可以放很多个。​ HTML标签一般分为块标签和行内标签两种类型，它们也称块元素和行内元素。 元素模式 元素排列 设置样式 默认宽度 包含 块级元素 一行只能放一个块级元素 可以设置宽度高度 容器的100% 容器级可以包含任何标签 行内元素 一行可以放多个行内元素 不可以直接设置宽度高度 它本身内容的宽度 容纳文本或则其他行内元素 行内块元素 一行放多个行内块元素 可以设置宽度和高度 它本身内容的宽度   1.1 块级元素（block-level）​ 块级元素特点：（1）比较霸道，自己独占一行（2）高度，宽度、外边距以及内边距都可以控制。（3）宽度默认是容器（父级宽度）的100%（4）是一个容器及盒子，里面可以放行内或者块级元素。/*常见的块元素*/&amp;lt;h1&amp;gt;~&amp;lt;h6&amp;gt;、&amp;lt;p&amp;gt;、&amp;lt;div&amp;gt;、&amp;lt;ul&amp;gt;、&amp;lt;ol&amp;gt;、&amp;lt;li&amp;gt;其中： &amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;内部不能放块级元素，尤其是不能放div h1,h2,h3,h4,h5,h6,dt内部不能放其他块级元素1.2 行内元素（inline-level)​ 行内元素的特点：​ （1）相邻行内元素在一行上，一行可以显示多个​ （2）高、宽直接设置是无效的​ （3）默认宽度就是它本身内容的宽度​ （4）行内元素只能容纳文本或则其他行内元素其中： 链接里面不能再放链接。 特殊情况a里面可以放块级元素，但是给a转换一下块级模式最安全。 1.3 行内块元素（inline-block）​ 在行内元素中有几个特殊的标签——&amp;lt;img /&amp;gt;、&amp;lt;input /&amp;gt;、&amp;lt;td&amp;gt;，可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块元素。行内块元素的特点：（1）和相邻行内元素（行内块）在一行上,但是之间会有空白缝隙。一行可以显示多个（2）默认宽度就是它本身内容的宽度。（3）高度，行高、外边距以及内边距都可以控制。2.盒子模型​ 所谓盒子模型，就是把HTML页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器。​ 盒子模型有元素的内容(content)、边框（border）、内边距（padding）、和外边距（margin）组成。 内容区域：盒子里面的文字和图片等元素是 边框 ：盒子的厚度 内边距：盒子内容与边框的距离（类似单元格的 cellpadding) 外边距：盒子与盒子之间的距离（类似单元格的 cellspacing）2.1 盒子边框（border）border : border-width || border-style || border-color border: 1px solid red; /* 没有顺序 */ 属性 作用 border-width 定义边框粗细，单位是px border-style 边框的样式 border-color 边框颜色 边框的样式border-style ： none：没有边框即忽略所有边框的宽度（默认值） solid：边框为单实线(最为常用的) dashed：边框为虚线 dotted：边框为点线 当需要单独指定边框的属性时，可以使用下面的属性设定 上边框 下边框 左边框 右边框 border-top-style:样式; border-bottom-style:样式; border-left-style:样式; border-right-style:样式; border-top-width:宽度; border- bottom-width:宽度; border-left-width:宽度; border-right-width:宽度; border-top-color:颜色; border- bottom-color:颜色; border-left-color:颜色; border-right-color:颜色; border-top:宽度 样式 颜色; border-bottom:宽度 样式 颜色; border-left:宽度 样式 颜色; border-right:宽度 样式 颜色; 2.2 圆角边框border-radius:length; /* 其中每一个值可以为 数值或百分比的形式。 技巧： 让一个正方形 变成圆圈 */border-radius: 50%;2.3 表格边框​ 着重说明表格的边框，实用性很强。在设定两个单元格之间的边框时，会出现重叠，从而使边框变粗，需要通过CSS来解决。/* - collapse 单词是合并的意思- border-collapse:collapse; 表示相邻边框合并在一起。*/table { border-collapse:collapse; } &amp;lt;style&amp;gt; table { width: 500px; height: 300px; border: 1px solid red; } td { border: 1px solid red; text-align: center; } table, td { border-collapse: collapse; /*合并相邻边框*/ }&amp;lt;/style&amp;gt;合并前：合并后：2.4 内边距（padding）​ padding属性用于设置内边距， 指 边框与内容之间的距离。 属性 作用 padding-left 左内边距 padding-right 右内边距 padding-top 上内边距 padding-bottom 下内边距 特点： 内容和边框 有了距离，添加了内边距。 盒子会变大了。 值的个数 表达意思 1个值 padding：上下左右内边距; 2个值 padding: 上下内边距 左右内边距 ； 3个值 padding：上内边距 左右内边距 下内边距； 4个值 padding: 上内边距 右内边距 下内边距 左内边距 ；（顺时针） 盒子宽度 Element Width = content width + padding + border （Width为内容宽度） 盒子高度 Element Height = content height + padding + border （Height为内容高度） 盒子的实际的大小 = 内容的宽度和高度 + 内边距 + 边框这个时候，容易造成问题：内边距的改变使得盒子实际大小被撑开/* 原盒子尺寸 盒子实际尺寸：100px + 0px + 0px = 100px*/div{ height:100px; width:100px;}/* 加入内边距 盒子实际尺寸：100px + 20px + 0px =120px*/div{ height:100px; width:100px; padding:10px;}/* 保持盒子大小不变的解决方案 盒子实际尺寸：80px + 20px + 0px =100px*/div{ height:80px; width:80px; padding:10px;}2.5 外边距（margin）​ margin属性用于设置外边距。 margin就是控制盒子和盒子之间的距离 属性 作用 margin-left 左外边距 margin-right 右外边距 margin-top 上外边距 margin-bottom 下外边距 margin值的简写 （复合写法）代表意思 跟 padding 完全相同。2.6 盒子阴影box-shadow:水平阴影 垂直阴影 模糊距离（虚实） 阴影尺寸（影子大小） 阴影颜色 内/外阴影；/* 前两个属性是必须写的。其余的可以省略。 外阴影 (outset) 是默认的 但是不能写 想要内阴影可以写 inset */div { width: 200px; height: 200px; border: 10px solid red; /* box-shadow: 5px 5px 3px 4px rgba(0, 0, 0, .4); */ /* box-shadow:水平位置 垂直位置 模糊距离 阴影尺寸（影子大小） 阴影颜色 内/外阴影； */ box-shadow: 0 15px 30px rgba(0, 0, 0, .4);}3.盒子模型操作3.1 块级盒子水平居中​ 让一个块级盒子实现水平居中必须： 盒子必须指定了宽度（width） 然后就给左右的外边距都设置为auto .header { width: 960px; margin:0 auto;}/* 常见的写法，以下下三种都可以margin-left: auto; margin-right: auto;margin: auto;margin: 0 auto;*/3.2 文字居中和盒子居中区别 盒子内的文字水平居中是 text-align: center, 而且还可以让 行内元素和行内块居中对齐 块级盒子水平居中 左右margin 改为 autotext-align: center; /* 文字 行内元素 行内块元素水平居中 */margin: 10px auto; /* 块级盒子水平居中 左右margin 改为 auto 就阔以了 上下margin都可以 */3.3 插入图片和背景图片区别 插入图片 我们用的最多 比如产品展示类 移动位置只能靠盒模型 padding margin 背景图片我们一般用于小图标背景 或者 超大背景图片 背景图片 只能通过 background-position img { width: 200px;/* 插入图片更改大小 width 和 height */ height: 210px; margin-top: 30px; /* 插入图片更改位置 可以用margin 或padding 盒模型 */ margin-left: 50px; /* 插入当图片也是一个盒子 */ } div { width: 400px; height: 400px; border: 1px solid purple; background: #fff url(images/sun.jpg) no-repeat; background-position: 30px 50px; /* 背景图片更改位置 我用 background-position */ }3.4 清除元素的默认内外边距 (重要)​ 为了更灵活方便地控制网页中的元素，制作网页时，我们需要将元素的默认内外边距清除 。* { padding:0; /* 清除内边距 */ margin:0; /* 清除外边距 */}/*行内元素为了照顾兼容性， 尽量只设置左右内外边距， 不要设置上下内外边距*/3.5 外边距合并（重要）使用margin定义块元素的垂直外边距时，可能会出现外边距的合并。(1). 相邻块元素垂直外边距的合并 当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom 下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和 取两个值中的较大者这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。解决方案：尽量给只给一个盒子添加margin值(2). 嵌套块元素垂直外边距的合并（塌陷） 对于两个嵌套关系的块元素，如果父元素没有上内边距及边框 父元素的上外边距会与子元素的上外边距发生合并 合并后的外边距为两者中的较大者解决方案： 可以为父元素定义上边框 可以为父元素定义上内边距 可以为父元素添加overflow:hidden还有其他方法，比如浮动、固定、绝对定位的盒子不会有问题，后面浮动章节见。3.6 盒子模型布局稳定性​ 大部分情况下,，内边距、外边距是可以混用的。 即用内边距也可以，用外边距也可以。 你觉得哪个方便，就用哪个。按照 优先使用 宽度 （width） ，其次 使用内边距（padding） 再次 外边距（margin）。 width &amp;gt; padding &amp;gt; margin 原因： margin 会有外边距合并 还有 ie6下面margin 加倍的bug（讨厌）所以最后使用。 padding 会影响盒子大小， 需要进行加减计算（麻烦） 其次使用。 width 没有问题（嗨皮）我们经常使用宽度剩余法 高度剩余法来做。 4.书写规范​ CSS中书写规范，是代码起飞的开始。4.1 空格规范/* 1. 选择器 与 { 之间必须包含空格 */.selector {}/* 2. 属性名与之后的 : 之间不允许包含空格， : 与 属性值 之间必须包含空格 */font-size: 12px;/* 3. 并集选择器，每个选择器声明必须独占一行*/ /* good */ .post, .page, .comment { line-height: 1.5; } /* bad */ .post, .page, .comment { line-height: 1.5; }/* 4.一般情况情况下，选择器的嵌套层级应不大于 3 级，位置靠后的限定条件应尽可能精确 */ /* good */ #username input {} .comment .avatar {} /* bad */ .page .header .login input {} .comment div * {}4.2 属性规范/* 1.属性定义必须另起一行。*/ /* good */ .selector { margin: 0; padding: 0; } /* bad */ .selector { margin: 0; padding: 0; }/* 2.属性定义后必须以分号结尾。*/ /* good */ .selector { margin: 0; } /* bad */ .selector { margin: 0 }" }, { "title": "CSS文本样式", "url": "/posts/%E5%89%8D%E7%AB%AF-CSS%E6%96%87%E6%9C%AC%E6%A0%B7%E5%BC%8F/", "categories": "前端", "tags": "前端CSS", "date": "2021-05-05 00:00:00 +0800", "snippet": "1.文本样式​ 文本样式包括文本的字体、字号、颜色等文字相关的属性。CSS中通过字体样式完成对字体的设置。2.font字体 属性 表示 注意点 font-size 字号 我们通常用的单位是px 像素，一定要跟上单位 font-family 字体 实际工作中按照团队约定来写字体 font-weight 字体粗细 记住加粗是 700 或者 bold 、不加粗 是 normal 或者 400 ；记住数字不要跟单位 font-style 字体样式 记住倾斜是 italic 不倾斜 是 normal 工作中我们最常用 normal font 字体连写 1. 字体连写是有顺序的 不能随意换位置 2. 其中字号 和 字体 必须同时出现 2.1 font-size​ font-size属性用于设置字号。p { font-size:20px; } 绝对长度 说明 in 英寸 cm 厘米 mm 毫米 pt 点 可以使用相对长度单位，也可以使用绝对长度单位。相对长度单位比较常用，推荐使用像素单位px，绝对长度单位使用较少。 相对长度 说明 em 相对于当前对象内文本的字体尺寸 px 像素，最常用，建议使用 px像素（Pixel），像素px是相对于显示器屏幕分辨率而言的。 em，相对于当前对象内文本的字体尺寸,多理解父级设定font-size的尺寸。.一旦父级元素有设定字体大小, em前面数值x就相当于父级元素字体乘以x% 任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合: 1em=16px。那么12px=0.75em,10px=0.625em。​ 为了换算方便，可以在父级元素定义style=&quot;font-size:62.5%;&quot;，这样就是1em = 10px&amp;lt;body style=&quot;font-size:62.5%;&quot;&amp;gt; &amp;lt;div style=&quot;width:200px; height:300px; margin-top:20px; border:1px solid #f00; font-size:2em; &quot;&amp;gt; 这里的文字是第一级的大小 &amp;lt;div style=&quot;font-size:0.9em;&quot;&amp;gt; 这里的文字是第二级的,相对第一级x90%; &amp;lt;p style=&quot;font-size:0.8em;&quot;&amp;gt;这里的文字是第三级的,相对第二级x80%&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div style=&quot;width:200px; height:300px; margin-top:20px; border:1px solid #f00; font-size:20px; &quot;&amp;gt; 这里的文字是第一级的大小 &amp;lt;div style=&quot;font-size:18px;&quot;&amp;gt; 这里的文字是第二级的 &amp;lt;p style=&quot;font-size:14px;&quot;&amp;gt;这里的文字是第三级的&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt;注意： 工作中基本就用px，其他单位很少使用 谷歌浏览器默认的文字大小为16px 不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小。一般给body指定整个页面文字的大小2.2 font-family​ font-family属性用于设置字体。p{ font-family:&quot;微软雅黑&quot;;}/* 可以同时指定多个字体，中间以逗号隔开，表示如果浏览器不支持第一个字体，则会尝试下一个，直到找到合适的字体.如果都没有，则以我们电脑默认的字体为准 */p{font-family: Arial,&quot;Microsoft Yahei&quot;, &quot;微软雅黑&quot;;} 字体名称 英文名称 Unicode 编码 宋体 SimSun \\5B8B\\4F53 新宋体 NSimSun \\65B0\\5B8B\\4F53 黑体 SimHei \\9ED1\\4F53 微软雅黑 Microsoft YaHei \\5FAE\\8F6F\\96C5\\9ED1 楷体_GB2312 KaiTi_GB2312 \\6977\\4F53_GB2312 隶书 LiSu \\96B6\\4E66 幼园 YouYuan \\5E7C\\5706 华文细黑 STXihei \\534E\\6587\\7EC6\\9ED1 细明体 MingLiU \\7EC6\\660E\\4F53 新细明体 PMingLiU \\65B0\\7EC6\\660E\\4F53 注意： 各种字体之间必须使用英文状态下的逗号隔开 中文字体需要加英文状态下的引号，英文字体一般不需要加引号。当需要设置英文字体时，英文字体名必须位于中文字体名之前 如果字体名中包含空格、#、$等符号，则该字体必须加英文状态下的单引号或双引号，例如font-family: &quot;Times New Roman&quot; 尽量使用系统默认字体，保证在任何用户的浏览器中都能正确显示 为什么使用 Unicode字体? - 在 CSS 中设置字体名称，直接写中文是可以的。但是在文件编码（GB2312、UTF-8 等）不匹配时会产生乱码的错误- xp 系统不支持 类似微软雅黑的中文 解决： - 方案一： 你可以使用英文来替代。 比如font-family:&quot;Microsoft Yahei&quot;- 方案二： 在 CSS 直接使用 Unicode 编码来写字体名称可以避免这些错误。使用 Unicode 写中文字体名称，浏览器是可以正确的解析的 font-family: &quot;\\5FAE\\8F6F\\96C5\\9ED1&quot;; /*表示设置字体为“微软雅黑”。*/ 2.3 font-weight​ 在HTML中如何将字体加粗我们可以用标签 b 和 strong 标签是文本加粗。在CSS中，使用 font-weight实现。 属性值 描述 normal 默认值（不加粗的） bold 定义粗体（加粗的） 100~900 400 等同于 normal，而 700 等同于 bold 我们重点记住这句话 提倡： 用数字来表示加粗和不加粗2.4 font-style​ 这个功能对应于HTML中的倾斜和正常字体，用的较少。 属性 作用 normal 默认值，浏览器会显示标准的字体样式 font-style: normal; italic 浏览器会显示斜体的字体样式 平时我们很少给文字加斜体，反而喜欢给斜体标签（em，i）改为普通模式。2.5 font​ font属性用于对字体样式进行综合设置。选择器 { font: font-style font-weight font-size/line-height font-family;}注意： 使用font属性时，必须按上面语法格式中的顺序书写，不能更换顺序，各个属性以空格隔开。 其中不需要设置的属性可以省略（取默认值），但必须保留font-size和font-family属性，否则font属性将不起作用。3.外观属性 属性 表示 注意点 color 颜色 我们通常用 十六进制 比如 而且是简写形式 #fff line-height 行高 控制行与行之间的距离 text-align 水平对齐 可以设定文字水平的对齐方式 text-indent 首行缩进 通常我们用于段落首行缩进2个字的距离 text-indent: 2em; text-decoration 文本修饰 记住 添加 下划线 underline 取消下划线 none 3.1 color​ color属性用于定义文本的颜色。 表示表示 属性值 预定义的颜色值 red，green，blue，还有我们的御用色 pink RGB代码 rgb(255,0,0)或rgb(100%,0%,0%) 十六进制 #FF0000，#FF6600，#29D794 ​ 我们实际工作中， 用 16进制的写法是最多的，而且我们更喜欢简写方式比如 #f00 代表红色。p { color:#f00;}3.2 text-align​ text-align属性用于设置文本内容的水平对齐，相当于html中的align对齐属性。 属性 解释 left 左对齐（默认值） right 右对齐 center 居中对齐 注意：​ text-align是让盒子里面的内容左对齐、右对齐和水平居中， 而不是让盒子居中对齐3.3 line-height​ line-height属性用于设置行间距，即字符的垂直间距，一般称为行高。line-height常用的属性值单位有三种，分别为像素px，相对值em和百分比%，实际工作中使用最多的是像素px。/*一般情况下，行距比字号大7~8像素左右就可以了。*/line-height: 24px;行高 = 上距离 + 内容高度 + 下距离 行高我们利用最多的一个地方是： 可以让单行文本在盒子中垂直居中对齐，这主要看行高（line-height）与文字高度（font-size）的关系。 如果 行高 = 文字高度 ， 文字会 垂直居中 如果行高 &amp;gt; 文字高度 ，文字会 偏下 如果行高&amp;lt;高度 ， 文字会 偏上3.4 text-indent​ text-indent属性用于设置首行文本缩进，其属性值可为不同单位的数值、em字符宽度的倍数、或相对于浏览器窗口宽度的百分比%，允许使用负值/*1em 就是一个字的宽度 如果是汉字的段落， 1em 就是一个汉字的宽度*/p { /*行间距*/ line-height: 25px; /*首行缩进2个字 em 1个em 就是1个字的大小*/ text-indent: 2em; }3.5 text-decoration​ text-decoration 通常用于给链接修改装饰效果。 值 描述 none 默认。定义标准的文本。 取消下划线（最常用） underline 定义文本下的一条线。下划线 也是我们链接自带的（常用） overline 定义文本上的一条线。（不用） line-through 定义穿过文本下的一条线。（不常用） 4.背景​ 案例中，背景为默认的白色，过于单调。通过css背景属性，给页面元素添加背景样式，增强视觉效果，满足开发所需。 属性 作用 值 background-color 背景颜色 预定义的颜色值/十六进制/RGB代码 background-image 背景图片 url(图片路径) background-repeat 是否平铺 repeat/no-repeat/repeat-x/repeat-y background-position 背景位置 length/position 分别是x 和 y坐标， 切记 如果有 精确数值单位，则必须按照先X 后Y 的写法 background-attachment 背景固定还是滚动 scroll/fixed 背景简写 更简单 背景颜色 背景图片地址 背景平铺 背景滚动 背景位置; 他们没有顺序 背景透明 让盒子半透明 background: rgba(0,0,0,0.3); 后面必须是 4个值 4.1 background-color​ 设置背景颜色。/* 默认的值是 transparent 透明的 */background-color:颜色值; 4.2 background-image​ 设置背景图片。 参数 作用 none 无背景图（默认的） url 使用绝对或相对地址指定背景图像 background-image : none | url (url) background-image : url(images/demo.png); /* 背景图片后面的地址，url不要加引号*/4.3 background-repeat​ 设置图片单张无法覆盖背景大小时，图片的平铺方式。 参数 作用 repeat 背景图像在纵向和横向上平铺（默认的） no-repeat 背景图像不平铺 repeat-x 背景图像在横向上平铺 repeat-y 背景图像在纵向平铺 background-repeat : repeat | no-repeat | repeat-x | repeat-y 4.4 background-position​ 背景图片位置设置。 参数 值 length 百分数 | 由浮点数字和单位标识符组成的长度值 position top | center | bottom | left | center | right 方位名词 background-position : length || lengthbackground-position : position || position 注意： 必须先指定background-image属性 position 后面是x坐标和y坐标。 可以使用方位名词或者 精确单位。 如果指定两个值，两个值都是方位名字，则两个值前后顺序无关，比如left top和top left效果一致 如果只指定了一个方位名词，另一个值默认居中对齐。 如果position 后面是精确坐标， 那么第一个肯定是 x 第二的一定是y 如果只指定一个数值,那该数值一定是x坐标，另一个默认垂直居中 如果指定的两个值是 精确单位和方位名字混合使用，则第一个值是x坐标，第二个值是y坐标4.5 background-attachment​ 背景附着就是解释背景是滚动的还是固定的。 参数 作用 scroll 背景图像是随对象内容滚动 fixed 背景图像固定 background-attachment : scroll | fixed 2.6 background​ background：属性的值的书写顺序官方并没有强制标准的。为了可读性，建议大家如下写：background: 背景颜色 背景图片地址 背景平铺 背景滚动 背景位置;background: transparent url(image.jpg) repeat-y scroll center top ;设置背景透明度background: rgba(0, 0, 0, 0.3); 最后一个参数是alpha 透明度 取值范围 0~1之间 我们习惯把0.3 的 0 省略掉 这样写 background: rgba(0, 0, 0, .3); 注意： 背景半透明是指盒子背景半透明， 盒子里面的内容不受影响 因为是CSS3 ，所以 低于 ie9 的版本是不支持的。5.注意1.input的边框样式​ 要设置input输入框的边框样式，边框颜色outline-color: 颜色;边框宽度outline-width : 4px;清除外边距样式：outline-style: none;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;title&amp;gt;input外边距&amp;lt;/title&amp;gt; &amp;lt;style&amp;gt; * { margin: 10px auto; } div { width: 1000px; } /* 修改外边框颜色 */ input { outline-color: brown; } &amp;lt;/style&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;div&amp;gt; &amp;lt;input type=&quot;text&quot; value=&quot;请输入内容&quot;&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;参考链接： px和em区别-在font-size的 css 的使用 - longlongcheng - 博客园 (cnblogs.com)) input边框颜色怎么设置？如何去掉默认颜色？【CSS教程】" }, { "title": "CSS选择器", "url": "/posts/%E5%89%8D%E7%AB%AF-CSS%E9%80%89%E6%8B%A9%E5%99%A8/", "categories": "前端", "tags": "前端CSS", "date": "2021-05-04 00:00:00 +0800", "snippet": "1.概述​ HTML只关注内容的语义， 比如&amp;lt;h1&amp;gt;表明这是一个大标题，用&amp;lt;p&amp;gt; 表明这是一个段落，用&amp;lt;img&amp;gt; 表明这儿有一个图片， 用&amp;lt;a&amp;gt; 表示此处有链接。很早的时候，世界上的网站虽然很多，但是他们都有一个共同的特点： 丑。​ HTML也曾做过尝试，企图改变丑的面貌。如：在标签内的属性进行style属性设置。但是，如果要改变下 高度或者变一个颜色，就需要大量重复操作。​ 由于HTML里面添加样式带来的是无尽的臃肿且操作html属性不方便，以至于仅仅通过HTML满足不了设计者的需求。这个时候，需要有个厉害的角色来扛起这面美容大旗— CSS(Cascading Style Sheets) 。CSS作用： 主要用于设置 HTML页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局和外观显示样式。 CSS可以针对不同的浏览器设置不同的样式。2.引入方式 样式表 优点 缺点 使用情况 控制范围 行内样式表 书写方便，权重高 没有实现样式和结构相分离 较少 控制一个标签（少） 内部样式表 部分结构和样式相分离 没有彻底分离 较多 控制一个页面（中） 外部样式表 完全实现结构和样式相分离 需要引入 最多，强烈推荐 控制整个站点（多） 2.1 行内样式​ 行内样式是通过标签的style属性来设置元素的样式。实际上任何HTML标签都拥有style属性，用来设置行内式。&amp;lt;标签名 style=&quot;属性1:属性值1; 属性2:属性值2; 属性3:属性值3;&quot;&amp;gt; 内容 &amp;lt;/标签名&amp;gt;&amp;lt;div style=&quot;color: red; font-size: 12px;&quot;&amp;gt;青春不常在，抓紧谈恋爱&amp;lt;/div&amp;gt; 注意： style其实就是标签的属性 样式属性和值中间是: 多组属性值之间用;隔开。 缺点： 没有实现样式和结构相分离 只能控制当前的标签和以及嵌套在其中的字标签，造成代码冗余 2.2 内部样式​ 内部样式（也称内嵌式）是将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义&amp;lt;head&amp;gt; &amp;lt;style type=&quot;text/CSS&quot;&amp;gt; 选择器（选择的标签） { 属性1: 属性值1; 属性2: 属性值2; 属性3: 属性值3; } &amp;lt;/style&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;div&amp;gt;青春不常在，抓紧谈恋爱&amp;lt;/div&amp;gt;&amp;lt;style&amp;gt; div { color: red; font-size: 12px; }&amp;lt;/style&amp;gt; 注意： style标签一般位于head标签中，当然理论上他可以放在HTML文档的任何地方。 type=&quot;text/css&quot; 在html5中可以省略。 缺点： 只能控制当前的页面 没有实现样式和结构彻底分离 2.3 外部样式​ 外部样式（外链式）是将所有的样式放在一个或多个以.CSS为扩展名的外部样式表文件中，通过link标签将外部样式表文件链接到HTML文档中。&amp;lt;head&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css文件路径&quot;&amp;gt;&amp;lt;/head&amp;gt; 属性 作用 rel 定义当前文档与被链接文档之间的关系，在这里需要指定为stylesheet，表示被链接的文档是一个样式表文件。 type 定义所链接文档的类型，在这里需要指定为text/CSS，表示链接的外部文件为CSS样式表。我们都可以省略 href 定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径。 2.4 书写风格​ 样式书写一般有两种： 紧凑格式 (Compact)h3 { color: deeppink;font-size: 20px;} 展开格式（推荐）h3 { color: deeppink; font-size: 20px; }2.5 团队约定-代码大小写​ 样式选择器，属性名，属性值关键字全部使用小写字母书写，属性字符串允许使用大小写。/* 推荐 */h3{ color: pink;} /* 不推荐 */H3{ COLOR: PINK;}3.CSS样式规则​ 使用HTML时，需要遵从一定的规范。CSS亦如此，要想熟练地使用CSS对网页进行修饰，首先需要了解CSS样式规则，规则： 选择器用于指定CSS样式作用的HTML标签，花括号内是对该对象设置的具体样式。 属性和属性值以键值对的形式出现。 属性是对指定的对象设置的样式属性，例如字体大小、文本颜色等。 属性和属性值之间用英文:连接。 多个“键值对”之间用英文;进行区分。4.选择器​ CSS选择器用于选择你想要的元素的样式的模式。css 就是 分两件事，选对人，做对事。下面这段代码就是2件事： 把 h3选出来 把它变成了 红色h3 { color: red;}选择器分为基础选择器和 复合选择器。4.1 基础选择器 选择器 作用 缺点 使用情况 用法 标签选择器 可以选出所有相同的标签，比如p 不能差异化选择 较多 p { color：red;} 类选择器 可以选出1个或者多个标签 可以根据需求选择 非常多 .nav { color: red; } id选择器 一次只能选择器1个标签 只能使用一次 不推荐使用 #nav {color: red;} 通配符选择器 选择所有的标签 选择的太多，有部分不需要 不推荐使用 * {color: red;} 4.1.1 标签选择器​ 标签选择器（元素选择器）是指用HTML标签名(Tag)称作为选择器，按标签名称分类，为页面中某一类标签指定统一的CSS样式。标签名 { 属性1:属性值1; 属性2:属性值2; 属性3:属性值3;} 作用：标签选择器 可以把某一类标签全部选择出来 比如所有的div标签 和 所有的 span标签 优点：是能快速为页面中同类型的标签统一样式 缺点：不能设计差异化样式/*选择h3标签*/h3 { color: red;}4.1.2 类选择器​ 类选择器使用.（英文点号）进行标识，后面紧跟类名。.类名 { 属性1:属性值1; 属性2:属性值2; 属性3:属性值3; } 优点：可以为元素对象定义单独或相同的样式。 可以选择一个或者多个标签 注意: 类选择器使用.（英文点号）进行标识，后面紧跟类名(自定义，我们自己命名的) 长名称或词组可以使用中横线来为选择器命名。 不要纯数字、中文等命名， 尽量使用英文字母来表示。&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt; &amp;lt;style&amp;gt; .blue { color: blue; font-size: 100px; } .red { color: red; font-size: 100px; } .orange { color: orange; font-size: 100px; } .green { color: green; font-size: 100px; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;span class=&quot;blue&quot;&amp;gt;G&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;red&quot;&amp;gt;o&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;orange&quot;&amp;gt;o&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;blue&quot;&amp;gt;g&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;green&quot;&amp;gt;l&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;red&quot;&amp;gt;e&amp;lt;/span&amp;gt; &amp;lt;/body&amp;gt;除了上面的示例中，采用的单类选择器，也可以采用多类选择器，如下&amp;lt;div class=&quot;pink fontWeight font20&quot;&amp;gt;亚瑟&amp;lt;/div&amp;gt;&amp;lt;div class=&quot;font20&quot;&amp;gt;刘备&amp;lt;/div&amp;gt;&amp;lt;div class=&quot;font14 pink&quot;&amp;gt;安其拉&amp;lt;/div&amp;gt;&amp;lt;div class=&quot;font14&quot;&amp;gt;貂蝉&amp;lt;/div&amp;gt;注意： 各个类名中间用空格隔开 多类名选择器在后期布局比较复杂的情况下，还是较多使用的4.1.3 id选择器​ id选择器使用#进行标识，后面紧跟id名。#id_name { 属性1:属性值1; 属性2:属性值2; 属性3:属性值3; } 元素的id值是唯一的，只能对应于文档中某一个具体的元素 用法基本和类选择器相同 4.1.4 通配符选择器​ 通配符选择器用*号表示， * 就是 选择所有的标签 。* { 属性1:属性值1; 属性2:属性值2; 属性3:属性值3; }/*使用通配符选择器定义CSS样式，清除所有HTML标记的默认边距*/* { margin: 0; /* 定义外边距*/ padding: 0; /* 定义内边距*/}注意：通配符选择器会匹配页面所有的元素，降低页面响应速度，不建议随便使用4.1.5 团队约定选择器 尽量少用通用选择器 * 尽量少用 ID 选择器 不使用无具体语义定义的标签选择器 div ,span/* 推荐 */.jdc {}li {}p{}/* 不推荐 */*{}#jdc {}div{} /* 因为div 没有语义，我们尽量少用 */4.2 复合选择器​ CSS基础选择器不能满足我们实际开发中快速高效选择标签的要求，所以引入复合选择器。复合选择器是由两个或多个基础选择器通过不同的方式组合而成的。 后代选择器 用来选择元素后代 是选择所有的子孙后代 较多 符号是空格 .nav a 子代选择器 选择 最近一级元素 只选亲儿子 较少 符号是&amp;gt; .nav&amp;gt;p 交集选择器 选择两个标签交集的部分 既是 又是 较少 没有符号 p.one 选择器 作用 特征 使用情况 隔开符号及用法 并集选择器 选择某些相同样式的选择器 可以用于集体声明 较多 符号是逗号 .nav, .header 链接伪类选择器 给链接更改状态   较多 重点记住 a{} 和 a:hover 实际开发的写法 4.2.1 后代选择器​ 后代选择器又称为包含选择器，用来选择元素或元素组的子孙后代/* 写法就是把外层标签写在前面，内层标签写在后面，中间用**空格**分隔，先写父亲爷爷，在写儿子孙子。 */父级 子级{ 属性1:属性值1; 属性2:属性值2;}&amp;lt;div class=&quot;out_level&quot;&amp;gt; &amp;lt;h3&amp;gt;青春不常在，我要谈恋爱&amp;lt;/h3&amp;gt;&amp;lt;/div&amp;gt;.out_level h3{ color:red; font-size:25px;}4.2.2 子元素选择器​ 子元素选择器只能选择作为某元素子元素(亲儿子)的元素。&amp;lt;div class=&quot;out_level&quot;&amp;gt; &amp;lt;h3&amp;gt;青春不常在，我要谈恋爱&amp;lt;/h3&amp;gt;&amp;lt;/div&amp;gt;/* 写法就是把父级标签写在前面，子级标签写在后面，中间跟一个 &amp;gt; 进行连接*/.out_level&amp;gt;h3{ color:red; font-size:25px;}注意：这里的子 指的是 亲儿子,而不包含孙子、重孙子之类。4.2.3 交集选择器​ 交集选择器由两个选择器构成，找到的标签必须满足：既有标签一的特点，也有标签二的特点。 p.one 选择的是： 类名为 .one 的 段落标签。 用的相对来说比较少，不太建议使用。4.2.4 并集选择器​ 如果某些选择器定义的相同样式，就可以利用并集选择器，可以让代码更简洁。这是在实战中用的非常多的选择器，需要重点掌握。/*表示 .one 和 p 和 #test 这三个选择器都会执行颜色为红色。 通常用于集体声明。 */.one, p , #test {color: #F00;} &amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt; &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;&amp;lt;!--1. 链接 登录 的颜色为红色2. 主导航栏里面的所有的链接改为橙色 3. 主导航栏和侧导航栏里面文字都是14像素并且是微软雅黑。--&amp;gt; &amp;lt;style type=&quot;text/css&quot;&amp;gt; .site-r&amp;gt;a{ color: red; } li&amp;gt;a{ color: #FFA500; } .nav a,.sitenav a{ font-size: 14px; font-family: &quot;Microsoft YaHei&quot;; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;!-- 主导航栏 --&amp;gt; &amp;lt;div class=&quot;nav&quot;&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;公司首页&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;公司简介&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;公司产品&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;联系我们&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- 侧导航栏 --&amp;gt; &amp;lt;div class=&quot;sitenav&quot;&amp;gt; &amp;lt;div class=&quot;site-l&quot;&amp;gt;左侧侧导航栏&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;site-r&quot;&amp;gt;&amp;lt;a href=&quot;#&quot;&amp;gt;登录&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;4.2.5 链接伪类选择器​ 用于向某些选择器添加特殊的效果。比如给链接添加特殊效果， 比如可以选择 第1个，第n个元素，引入伪类选择器的概念伪类选择器很多，比如链接伪类，结构伪类等等，这里讲解链接伪类选择器。/* 伪类 用 2个点 就是 冒号 比如 :link{} */- a:link /* 未访问的链接 */- a:visited /* 已访问的链接 */- a:hover /* 鼠标移动到链接上 */- a:active /* 选定的链接 */" }, { "title": "HTML列表和表单", "url": "/posts/%E5%89%8D%E7%AB%AF-HTML%E5%88%97%E8%A1%A8%E5%92%8C%E8%A1%A8%E5%8D%95/", "categories": "前端", "tags": "前端HTML", "date": "2021-05-03 00:00:00 +0800", "snippet": "1.列表概述​ HTML 支持有序、无序和自定义列表，用来分条展示、简洁明了。 列表名称 符号 用途 无序列表 ul unordered list无序列出要点，ul中只能嵌套li,其他任何字符都不行 ；使用频繁 有序列表 ol ordered list无序列出要点，使用次数少 自定义列表 dl defined list,里面有2个兄弟， dt 和 dd 2.列表2.1无序列表​ 无序列表的各个列表项之间没有顺序级别之分，是并列的。其基本语法格式如下：&amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;列表项1&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;列表项2&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;列表项3&amp;lt;/li&amp;gt; ......&amp;lt;/ul&amp;gt;无序列表会带有自己样式属性，放下那个样式，一会让CSS来！2.2有序列表​ 有序列表是有排列顺序的列表，其各个列表项按照一定的顺序排列定义，有序列表的基本语法格式如下：&amp;lt;ol&amp;gt; &amp;lt;li&amp;gt;列表项1&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;列表项2&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;列表项3&amp;lt;/li&amp;gt; ......&amp;lt;/ol&amp;gt;所有特性基本与ul 一致， 但是实际中比 无序列表 用的少很多。2.3 自定义列表​ 自定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。其基本语法如下：&amp;lt;dl&amp;gt; &amp;lt;dt&amp;gt;名词1&amp;lt;/dt&amp;gt; &amp;lt;dd&amp;gt;名词1解释1&amp;lt;/dd&amp;gt; &amp;lt;dd&amp;gt;名词1解释2&amp;lt;/dd&amp;gt; ... &amp;lt;dt&amp;gt;名词2&amp;lt;/dt&amp;gt; &amp;lt;dd&amp;gt;名词2解释1&amp;lt;/dd&amp;gt; &amp;lt;dd&amp;gt;名词2解释2&amp;lt;/dd&amp;gt; ...&amp;lt;/dl&amp;gt;3.表单概述​ 现实中的表单，类似我们去银行办理信用卡填写的单子，**作用： **收集用户资料， 如下图，​ 在HTML中，一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域3个部分构成。 表单元素 作用 表单控件 包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等 提示信息 一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作 表单域 他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。 3.1 表单控件​ input控件就是表单控件，在html中，江湖排名NO.1。​ input是 输入的意思 、单标签、是一类控件的集合，通过type属性设置不同的属性值用来指定不同的控件类型。除了type属性外，还有其他属性。&amp;lt;input type=&quot;属性值&quot; value=&quot;你好&quot;&amp;gt; input属性 属性值 描述 type text 单行文本输入框   password 密码输入框   radio 单选按钮   checkbox 复选框   button 普通按钮   submit 提交按钮   reset 重置按钮   image 图像形式的提交按钮   file 文件域 name 由用户自定义 控件的名称 value 由用户自定义 input控件中默认文本值 size 正整数 input控件中页面显示宽度 checked checked 定义选择控件默认被选中的项 maxlength 正整数 控件允许输入的最多字符数 3.1.1. type 属性 这个属性通过改变值，可以决定了你属于那种input表单。 比如 type = ‘text’ 就表示 文本框 可以做 用户名， 昵称等。 比如 type = ‘password’ 就是表示密码框 用户输入的内容 是不可见的。用户名: &amp;lt;input type=&quot;text&quot; /&amp;gt; 密 码：&amp;lt;input type=&quot;password&quot; /&amp;gt;3.1.2. value属性用户名:&amp;lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;请输入用户名&quot;&amp;gt; value 默认的文本值。 有些表单想刚打开页面就默认显示几个文字，就可以通过这个value 来设置。3.1.3. name属性用户名:&amp;lt;input type=&quot;text&quot; name=“username” /&amp;gt; name表单的名字， 这样，后台可以通过这个name属性找到这个表单。 页面中的表单很多，name主要作用就是用于区别不同的表单。 name属性后面的值，是我们自己定义的。 radio 如果是一组，我们必须给他们命名相同的名字 name 这样就可以多个选其中的一个啦 &amp;lt;input type=&quot;radio&quot; name=&quot;sex&quot; /&amp;gt;男&amp;lt;input type=&quot;radio&quot; name=&quot;sex&quot; /&amp;gt;女 name属性，我们现在用的较少， 但是，当我们学ajax 和后台的时候，是必须的。3.1.4. checked属性 表示默认选中状态。 较常见于 单选按钮和复选按钮。性 别:&amp;lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot; checked=&quot;checked&quot; /&amp;gt;男&amp;lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot; /&amp;gt;女 上面这个，表示就默认选中了 男 这个单选按钮3.2 文本域控件 表单 名称 区别 默认值显示 用于场景 input type=&quot;text&quot; 文本框 只能显示一行文本 单标签，通过value显示默认值 用户名、昵称、密码等 textarea 文本域 可以显示多行文本 双标签，默认值写到标签中间 留言板 &amp;lt;textarea &amp;gt; 文本内容&amp;lt;/textarea&amp;gt;作用：通过textarea控件可以轻松地创建多行文本输入框属性：cols=&quot;每行中的字符数&quot; ,rows=&quot;显示的行数&quot; 我们实际开发不用3.3 下拉列表如果有多个选项让用户选择，为了节约空间，我们可以使用select控件定义下拉列表。&amp;lt;select&amp;gt; &amp;lt;option&amp;gt;选项1&amp;lt;/option&amp;gt; &amp;lt;option&amp;gt;选项2&amp;lt;/option&amp;gt; &amp;lt;option&amp;gt;选项3&amp;lt;/option&amp;gt; ...&amp;lt;/select&amp;gt; 注意： &amp;lt;select&amp;gt;; 中至少包含一对 option 在option中定义selected =&quot; selected &quot;时，当前项即为默认选中项 但是我们实际开发会用的比较少3.4 表单域 收集的用户信息怎么传递给服务器？ 通过form表单域 目的： 在HTML中，form标签被用于定义表单域，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器。 &amp;lt;form action=&quot;url地址&quot; method=&quot;提交方式&quot; name=&quot;表单名称&quot;&amp;gt; 各种表单控件&amp;lt;/form&amp;gt; 属性 属性值 作用 action url地址 用于指定接收并处理表单数据的服务器程序的url地址。 method get/post 用于设置表单数据的提交方式，其取值为get或post。 name 名称 用于指定表单的名称，以区分同一个页面中的多个表单。 注意: 每个表单都应该有自己表单域。我们现在做页面，不写看不到效果，但是 如果后面学 ajax 后台交互的时候，必须需要 form表单域。建议： 元素属性值使用双引号语法 元素属性值可以写上的都写上推荐：&amp;lt;input type=&quot;text&quot; /&amp;gt; &amp;lt;input type=&quot;radio&quot; name=&quot;name&quot; checked=&quot;checked&quot; /&amp;gt;不推荐：&amp;lt;input type=text /&amp;gt; &amp;lt;input type=&#39;text&#39; /&amp;gt; &amp;lt;input type=&quot;radio&quot; name=&quot;name&quot; checked /&amp;gt;" }, { "title": "HTML表格", "url": "/posts/%E5%89%8D%E7%AB%AF-HTML%E8%A1%A8%E6%A0%BC/", "categories": "前端", "tags": "前端HTML", "date": "2021-05-02 00:00:00 +0800", "snippet": "1.概述​ 表格现在还是较为常用的一种标签，但不是用来布局，常见显示、展示表格式数据。因为它可以让数据显示的非常的规整，可读性非常好。​ 后台展示数据的时候表格运用是否熟练显得特别重要，一个清爽简约的表格能够把繁杂的数据表现得很有条理，虽然 div 布局也可以做到，但是总没有表格来得方便。2.表格使用2.1 创建表格​ 在HTML网页中，要想创建表格，就需要使用表格相关的标签。创建表格的基本语法：&amp;lt;table&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;单元格内的文字&amp;lt;/td&amp;gt; ... &amp;lt;/tr&amp;gt; ...&amp;lt;/table&amp;gt; 表格标签 含义 说明 table 表格标签 table tr 表格中的行，必须嵌套在 table标签中 table row td 用于定义表格中的单元格，必须嵌套在tr标签中 table data th 表头单元格标签th table head caption 表格标题caption,caption 标签必须紧随 table 标签之后,且必须处于table中 table caption 2.2 表格属性​ 表格有部分属性我们不常用，这里重点记住 cellspacing 、 cellpadding 属性名 含义 常用属性值 border 设置表格的边框（默认border=0，无边框） 像素值 cellspacing 设置单元格之间的空白距离 像素值（默认2像素） cellpadding 设置单元格内容与单元格边框之间的距离 像素值（默认1像素） width 设置表格的宽度 像素值 height 设置表格的高度 像素值 align 这是表格在网页中的水平对齐方式 left、center、right rowspan 合并行单元格 数值（合并个数） colspan 合并列单元格 数值（合并个数） 我们经常有个说法，是三参为0， 平时开发的我们这三个参数 border cellpadding cellspacing 为 02.3 表格合并​ 合并单元格是我们比较常用的一个操作，但是不会合并的很复杂。 合并方式 操作 跨行合并 rowspan=&quot;合并单元格的个数&quot; 跨列合并 colspan=&quot;合并单元格的个数&quot; **合并的顺序我们按照 先上 后下 先左 后右 的顺序 **合并流程： 先确定是跨行还是跨列合并 根据 先上 后下 先左 后右的原则找到目标单元格 然后写上 合并方式 还有 要合并的单元格数量 比如 ： &amp;lt;td colspan=&quot;3&quot;&amp;gt; &amp;lt;/td&amp;gt; 删除多余的单元格 单元格`&amp;lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;20&quot; align=&quot;center&quot;&amp;gt; &amp;lt;caption&amp;gt;&amp;lt;b&amp;gt;个人简介&amp;lt;/b&amp;gt;&amp;lt;/caption&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;姓名&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;刘德华&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;性别&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;男&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;年龄&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;18&amp;lt;/td&amp;gt; &amp;lt;td rowspan=2&amp;gt;照片&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;身高&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;180&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;民族&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;汉&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;婚姻&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;未婚&amp;lt;/td&amp;gt; &amp;lt;!-- 删除多余--&amp;gt; &amp;lt;!-- &amp;lt;td&amp;gt;照片&amp;lt;/td&amp;gt; --&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td colspan=&quot;2&quot;&amp;gt;个人简介&amp;lt;/td&amp;gt; &amp;lt;!-- &amp;lt;td&amp;gt;个人简介&amp;lt;/td&amp;gt; --&amp;gt; &amp;lt;td colspan=&quot;5&quot;&amp;gt;个人简介&amp;lt;/td&amp;gt; &amp;lt;!-- &amp;lt;td&amp;gt;个人简介&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;个人简介&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;个人简介&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;个人简介&amp;lt;/td&amp;gt; --&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td colspan=&quot;2&quot;&amp;gt;个人作品&amp;lt;/td&amp;gt; &amp;lt;!-- &amp;lt;td&amp;gt;个人作品&amp;lt;/td&amp;gt; --&amp;gt; &amp;lt;td colspan=&quot;5&quot;&amp;gt;个人作品&amp;lt;/td&amp;gt; &amp;lt;!-- &amp;lt;td&amp;gt;个人作品&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;个人作品&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;个人作品&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;个人作品&amp;lt;/td&amp;gt; --&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;/table&amp;gt;2.4 复杂表格处理​ 对于比较复杂的表格，表格的结构也就相对的复杂了，所以又将表格分割成三个部分：题头、正文和脚注。而这三部分分别用:thead,tbody,tfoot来标注， 这样更好的分清表格结构注意： &amp;lt;thead&amp;gt;&amp;lt;/thead&amp;gt;：用于定义表格的头部。用来放标题之类的东西。&amp;lt;thead&amp;gt; 内部必须拥有 &amp;lt;tr&amp;gt; 标签！ &amp;lt;tbody&amp;gt;&amp;lt;/tbody&amp;gt;：用于定义表格的主体。放数据本体 。 &amp;lt;tfoot&amp;gt;&amp;lt;/tfoot&amp;gt;: 放表格的脚注之类。 以上标签都是放到table标签中。 &amp;lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; align=&quot;center&quot; width=&quot;500&quot;&amp;gt; &amp;lt;thead&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;th&amp;gt;姓名&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;性别&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;年龄&amp;lt;/th&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;/thead&amp;gt; &amp;lt;tbody&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;刘德华&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;男&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;55&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;刘若英&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;女&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;35&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;刘晓庆&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;女&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;65&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;刘三姐&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;女&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;15&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;/tbody&amp;gt; &amp;lt;tfoot&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;信息地址&amp;lt;/td&amp;gt; &amp;lt;td colspan=&quot;2&quot;&amp;gt; 北京市金燕龙校区举办演唱会&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;/tfoot&amp;gt; &amp;lt;/table&amp;gt;" }, { "title": "HTML基本元素标签", "url": "/posts/%E5%89%8D%E7%AB%AF-HTML%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0%E6%A0%87%E7%AD%BE/", "categories": "前端", "tags": "前端HTML", "date": "2021-05-01 00:00:00 +0800", "snippet": "1.概述​ 超文本标记语言（英语：HyperText Markup Language，简称：HTML）是一种用于创建网页的标准标记语言。可以使用 HTML 来建立自己的 WEB 站点，HTML 运行在浏览器上，由浏览器来解析。​ 在本章中，博主主要采用的前端编辑器是Hbuilder X 3.3.13。2.基础元素​ 在HTML中，基本骨架如下图所示​ 在HTML页面中，带有&amp;lt; &amp;gt;符号的元素被称为HTML标签，如上面提到的 &amp;lt;html&amp;gt;、&amp;lt;head&amp;gt;、&amp;lt;body&amp;gt;都是HTML骨架结构标签。 标签 说明 示例 常规元素（双标签） &amp;lt;标签名&amp;gt; 内容 &amp;lt;/标签名&amp;gt; &amp;lt;body&amp;gt; 我是文字 &amp;lt;/body&amp;gt; 空元素（单标签） &amp;lt;标签名 /&amp;gt; &amp;lt;br /&amp;gt; 标签关系 示例 嵌套关系 &amp;lt;head&amp;gt; &amp;lt;br/&amp;gt; &amp;lt;title&amp;gt; &amp;lt;/title&amp;gt; &amp;lt;br/&amp;gt;&amp;lt;/head&amp;gt; 并列关系 &amp;lt;head&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;br/&amp;gt;&amp;lt;body&amp;gt;&amp;lt;/body&amp;gt;     2.1 文档类型&amp;lt;!DOCTYPE html&amp;gt; ​ &amp;lt;!DOCTYPE html&amp;gt; 声明位于文档中的最前面的位置，处于 &amp;lt;html&amp;gt; 标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。​ &amp;lt;!DOCTYPE html&amp;gt; 就是告诉浏览器按照HTML5 规范解析页面。​ 规定： HTML文件必须加上 DOCTYPE 声明，并统一使用 HTML5 的文档声明2.2 页面语言&amp;lt;html lang=&quot;en&quot;&amp;gt; 指定html 语言种类为英文&amp;lt;html lang=&quot;zh-CN&quot;&amp;gt; 指定html 语言种类为中文 &amp;lt;!--简单来说，可能对于程序来说没有太大的作用，但是它可以告诉浏览器，搜索引擎，一些处理Html的程序，对页面语言内容来做一些对应的处理或者事情比如:- 根据根据lang属性来设定不同语言的css样式，或者字体- 告诉搜索引擎做精确的识别- 让语法检查程序做语言识别- 帮助翻译工具做识别- 帮助网页阅读程序做识别 等等--&amp;gt;​ 规定：考虑浏览器和操作系统的兼容性，目前仍然使用 zh-CN 属性值2.3 字符集&amp;lt;meta charset=&quot;UTF-8&quot; /&amp;gt;&amp;lt;!--字符集(Character set)是多个字符的集合。计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。--&amp;gt; 字符集 支持语言 说明 gb2312 简单中文 包括6763个汉字 gb – 国标（GUO BIAO） BIG5 繁体中文 港澳台等用 GBK 全部中文字符 GBK是GB2312的扩展，加入对繁体字的支持，兼容GB2312 UTF-8 全世界字符 包含全世界所有国家需要用到的字符 ​ 规定：一般情况下统一使用 UTF-8 编码, 请尽量统一写成标准的 UTF-8，不要写成 “utf-8” 或 “utf8” 或 “UTF8”。3.常用标签 标签类型 说明 示例 标题标签h head 头部,加了标题的文字会变的加粗，字号也会依次变大一行是只能放一个标题的 &amp;lt;h1&amp;gt; 标题文本 &amp;lt;/h1&amp;gt; 段落标签p paragraph段落 &amp;lt;p&amp;gt; 文本内容 &amp;lt;/p&amp;gt; 水平线标签hr horizontal 横线,在网页中显示默认样式的水平线 &amp;lt;hr/&amp;gt;是单标签 换行标签br break 打断 、换行， &amp;lt;br /&amp;gt;是单标签 标签类型 说明 示例 div division 的缩写 分割， 分区;盒子元素，一行只能放一个 &amp;lt;div&amp;gt; 这是头部 &amp;lt;/div&amp;gt; span span 跨度，跨距；范围；盒子元素，一行可以放多个 &amp;lt;span&amp;gt;今日价格&amp;lt;/span&amp;gt; 文本格式标签 说明 示例 加粗标签b或者strong b-bold 加粗，strong 强壮，粗壮 &amp;lt;b&amp;gt;加粗文字&amp;lt;/b&amp;gt;&amp;lt;strong&amp;gt;加粗文字&amp;lt;/strong&amp;gt; 倾斜文字标签i或em 文字斜体显示 &amp;lt;i&amp;gt;倾斜文字&amp;lt;/i&amp;gt;&amp;lt;em&amp;gt;倾斜文字&amp;lt;/em&amp;gt; 删除线标签 s或del 文字加删除线 &amp;lt;s&amp;gt;加删除线的文字&amp;lt;/s&amp;gt;&amp;lt;del&amp;gt;加删除线的文字&amp;lt;/del&amp;gt; 下划线u或ins 文字加下划线 &amp;lt;u&amp;gt;加删除线的文字&amp;lt;/u&amp;gt;&amp;lt;ins&amp;gt;加删除线的文字&amp;lt;/ins&amp;gt; 4.标签属性​ 有些标签有属性加持，本节介绍有属性加持的标签。所谓属性就是外在特性 比如 手机的颜色 手机的尺寸 ，总结就是手机的属性。 手机的颜色是黑色 手机的尺寸是 8寸 水平线的长度是 200 图片的宽度 是 300&amp;lt;标签名 属性1=&quot;属性值1&quot; 属性2=&quot;属性值2&quot; …&amp;gt; 内容 &amp;lt;/标签名&amp;gt;&amp;lt;手机 颜色=&quot;红色&quot; 大小=&quot;5寸&quot;&amp;gt; &amp;lt;/手机&amp;gt;4.1 图像标签​ 单词缩写： image 图像​ 要想在网页中显示图像就需要使用图像标签，接下来将详细介绍图像标签&amp;lt;img /&amp;gt;以及和他相关的属性。（它是一个单标签）语法如下：&amp;lt;img src=&quot;图像URL&quot; 属性1=&quot;属性值1&quot; 属性2=&quot;属性值2&quot; …/&amp;gt; 属性 属性值 描述 src URL 图像的路径 alt 文本 图像不能显示时的替换文本 title 文本 鼠标悬停时显示的内容 width 像素 设置图像的宽度 height 像素 设置图像的高度 border 数字 设置图像边框的宽度（css中讲解） 正常的&amp;lt;br /&amp;gt; &amp;lt;img src=&quot;cz.jpg&quot; width=&quot;300&quot; height=&quot;300&quot; /&amp;gt;&amp;lt;br /&amp;gt; 带有边框的&amp;lt;br /&amp;gt; &amp;lt;img src=&quot;cz.jpg&quot; width=&quot;300&quot; height=&quot;300&quot; border=&quot;3&quot; /&amp;gt;&amp;lt;br /&amp;gt; 有提示文本的&amp;lt;br /&amp;gt; &amp;lt;img src=&quot;cz.jpg&quot; width=&quot;300&quot; height=&quot;300&quot; border=&quot;3&quot; title=&quot;这是个小蒲公英&quot; /&amp;gt;&amp;lt;br /&amp;gt; 有替换文本的&amp;lt;br /&amp;gt; &amp;lt;img src=&quot;cz.jpg&quot; width=&quot;300&quot; height=&quot;300&quot; border=&quot;3&quot; alt=&quot;图片不存在&quot; /&amp;gt;4.2 链接标签​ 单词缩写： anchor 的缩写 [ˈæŋkə(r)] 。基本解释 锚, 铁锚 。​ 在HTML中创建超链接非常简单，只需用标签把文字包括起来就好。语法格式：&amp;lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式&quot;&amp;gt;文本或图像&amp;lt;/a&amp;gt; 属性 作用 href 用于指定链接目标的url地址，（必须属性）当为标签应用href属性时，它就具有了超链接的功能 target 用于指定链接页面的打开方式，其取值有_self和_blank两种，其中_self为默认值，__blank为在新窗口中打开方式。 注意： 外部链接 需要添加 http:// www.baidu.com 内部链接 直接链接内部页面名称即可 比如 &amp;lt; a href=&quot;index.html&quot;&amp;gt; 首页 &amp;lt;/a &amp;gt; 如果当时没有确定链接目标时，通常将链接标签的href属性值定义为“#”(即href=&quot;#&quot;)，表示该链接暂时为一个空链接。 不仅可以创建文本超链接，在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。4.3 注释标签​ 在HTML中还有一种特殊的标签——注释标签。如果需要在HTML文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字，就需要使用注释标签。 &amp;lt;!-- 注释语句 --&amp;gt; ​ 一般用于简单的描述，如某些状态描述、属性描述等。注释内容前后各一个空格字符，注释位于要注释代码的上面，单独占一行推荐：&amp;lt;!-- Comment Text --&amp;gt;&amp;lt;div&amp;gt;...&amp;lt;/div&amp;gt;5.路径​ 实际工作中，我们的文件不能随便乱放，否则用起来很难快速的找到他们，因此我们需要一个文件夹来管理他们。​ 页面中的图片会非常多， 通常我们再新建一个文件夹专门用于存放图像文件（images），这时再插入图像，就需要采用“路径”的方式来指定图像文件的位置。路径可以分为： 相对路径和绝对路径5.1 相对路径​ 以引用文件之网页所在位置为参考基础，而建立出的目录路径。因此，当保存于不同目录的网页引用同一个文件时，所使用的路径将不相同，故称之为相对路径。 路径分类 符号 说明 同一级路径   只需输入图像文件的名称即可，如&amp;lt;img src=”baidu.gif” /&amp;gt;。 下一级路径 “/” 图像文件位于HTML文件同级文件夹下（例如文件夹名称为：images） 如&amp;amp;lt;img src=&quot;images/baidu.gif&quot; /&amp;amp;gt;。 上一级路径 “../” 在文件名之前加入“../” ，如果是上两级，则需要使用 “../ ../”，以此类推， 如&amp;amp;lt;img src=&quot;../baidu.gif&quot; /&amp;amp;gt;。 相对路径，是从代码所在的这个文件出发， 去寻找我们的目标文件的，而 我们所说的 上一级 下一级 同一级 简单说，就是 图片 位于 HTML 页面的位置5.2 绝对路径​ 绝对路径以Web站点根目录为参考基础的目录路径。之所以称为绝对，意指当所有网页引用同一个文件时，所使用的路径都是一样的。D:\\web\\img\\logo.gif，或完整的网络地址，例如http://www.itcast.cn/images/logo.gif。注意：​ 绝对路径用的较少，我们理解下就可以了。 但是要注意，它的写法 特别是符号反斜杠 ` 并不是 相对路径的 ` / `" }, { "title": "Python基操-装饰器", "url": "/posts/Python-%E8%A3%85%E9%A5%B0%E5%99%A8/", "categories": "Python", "tags": "Python基操", "date": "2020-04-05 00:00:00 +0800", "snippet": "1.概述​ 装饰器(Decorators)是 Python 的一个重要部分。简单地说：他们是修改其他函数的功能的函数。他们有助于让我们的代码更简短，也更Pythonic（Python范儿）。大多数初学者不知道在哪儿使用它们，所以我将要分享下，哪些区域里装饰器可以让你的代码更简洁。 首先，让我们讨论下如何写你自己的装饰器。2.用法2.1 函数中定义函数​ 写一段代码，用来寻找n（整数）以内的所有质数# 寻找质数def find_prime(nums): result = [] for num in range(nums): if num &amp;gt; 1: for i in range(2, num): if (num % i) == 0: break else: result.append(num) else: pass return result# 进行函数的嵌套，用来执行寻找质数的操作def prime_nums(nums): prime_list = find_prime(nums) return prime_list# 打印结果print(prime_nums(20000))2.2函数中传入函数​ 为了查看算法函数find_prime的执行时间，需要写一个时间计算import time# 寻找质数def find_prime(nums): result = [] for num in range(nums): if num &amp;gt; 1: for i in range(2, num): if (num % i) == 0: break else: result.append(num) else: pass return result# 进行函数的嵌套，用来执行寻找质数的操作def prime_nums(nums): start = time.time() prime_list = find_prime(nums) end = time.time() print(&quot;Tatol time:{:.4} s&quot;.format(end-start) ) return prime_list# 打印结果print(prime_nums(20000))&amp;gt;&amp;gt;&amp;gt;Tatol time:0.9993 s[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, ......]这个时候，可以将计算函数作为参数，传递给计时函数。目的是让计时函数独立功能，可以复用import time# 寻找质数def find_prime(nums): result = [] for num in range(nums): if num &amp;gt; 1: for i in range(2, num): if (num % i) == 0: break else: result.append(num) else: pass return result# 装饰器函数，用来显示运行时间def display_time(func): def wrapper(): start = time.time() func() end = time.time() print(&quot;Tatol time:{:.4} s&quot;.format(end - start)) return wrapper# 在主函数上用@符号挂上装饰器，就可以计算函数的运行时间@display_timedef prime_nums(): prime_list = find_prime(nums=20000) print(prime_list) return prime_list# 打印结果prime_nums()&amp;gt;&amp;gt;&amp;gt;[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,......]Tatol time:0.9225 s这个时候，实现了主函数传入装饰器函数，但是，如果主函数是有参数的，应该如何处理呢？2.3函数中传入函数与参数import time# 寻找质数def find_prime(nums): result = [] for num in range(nums): if num &amp;gt; 1: for i in range(2, num): if (num % i) == 0: break else: result.append(num) else: pass return result# 装饰器函数，用来显示运行时间,在wrapper中接收主函数的参数# *args 可变长度的变量；**kwargs 可变长度的字典def display_time(func): def wrapper(*args, **kwargs): start = time.time() # 这个*args就是wrapper后面的*args func(*args) end = time.time() print(&quot;Tatol time:{:.4} s&quot;.format(end - start)) return wrapper# 在主函数上用@符号挂上装饰器，就可以计算函数的运行时间@display_timedef prime_nums(nums): prime_list = find_prime(nums) print(prime_list) return prime_list# 打印结果，实现主函数的参数传入prime_nums(20000)&amp;gt;&amp;gt;&amp;gt;[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,......]Tatol time:0.9225 s下面就基本解析上主函数的传入和参数的传入 首先将主函数进行拆分为 prime_nums()和参数20000 将主函数prime_nums作为装饰器函数的参数，在装饰器函数的外层函数display_time()处传入 将主函数prime_nums的参数20000作为装饰器内层函数的参数，在装饰器内层函数wrapper()处 注：一般情况下，参数的传入设置为可变长度的：*args代表可变长度的变量；**kwargs代表 可变长度的字典 参考链接1.Python小技巧：装饰器(Decorator)" }, { "title": "Python基操-自动化办公(E-mail)", "url": "/posts/Python-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC(E-mail)/", "categories": "Python", "tags": "Python基操", "date": "2020-04-03 00:00:00 +0800", "snippet": "1.概述​ 在日常的工作中，涉及到自动化数据采集、处理并形成文档，且需要将信息以邮件的方式告知相关工作人员的场景。对于远端的机器，需要执行无人值守，并自动完成数据采集、处理、分析、形成文档和自动邮件发送的功能。这个时候，需要用代码去实现邮件的编写和发送，本节介绍Python的两个内置库smtplib和email，来实现邮件功能。2.smtplib库​ SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。python实现发邮件也是基于此基础上进行封装的。SMTP协议只能用来发送邮件，不能用来接收邮件。大多数的邮件发送服务器 (Outgoing Mail Server) 都是使用SMTP协议。SMTP协议的默认TCP端口号是25。​ smtplib用法相对来说很简单，就是分为三步。 创建SMTP的操作对象并连接smtp目标服务器，可以是126、163、QQ等 根据自己的账号登录目标服务器（自己的邮箱地址和邮箱授权码） 调用对象中的方法，发送邮件到目标地址import smtplibfrom email.mime.text import MIMETextmail_host = &quot;smtp.163.com&quot;mail_sender = &quot;zhengkan1993@163.com&quot;mail_receivers = [&quot;846774350@qq.com&quot;, &quot;1175234362@qq.com&quot;, &quot;188261720@qq.com&quot;]mail_license = &quot;HBUFQCFRNAIJINJC&quot;msg = MIMEText(&#39;邮件发送测试内容&#39;) # 邮件内容# 创建SMTP对象stp = smtplib.SMTP()# 设置发件人邮箱的域名和端口，端口地址为25stp.connect(mail_host, 25)# set_debuglevel(1)可以打印出和SMTP服务器交互的所有信息stp.set_debuglevel(1)# 登录邮箱，传递参数1：邮箱地址，参数2：邮箱授权码stp.login(mail_sender, mail_license)# 发送邮件，传递参数1：发件人邮箱地址，参数2：收件人邮箱地址，参数3：把邮件内容格式改为strstp.sendmail(mail_sender, mail_receivers, msg.as_string())print(&quot;邮件发送成功&quot;)# 关闭SMTP对象stp.quit()3.email库​ 除简单文本外，很多时候邮件中还会包含HTML、图片、音频、附件等。MIME（Multipurpose Internet Mail Extensions，多用途互联网邮件扩展）作为一种新的扩展邮件格式很好地补充了这一点。​ 可以将email.mime理解成smtplib模块邮件内容主体的扩展，从原先默认只支持纯文本格式扩展到HTML，同时支持附件、音频、图像等格式，smtplib只负责邮件的投递即可。 类 说明 email.mime.multipart.MIMEMultipart([_subtype[,boundary[,_subparts[,_params]]]]) 包含多个部分邮件体的MIME对象 email.mime.audio.MIMEAudio (_audiodata[,_subtype[,_encoder[,_params]]]) 创建包含音频数据的邮件体 email.mime.image.MIMEImage(_imagedata[,_subtype[,_encoder[,_params]]]) 创建包含图片数据的邮件体 email.mime.text.MIMEText (_text[,_subtype[,_charset]]) 创建包含文本数据的邮件体 说明：# MIMEMultipart中的_subtype类型mixed（默认）：构建一个带附件的邮件体related：构建内嵌资源的邮件体alternative：构建纯文本与超文本共存的邮件体# MIMEAudio中的_audiodata_audiodata包含原始二进制音频数据的字节字符串# MIMEImage中的_imagedata_imagedata是包含原始图片数据的字节字符串# MIMEText中的_text_text是包含消息负载的字符串；_subtype指定文本类型，支持plain（默认值）或html类型的字符串from email.header import Headerfrom email.mime.text import MIMETextfrom email.mime.image import MIMEImagefrom email.mime.multipart import MIMEMultipartmm = MIMEMultipart(&#39;related&#39;)# 构建邮件头subject_content = &quot;琵琶行&quot;mm[&quot;Subject&quot;] = Header(subject_content, &#39;utf-8&#39;)# 构建邮件内容content = MIMEText(_text=&#39;&#39;&#39;浔阳江头夜送客，枫叶荻花秋瑟瑟。主人下马客在船，举酒欲饮无管弦。醉不成欢惨将别，别时茫茫江浸月。忽闻水上琵琶声，主人忘归客不发。寻声暗问弹者谁，琵琶声停欲语迟。移船相近邀相见，添酒回灯重开宴。千呼万唤始出来，犹抱琵琶半遮面。转轴拨弦三两声，未成曲调先有情。弦弦掩抑声声思，似诉平生不得志。低眉信手续续弹，说尽心中无限事。轻拢慢捻抹复挑，初为《霓裳》后《六幺》。大弦嘈嘈如急雨，小弦切切如私语。嘈嘈切切错杂弹，大珠小珠落玉盘。间关莺语花底滑，幽咽泉流冰下难。冰泉冷涩弦凝绝，凝绝不通声暂歇。别有幽愁暗恨生，此时无声胜有声。银瓶乍破水浆迸，铁骑突出刀枪鸣。曲终收拨当心画，四弦一声如裂帛。东船西舫悄无言，唯见江心秋月白。沉吟放拨插弦中，整顿衣裳起敛容。自言本是京城女，家在虾蟆陵下住。十三学得琵琶成，名属教坊第一部。曲罢曾教善才服，妆成每被秋娘妒。五陵年少争缠头，一曲红绡不知数。钿头银篦击节碎，血色罗裙翻酒污。今年欢笑复明年，秋月春风等闲度。弟走从军阿姨死，暮去朝来颜色故。门前冷落鞍马稀，老大嫁作商人妇。商人重利轻别离，前月浮梁买茶去。去来江口守空船，绕船月明江水寒。夜深忽梦少年事，梦啼妆泪红阑干。我闻琵琶已叹息，又闻此语重唧唧。同是天涯沦落人，相逢何必曾相识！我从去年辞帝京，谪居卧病浔阳城。浔阳地僻无音乐，终岁不闻丝竹声。住近湓江地低湿，黄芦苦竹绕宅生。其间旦暮闻何物？杜鹃啼血猿哀鸣。春江花朝秋月夜，往往取酒还独倾。岂无山歌与村笛？呕哑嘲哳难为听。今夜闻君琵琶语，如听仙乐耳暂明。莫辞更坐弹一曲，为君翻作《琵琶行》。感我此言良久立，却坐促弦弦转急。凄凄不似向前声，满座重闻皆掩泣。座中泣下谁最多？江州司马青衫湿。&#39;&#39;&#39;, _subtype=&quot;text&quot;, _charset=&quot;utf-8&quot;)mm.attach(content)# 构建插图pic = MIMEImage(_imagedata=open(&quot;./source/琵琶行.jpg&quot;, &quot;rb&quot;).read(), _subtype=&quot;base64&quot;)mm.attach(pic)# 构建附件txt_file = MIMEText(open(&#39;./source/琵琶行.txt&#39;, &#39;rb&#39;).read(), &#39;base64&#39;, &#39;utf-8&#39;)txt_file[&quot;Content-Disposition&quot;] = &#39;attachment; filename=&quot;琵琶行.txt&quot;&#39;mm.attach(txt_file)4.综合一封邮件import smtplibfrom email.header import Headerfrom email.mime.text import MIMETextfrom email.mime.image import MIMEImagefrom email.mime.multipart import MIMEMultipartfrom email.mime.application import MIMEApplicationmail_host = &quot;smtp.163.com&quot;mail_sender = &quot;zhengkan1993@163.com&quot;mail_receivers = [&quot;zhengkan@mywind.com.cn&quot;, &quot;846774350@qq.com&quot;]mail_license = &quot;HBUFQCFRNAIJINJC&quot;mm = MIMEMultipart(&#39;related&#39;)# 构建邮件头subject_content = &quot;琵琶行&quot;mm[&quot;Subject&quot;] = Header(subject_content, &#39;utf-8&#39;)mm[&quot;FROM&quot;] = &quot;&amp;lt;zhengkan1993@163.com&amp;gt;&quot;mm[&quot;TO&quot;] = &quot;&amp;lt;zhengkan@mywind.com.cn&amp;gt;&quot;# 构建邮件内容with open(&quot;./source/琵琶行.txt&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f: text = f.read()# 构建插图with open(&quot;./source/琵琶行.jpeg&quot;, &quot;rb&quot;) as f: pic = MIMEImage(f.read(), _subtype=&quot;base64&quot;)pic.add_header(&#39;Content-ID&#39;, &#39;&amp;lt;image1&amp;gt;&#39;)pic[&quot;Content-Disposition&quot;] = &#39;attachment; filename=&quot;琵琶行.jpeg&quot;&#39;mm.attach(pic)# 整合内容（图片+文字）content1 = MIMEText(&#39;&#39;&#39;&amp;lt;html&amp;gt; &amp;lt;body&amp;gt; {} &amp;lt;img src=&quot;cid:image1&quot; alt=&quot;image1&quot;&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&#39;&#39;&#39;.format(text), &#39;html&#39;, &#39;utf-8&#39;) # 正文mm.attach(content1)# 构建附件txt_file = MIMEApplication(open(&#39;./source/琵琶行.txt&#39;, &#39;rb&#39;).read())txt_file.add_header(&#39;content-disposition&#39;, &#39;attachment&#39;, filename=&quot;琵琶行.txt&quot;)mm.attach(txt_file)xlsx_file = MIMEApplication(open(&#39;./source/琵琶行.xlsx&#39;, &#39;rb&#39;).read(), &#39;base64&#39;)xlsx_file.add_header(&#39;content-disposition&#39;, &#39;attachment&#39;, filename=&quot;琵琶行.xlsx&quot;)mm.attach(xlsx_file)pic_file = MIMEApplication(open(&#39;./source/琵琶行.jpeg&#39;, &#39;rb&#39;).read(), &#39;base64&#39;)pic_file.add_header(&#39;content-disposition&#39;, &#39;attachment&#39;, filename=&quot;琵琶行.jpeg&quot;)mm.attach(pic_file)# 创建SMTP对象stp = smtplib.SMTP()# 设置发件人邮箱的域名和端口，端口地址为25stp.connect(mail_host, 25)# set_debuglevel(1)可以打印出和SMTP服务器交互的所有信息stp.set_debuglevel(1)# 登录邮箱，传递参数1：邮箱地址，参数2：邮箱授权码stp.login(mail_sender, mail_license)# 发送邮件，传递参数1：发件人邮箱地址，参数2：收件人邮箱地址，参数3：把邮件内容格式改为strstp.sendmail(mail_sender, mail_receivers, mm.as_string())print(&quot;邮件发送成功&quot;)# 关闭SMTP对象stp.quit()参考链接：1.python发送各类QQ邮件 —— smtplib与email模块" }, { "title": "Python基操-自动化办公(Pdf)", "url": "/posts/Python-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC(Pdf)/", "categories": "Python", "tags": "Python基操", "date": "2020-04-02 00:00:00 +0800", "snippet": "1.概述​ PDF（Portable Document Format）是日常办公中常用的文件格式，使用.pdf作为扩展名，用于可靠的呈现和交换文档，与软件、硬件和操作系统无关。2.PyPDF2库​ 日常办公中，对于PDF文件的制作，一般通过在Office Word中进行文档的编辑工作，随后通过另存为pdf生成得到。本节主要讲解对生成后的PDF文件的处理，包括合并、拆分、读取、旋转等功能。​ 主要用到的第三方库为PyPDF2# 安装PyPDF2&amp;gt;&amp;gt;&amp;gt; pip install PyPDF2&amp;gt;&amp;gt;&amp;gt;pip show pypdf2Name: PyPDF2Version: 1.26.0Summary: PDF toolkitHome-page: http://mstamy2.github.com/PyPDF2...PyPDF2库主要包括 PdfFileReader、PdfFileWriter、PageObject和PdfFileMerge共四个大类，分别负责pdf文件的读取、写出、页码管理和合并2.1读取PDF​ 读取pdf文件用到 PdfFileReader类，详解一下这个类下面的方法 方法 说明 decrypt (password） 加密文档 getDestinationPageNumber(destination) 获取目标页（destination为 int类型） getDocumentInfo() 获取文档基本信息 getIsEncrypted() 判断是否加密 getNumPages() 获取总页数 getPage() 获取页面信息，返回一个页面对象PageObject from PyPDF2 import PdfFileReaderfile = r&quot;./sources/Deep Forecast Deep Learning-based Spatio-Temporal Forecasting.pdf&quot;reader = PdfFileReader(file)# 获取文档信息print(reader.getDocumentInfo())# 获取是否加密信息print(reader.getIsEncrypted())# 获取总页数print(reader.getNumPages())# 获取最后一页的内容信息print(reader.getPage(reader.getNumPages() - 1))print(reader.getFields(tree=True))# 获取索引内容print(reader.getOutlines())# 导出第一页内容page = reader.pages[0]print(page.extractText())2.2PDF拆分​ 拆分PDF主要用到了PdfFileWriter类，简单梳理下这个类的方法 方法 说明 addPage(page) 添加页，page是page (PageObject)对象，可以通过PdfFileReader获得 addBlankPage(width=None,height=None) 添加空白页 … 有些方法用不到，可直接在word中完成 from PyPDF2 import PdfFileReader, PdfFileWriterinput_file = r&quot;./sources/Deep Forecast Deep Learning-based Spatio-Temporal Forecasting.pdf&quot;pdf_file = PdfFileReader(input_file)# 获取总页数page_sum = pdf_file.numPagesfor num in range(page_sum): output_file = r&#39;./sources/splited_pdf/拆分文件第&#39; + str(num + 1) + &#39;页.pdf&#39; add_page = pdf_file.getPage(num) pdf_output = PdfFileWriter() pdf_output.addPage(add_page) with open(output_file, &#39;wb&#39;) as f: pdf_output.write(f)2.3PDF合并​ 合并PDF主要用到 PdfFileMerge类，基本方法介绍下 方法 说明 close() 关闭内存 merge (position, fileobj, bookmark=None, pages=None, import_bookmarks=True)   append（fileobj, bookmark=None, pages=None, import_bookmarks=True) 一般参数不设置，直接添加就行，每个子页命名顺序就行了 from PyPDF2 import PdfFileMergerimport os# 三个输入项，分别为输入路径、输出路径和合并后的名字input_file_path = r&#39;./sources/splited_pdf&#39;output_file_path = r&#39;./sources/merged_pdf&#39;merge_name = &#39;merge_file&#39;files = os.listdir(input_file_path) # 列出目录中的所有文件merger = PdfFileMerger()for file in files: # 从所有文件中选出pdf文件合并 if file.endswith(&#39;pdf&#39;): file = os.path.join(input_file_path, file) merger.append(open(file, &#39;rb&#39;))output_file = os.path.join(output_file_path, merge_name) + &#39;.pdf&#39;with open(output_file, &#39;wb&#39;) as fout: # 输出文件为newfile.pdf merger.write(fout)参考链接：1.PyPDF2官网说明" }, { "title": "Python基操-自动化办公(Excel)", "url": "/posts/Python-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC(Excel)/", "categories": "Python", "tags": "Python基操", "date": "2020-04-01 00:00:00 +0800", "snippet": "1.概述​ 前一篇讲了自动化办公中的Office Word，这一篇针对Office Excel进行解析。主要用到的库是openpyxl、xlwt等等库，但是每个库里面的专注的功能不一样，需要根据需要使用。​ Python 中有大量的原生和第三方 Excel 操作包，各有所长，不过对于刚使用 Python 与 Excel 交互的同学来说，可能有点目不暇接，所以先简单梳理一下常见的一些 Excel 包 OpenPyXL 是个读写 Excel 2010 xlsx/xlsm/xltx/xltm 的 Python 库，简单易用，功能广泛，单元格格式/图片/表格/公式/筛选/批注/文件保护等等功能应有尽有，图表功能是其一大亮点 xlwings 是一个基于 BSD 授权协议的 Python 库，可以轻松的使用 Python 操作 Excel，也可以在 Excel 中调用 Python，以接近 VBA 语法的实现 Excel 编程，支持 Excel 宏，并且可以作为 Web 服务器，提供 REST API 接口 pandas 数据处理是 pandas 的立身之本，Excel 作为 pandas 输入/输出数据的容器 win32com 从命名上就可以看出，这是一个处理 windows 应用的扩展，Excel 只是该库能实现的一小部分功能。该库还支持 office 的众多操作。需要注意的是，该库不单独存在，可通过安装 pypiwin32 或者 pywin32 获取 Xlsxwriter 拥有丰富的特性，支持图片/表格/图表/筛选/格式/公式等，功能与 openpyxl 相似，优点是相比 openpyxl 还支持 VBA 文件导入，迷你图等功能，缺点是不能打开/修改已有文件，意味着使用 xlsxwriter 需要从零开始 DataNitro 一个 Excel 的付费插件，内嵌到 Excel 中，可完全替代 VBA，在 Excel 中使用 python 脚本。既然被称为 Excel 中的 python，同时可以与其他 python 库协同。 xlutils 基于 xlrd/xlwt，老牌 python 包，算是该领域的先驱，功能特点中规中矩，比较大的缺点是仅支持 xls 文件。概括一下： 不想使用 GUI 而又希望赋予 Excel 更多的功能，openpyxl 与 xlsxwriter，二者可选其一； 需要进行科学计算，处理大量数据，建议 pandas+xlsxwriter 或者 pandas + openpyxl，是不错的选择； 想要写 Excel 脚本，会 Python 但不会 VBA，可考虑 xlwings 或 DataNitro； win32com 功能还是性能都很强大，不过需要一定的 windows 编程经验才能上手，它相当于是 windows COM 的封装，另外文档不够完善2.openpyxl库&amp;gt;&amp;gt;&amp;gt; pip install openpyxl&amp;gt;&amp;gt;&amp;gt; pip show openpyxlName: openpyxlVersion: 3.0.9Summary: A Python library to read/write Excel 2010 xlsx/xlsm filesHome-page: https://openpyxl.readthedocs.ioAuthor: See AUTHORS在操作Excel文件之前需要了解Exce工作簿的基本概念 基本概念 说明 workbook 工作簿，即xls文件，每个工作簿都是一个Workbook对象 sheet Excel中的表单，每个文档至少一个sheet cell 单元格，每个sheet中都要若干个cell，存储数据 2.1 创建工作簿from openpyxl import Workbookimport datetime# 创建一个 workbookwb = Workbook()# 获取被激活的 worksheetws = wb.active# 设置单元格内容ws[&#39;A1&#39;] = 42# 设置一行内容ws.append([1, 2, 3])# 设置A2的值，前面已经在A2写下的值会被覆盖ws[&#39;A2&#39;] = datetime.datetime.now()# 保存 Excel 文件wb.save(&quot;第一个工作簿v1.1.xlsx&quot;)# 打开一个工作簿from openpyxl import load_workbookwb = load_workbook(&#39;第一个工作簿v1.1.xlsx&#39;)# 显示文档中包含的 表单 名称print(wb.sheetnames)load_workbook 除了参数 filename 外为还有一些有用的参数： read_only：是否为只读模式，对于超大型文件，要提升效率有帮助 keep_vba ：是否保留 vba 代码，即打开 Excel 文件时，开启并保留宏 guess_types：是否做在读取单元格数据类型时，做类型判断 data_only：是否将公式转换为结果，即包含公式的单元格，是否显示最近的计算结果 keep_links：是否保留外部链接2.2 操作sheet​ openpyxl具备对sheet创建、删除、修改、查询的功能from openpyxl import Workbookimport warningswarnings.filterwarnings(&quot;ignore&quot;)wb = Workbook()ws = wb.activews1 = wb.create_sheet(&quot;人员汇总&quot;) # 创建一个名为 人员汇总 的sheetws1.title = &quot;人员汇总A&quot; # 修改 ws1 标题ws1.sheet_properties.tabColor = &quot;1072BA&quot; # 设置 sheet 标签背景色ws2 = wb.create_sheet(&quot;收入汇总&quot;, 0) # 创建一个 sheet，插入到最前面 默认插在后面ws2.title = &quot;收入汇总A&quot; # 修改 ws2的 标题# 获取 sheetws3 = wb.get_sheet_by_name(&quot;收入汇总A&quot;)# ws4 = wb[&#39;New Title&#39;]# 复制 sheetws1_copy = wb.copy_worksheet(ws1)# 删除 sheetwb.remove(ws1)wb.save(&quot;第二个工作簿v2.2.xlsx&quot;) 每个 Workbook 中都有一个被激活的 sheet，一般都是第一个，可以通过 active 直接获取 可以通过 sheet 名来获取 sheet 对象 创建 sheet时需要提供 sheet 名称参数，如果该名称的 sheet 已经存在，则会在名称后添加 1，再有重复添加 2，以此类推 获得 sheet 对象后，可以设置 名称（title），背景色等属性 同一个 Workbook 对象中，可以复制 sheet，需要将源 sheet 对象作为参数，复制的新 sheet 会在最末尾 可以删除一个 sheet，参数是目标 sheet 对象 对于每个sheet中的行列，可以插入行、插入列、删除行、删除列、移动 # 在第7行之前插入行ws.insert_rows(7)# 删除第6列后面的三列，即F:Hws.delete_cols(6, 3)# 移动&quot;D4:F10&quot;,向上移动1行，向右移动2列，并覆盖原来的值ws.move_range(&quot;D4:F10&quot;, rows=-1, cols=2)# 如果单元格有公式，一起移动需要加上translate；公式这部分放在后面部分讲 ws.move_range(&quot;G4:H10&quot;, rows=1, cols=1, translate=True)2.3 操作cellfrom openpyxl import Workbookwb = Workbook()ws = wb.active# 创建一个sheetws1 = wb.create_sheet(&quot;人员数据&quot;, 0)# 通过单元格名称设置ws1[&quot;A1&quot;], ws1[&quot;B1&quot;] = &quot;姓名&quot;, &quot;年龄&quot;ws1[&quot;A2&quot;], ws1[&quot;B2&quot;] = &quot;马三&quot;, 20# 通过行列坐标设置ws1.cell(row=3, column=1, value=&quot;李四&quot;)ws1.cell(row=3, column=2, value=10)wb.save(&quot;Workbook v2.3.1.xlsx&quot;)from openpyxl import Workbook,load_workbookwb = load_workbook(&quot;Workbook v2.3.1.xlsx&quot;)ws = wb[&quot;人员数据&quot;]# 操作单列for cell in ws[&quot;A&quot;]: print(cell.value)print(&quot;--------------------&quot;)# 操作单行for cell in ws[&quot;1&quot;]: print(cell.value)print(&quot;--------------------&quot;)# 操作多列for column in ws[&#39;A:C&#39;]: for cell in column: print(cell.value)print(&quot;--------------------&quot;)# 操作多行for row in ws[&#39;1:3&#39;]: for cell in row: print(cell.value)print(&quot;--------------------&quot;)# 指定范围for row in ws[&#39;A1:C3&#39;]: for cell in row: print(cell.value)print(&quot;--------------------&quot;)# 设置整行数据ws.append((1,2,3))# 合并单元格ws.merge_cells(&#39;A2:D2&#39;)# 解除合并 # 注意：对于没有合并过单元格的位置调用 unmerge_cells 时回报错ws.unmerge_cells(&#39;A2:D2&#39;)ws.merge_cells(start_row=2,start_column=1,end_row=2,end_column=4)ws.unmerge_cells(start_row=2,start_column=1,end_row=2,end_column=4)2.4 单元格格式OpenPyXl 用6中类来设置单元格的样式 样式 说明 NumberFormat 数字 Alignment 对齐 Font 字体 Border 边框 PatternFill 填充 Protection 保护 from openpyxl import Workbookfrom openpyxl.styles import PatternFill, Border, Side, Alignment, Protection, Font, numberswb = Workbook()ws = wb.active# 创建一个sheetws1 = wb.create_sheet(&quot;人员数据&quot;, 0)# 通过单元格名称设置ws1[&quot;A1&quot;], ws1[&quot;B1&quot;] = &quot;姓名&quot;, &quot;年龄&quot;ws1[&quot;A2&quot;], ws1[&quot;B2&quot;] = &quot;马三&quot;, 20# 通过行列坐标设置ws1.cell(row=3, column=1, value=&quot;李四&quot;)ws1.cell(row=3, column=2, value=10)# 设置单元格格式# 字体font_style = Font(name=&#39;Calibri&#39;, # 字体样式 size=11, # 字体大小 bold=False, # 加粗 italic=False, # 斜体 vertAlign=None, # 垂直对齐 underline=&#39;none&#39;, # 下划线 strike=False, color=&#39;00FF0000&#39;)# 填充背景色fill = PatternFill(fill_type=&#39;solid&#39;, start_color=&#39;FF0000&#39;)# 设置边线border = Border(left=Side(border_style=&#39;thin&#39;, color=&#39;FF0000&#39;), right=Side(border_style=&#39;thin&#39;, color=&#39;FF0000&#39;), top=Side(border_style=&#39;thin&#39;, color=&#39;FF0000&#39;), bottom=Side(border_style=&#39;thin&#39;, color=&#39;FF0000&#39;), )# 设置数字格式number_format = numbers.FORMAT_PERCENTAGE# 设置对齐方式alignment = Alignment(horizontal=&#39;right&#39;)# 设置单元格保护protection = Protection(locked=True, hidden=False)ws1.cell(row=1, column=1).font = font_stylews1.cell(row=1, column=2).fill = fillws1.cell(row=2, column=1).border = borderws1.cell(row=1, column=3, value=0.54).number_format = number_formatws1.cell(row=2, column=2, value=&#39;右对齐&#39;).alignment = alignmentws1.cell(row=2, column=4, value=&#39;保护&#39;).protection = protection# 遍历范围内的单元格for row in ws1[&#39;A1:C3&#39;]: for cell in row: cell.font = font_style# 设置整行row = ws1.row_dimensions[1]row.font = font_style# 设置整列column = ws1.column_dimensions[&quot;A&quot;]column.font = font_stylewb.save(&quot;Workbook v2.4.xlsx&quot;)2.5 柱状图from openpyxl import Workbookfrom openpyxl.chart import BarChart, Referencewb = Workbook()ws = wb.activerows = [ (&#39;月份&#39;, &#39;苹果&#39;, &#39;香蕉&#39;), (1, 43, 25), (2, 10, 30), (3, 40, 60), (4, 50, 70), (5, 20, 10), (6, 10, 40), (7, 50, 30),]# 对于数据录入，同一采用循环添加 append 方法for row in rows: ws.append(row)chart1 = BarChart()chart1.type = &quot;col&quot;chart1.style = 10chart1.title = &quot;销量柱状图&quot;chart1.y_axis.title = &#39;销量&#39;chart1.x_axis.title = &#39;月份&#39;data = Reference(ws, min_col=2, min_row=1, max_row=8, max_col=3)series = Reference(ws, min_col=1, min_row=2, max_row=8)chart1.add_data(data, titles_from_data=True)chart1.set_categories(series)ws.add_chart(chart1, &quot;A10&quot;)2.6 饼状图from openpyxl import Workbookfrom openpyxl.chart import PieChart, Referencedata = [ [&#39;水果&#39;, &#39;销量&#39;], [&#39;苹果&#39;, 50], [&#39;樱桃&#39;, 30], [&#39;橘子&#39;, 10], [&#39;香蕉&#39;, 40],]wb = Workbook()ws = wb.activefor row in data: ws.append(row)pie = PieChart()pie.title = &quot;水果销量占比&quot;labels = Reference(ws, min_col=1, min_row=2, max_row=5)data = Reference(ws, min_col=2, min_row=1, max_row=5)pie.add_data(data, titles_from_data=True)pie.set_categories(labels)ws.add_chart(pie, &quot;D1&quot;)wb.save(&quot;Workbook v2.6.xlsx&quot;)2.7 补充说明​ 个人认为，openpyxl适用于对表格样式的加工，旨在为用户提供一个经过美化的效果，而其计算功能相较于pandas而言，就相对复杂和鸡肋了。所以，这里不记录openpyxl中的公式移植功能，数据透视表功能等使用pandas能够轻松解决的问题。​ 在数据处理方面，建议使用pandas读取Excel文件中的数据，进行处理，最后保存到Excel文件中。后通过openpyxl读取该Excel文档，并对指定位置进行加工（字体样式、单元格样式等），最后呈现出一个适合用户阅读的Excel文档。参考链接：1.全网最全 Python 操作 Excel库总结！2.Excel 神器 —— OpenPyXl" }, { "title": "Python基操-自动化办公(Word)", "url": "/posts/Python-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC(Word)/", "categories": "Python", "tags": "Python基操", "date": "2020-03-31 00:00:00 +0800", "snippet": "1.概述​ 在日常办公中，常用的软件就是office套件。针对office word、office excel和pdf的相关办公要求，python给出了相应的自动化处理的包，加速办公进程。2.Word-docx库​ 在处理文档时，常用的是office word。在python的docx库中，提供了多种方法来对接office文档。&amp;gt;&amp;gt;&amp;gt; pip install python-docx &amp;gt;&amp;gt;&amp;gt; pip show python-docxName: python-docxVersion: 0.8.11Summary: Create and update Microsoft Word .docx files.Home-page: https://github.com/python-openxml/python-docx...2.1 创建docx文档from docx import Documentdocument = Document()document.save(&#39;test.docx&#39;)# 打开文档（版本大于 Word 2007）document = Document(&#39;existing-document-file.docx&#39;)document.save(&#39;new-file-name.docx&#39;)# 可以使用打开文件的方式打开docx文档f = open(&#39;foobar.docx&#39;, &#39;rb&#39;)document = Document(f)f.close()通过Document类实例化形成document对象，实例化后的对象拥有多个方法 方法 说明 add_heading(text=u’‘, level=1) 添加标题、标题等级 add_page_break() 添加分页符 add_paragraph(text=u’‘, style=None) 添加一个段落、段落等级 add_picture(image_path_or_stream, width=None, height=None） 添加图片 add_section(start_type=2) 添加一个分区 add_table(rows, cols, style=None) 添加表格、表格样式 save(path_or_stream) 存储文档 核心属性（Document.core_properties.xxx) 文档可读可写的核心属性 author 作者 category 文档类别 comments 文档说明 content_status 文档说明状态、如草稿 created 创建时间（datetime类型） identifier 标志符号，如ISBN keywords 文档关键词 language 文档语言 last_modified_by 最后修改人员 last_printed 最后打印时间（datetime类型） modified 最后修改时间（datetime类型） revision 修订次数（int类型） subject 文档主题 title 文档标题 version 版本号 from docx import Documentimport datetimedocument = Document()document.core_properties.author = &quot;BlackJ&quot;document.core_properties.category = &quot;tech&quot;document.core_properties.comments = &quot;This is a document&quot;document.core_properties.content_status = &quot;draft&quot;document.core_properties.created = datetime.datetime.now()document.core_properties.identifier = &quot;ISBN:38.315&quot;document.core_properties.keywords = &quot;tech class&quot;document.core_properties.language = &quot;en&quot;document.core_properties.last_modified_by = &quot;BlackJ&quot;document.core_properties.last_modified = datetime.datetime(2022, 1, 2, 9, 22, 11)document.core_properties.last_printed = datetime.datetime(2022, 1, 3, 8, 32, 21)document.core_properties.subject = &quot;Tech Power&quot;document.core_properties.title = &quot;Tech Power is unlimited&quot;document.core_properties.version = &quot;1.1&quot;print(document.core_properties.category)document.save(&quot;Tech Power.docx&quot;)2.2 编辑文档from docx import Documentnew_doc = Document()new_doc.add_heading(text=&quot;Tech Blogs&quot;)new_doc.add_paragraph( text=r&#39;&#39;&#39;The paper presents a spatio-temporal wind speed forecasting algorithm using Deep Learning (DL) and in particular, Recurrent Neural Networks(RNNs). Motivated by recent advances in renewable energy integration and smart grids, we apply our proposed algorithm for wind speed forecasting. Renewable energy resources (wind and solar)are random in nature and, thus, their integration is facilitated with accurate short-term forecasts.In our proposed framework, we model the spatiotemporal information by a graph whose nodes are data generating entities and its edges basically model how these nodes are interacting with each other. One of the main contributions of our work is the fact that we obtain forecasts of all nodes of the graph at the same time based on one framework. Results of a case study on recorded time series data from a collection of wind mills in the north-east of the U.S. show that the proposed DL-based forecasting algorithm significantly improves the short-term forecasts compared to a set of widely-used benchmarks models.&#39;&#39;&#39;)new_doc.add_picture(&#39;./source/EX01.png&#39;)new_doc.add_section(2)new_doc.add_table(3, 4)new_doc.save(&quot;Tech Blogs v2.2.docx&quot;)​ 生成的文档属于一个素版的文档，没有修饰和格式，纯粹的堆砌而成。所以，在这个时候，需要了解下后面的样式的内容。2.3 样式单位​ 样式在word文档中有着灵魂作用，包括对齐方式、颜色、字体大小等等。首先介绍一下尺寸方面和颜色方面的基本知识，这个模块集中在docx.shared模块中，主要包括长度（Length objects）和颜色（Length objects）。from docx.shared import Inches,Cm,Pt,Mmfrom docx.shared import RGBColor Length objects 说明 Inches 英寸单位 width = Inches(0.5) Cm 厘米单位 height = Cm(12) Mm 毫米单位 width = Mm(240.5) Pt 点单位 Twips 缇，长度单位 width = Twips(42),A twip is a twentieth of a point, 635 EMU Emu 英文width = Emu(457200)，1cm = 360000 EMU RGBColor objects 表示方法 RGBColor 三通道颜色表示 RGBColor(0xff, 0x99, 0xcc) RGBColor.from_string(*rgb_hex_str*) 三通道字符表示RGBColor.from_string(3C2F80) 2.4 样式格式​ 上一小节列举了样式的单位，这一节具体介绍样式格式的运用。在python-docx这个包中，有enumerations 模块，里面有Microsoft office的各种属性设置。段落样式​ 对于段落样式，常见的就是对齐方式from docx.enum.text import WD_ALIGN_PARAGRAPHparagraph = document.add_paragraph()paragraph.alignment = WD_ALIGN_PARAGRAPH.CENTER 对齐方式 说明 LEFT Left-aligned CENTER Center-aligned RIGHT Right-aligned JUSTIFY 两端对齐 DISTRIBUTE 分散对齐 JUSTIFY_MED 上下居中 JUSTIFY_HI 顶端对齐 JUSTIFY_LOW 底端对齐 THAI_JUSTIFY 泰式对齐 行间距from docx.enum.text import WD_LINE_SPACINGparagraph = document.add_paragraph()paragraph.paragraph_format.line_spacing_rule = WD_LINE_SPACING.EXACTLY 行间距 说明 ONE_POINT_FIVE 1.5倍行距 AT_LEAST 最小行距 DOUBLE 2倍行距 EXACTLY 固定行距 MULTIPLE 多倍行距 SINGLE 单倍行距 节（section）的概念​ 一个文档中，有多个节，通过获取节来进行本节（section）内的操作&amp;gt;&amp;gt;&amp;gt; document = Document()&amp;gt;&amp;gt;&amp;gt; sections = document.sections&amp;gt;&amp;gt;&amp;gt; sections&amp;lt;docx.parts.document.Sections object at 0x1deadbeef&amp;gt;&amp;gt;&amp;gt;&amp;gt; len(sections)3&amp;gt;&amp;gt;&amp;gt; section = sections[0] #在section[0]中有奇偶页的设置属性&amp;gt;&amp;gt;&amp;gt; section&amp;lt;docx.section.Section object at 0x1deadbeef&amp;gt;&amp;gt;&amp;gt;&amp;gt; for section in sections:... print(section.start_type)...NEW_PAGE (2)EVEN_PAGE (3)ODD_PAGE (4)# 添加新节&amp;gt;&amp;gt;&amp;gt; current_section = document.sections[-1] # last section in document&amp;gt;&amp;gt;&amp;gt; current_section.start_typeNEW_PAGE (2)&amp;gt;&amp;gt;&amp;gt; new_section = document.add_section(WD_SECTION.ODD_PAGE)&amp;gt;&amp;gt;&amp;gt; new_section.start_typeODD_PAGE (4) 节的属性 说明 start_type 开始的类型 orientation 方向 page_width 页面宽度 page_height 页面高度 left_margin 文字到页面最左端的距离(页边距) right_margin 文字到页面最右端的距离 top_margin 文字到页面最上端的距离 bottom_margin 文字到页面最底端的距离 header_distance 页眉顶端距离 footer_distance 页脚底端距离 gutter 装订线位置 页眉和页脚&amp;gt;&amp;gt;&amp;gt; document = Document()&amp;gt;&amp;gt;&amp;gt; section = document.sections[0]# 获取第一节的页眉&amp;gt;&amp;gt;&amp;gt; header = section.header&amp;gt;&amp;gt;&amp;gt; header.is_linked_to_previous = False # 不使用上节内容和样式&amp;gt;&amp;gt;&amp;gt; document.settings.odd_and_even_pages_header_footer = True # 奇偶页不一样&amp;gt;&amp;gt;&amp;gt; section.different_first_page_header_footer = True # 设置启动首页不同&amp;gt;&amp;gt;&amp;gt; section.footer.paragraphs[0].alignment = WD_PARAGRAPH_ALIGNMENT.LEFT # 页脚左对齐2.5 图片和表格​ 在2.2小节已经用到了插入图片和表格，本小节细化一下from docx import Documentnew_doc = Document()new_doc.add_heading(text=&quot;Tech Blogs&quot;)new_doc.add_picture(&#39;./source/EX01.png&#39;,width=Inches(1.25))new_doc.add_table(3, 4，style=&#39;Medium Grid 1 Accent 1&#39;)new_doc.save(&quot;Tech Blogs v2.2.docx&quot;)# 查看docx中包含的表格样式from docx.enum.style import WD_STYLE_TYPEfrom docx import Documentd.=Document()styles=d.stylesfor s in styles: if s.type==WD_STYLE_TYPE.TABLE: print(s.name)表格列宽 1. 可以使表格自动适应窗口大小: table.autofit=True 2. 设置列宽尺寸table.cell(row,col).width=Cm(4) 表格行高 设置行高尺寸table.rows[0].height=Cm(12)表格对齐方式table.alignment=WD_TABLE_ALIGNMENT.CENTER|WD_TABLE_ALIGNMENT.LEFT|WD_TABLE_ALIGNMENT.RIGHT合并单元格# 在表格中每个单元格都有一个代码，cell(row,col)，row表示行号，col表示列号，从0开始计数table.cell(row1,col1).merge(table.cell(row2,col2))如果是cell(row1,col1)是cell(1,0）,cell(row2,col2)是cell(1,2)，那么合并的就是cell(1,0)、cell(1,1)、cell(1,2)三个单元格。表格文字样式# 表格中文字样式修改，与在段落中的样式修改一样，只是在添加文本时调用的方法不同。run=table.cell(row,col).paragraphs[0].add_run(str) #添加文本的方法run.font.name = u&#39;宋体&#39; run._element.rPr.rFonts.set(qn(&#39;w:eastAsia&#39;), u&#39;宋体&#39;)run.font.bold=True表格文字对齐# 水平对齐table.cell(row,col).paragraphs[0].paragraph_format.alignment=WD_ALIGN_PARAGRAPH.CENTER |WD_ALIGN_PARAGRAPH.LEFT|WD_ALIGN_PARAGRAPH.RIGHT# 垂直对齐table.cell(1,1).vertical_alignment=WD_ALIGN_VERTICAL.CENTER |WD_ALIGN_VERTICAL.TOP|WD_ALIGN_VERTICAL.BOTTOM综合案例from docx import Documentfrom docx.shared import Cm, Ptfrom docx.shared import RGBColorfrom docx.enum.text import WD_PARAGRAPH_ALIGNMENTfrom docx.oxml.ns import qnfrom docx.enum.table import WD_TABLE_ALIGNMENT&#39;&#39;&#39;# 查看docx中包含的表格样式from docx.enum.style import WD_STYLE_TYPEfrom docx import Documentd = Document()styles = d.stylesfor s in styles: if s.type == WD_STYLE_TYPE.TABLE: print(s.name)&#39;&#39;&#39;# 首先创建一个文档对象document = Document()# 修改页面为横板sections = document.sectionssection = sections[0]new_pagewidth, new_pageheight = section.page_height, section.page_widthsection.page_height = new_pageheightsection.page_width = new_pagewidth# 添加标题,并修改字体样式head = document.add_heading(0)run = head.add_run(&#39;表格&#39;)run.font.name = u&#39;黑体&#39; # 设置字体为黑体run.font.size = Pt(24) # 设置大小为24磅run.font.color.rgb = RGBColor(0, 0, 0) # 设置颜色为黑色head.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER # 居中# 添加子文档p = document.add_paragraph()run = p.add_run(&#39;2019年03月24日至2020年03月25日&#39;)run.font.name = u&#39;宋体&#39;run._element.rPr.rFonts.set(qn(&#39;w:eastAsia&#39;), u&#39;宋体&#39;)run.font.size = Pt(14) # 设置大小为14磅p.alignment = WD_PARAGRAPH_ALIGNMENT.RIGHT # 右对齐# 表格操作colss = 11 # 表格的总列数table = document.add_table(rows=1, cols=colss, style=&#39;Table Grid&#39;)table.alignment = WD_TABLE_ALIGNMENT.CENTER# 表格标题行，并设置字体hdr_cells = table.rows[0].cellsFields = [&#39;序号&#39;, &#39;字段&#39;, &#39;日期&#39;, &#39;x1&#39;, &#39;y1&#39;, &#39;x2&#39;, &#39;y2&#39;, &#39;重要性&#39;, &#39;整数&#39;, &#39;类型&#39;, &#39;备注&#39;]for i in range(colss): hdr_cells[i].paragraphs[0].paragraph_format.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER run = hdr_cells[i].paragraphs[0].add_run(Fields[i]) run.font.name = u&#39;宋体&#39; run._element.rPr.rFonts.set(qn(&#39;w:eastAsia&#39;), u&#39;宋体&#39;) run.font.bold = True if i == 2: hdr_cells[i].width = Cm(2.7)# 写入表格数据data = [ [1, &#39;B&#39;, &#39;2020-03-04&#39;, -102.36, 1254.03, 23.00, 1635.2, &quot;正常&quot;, 10, &#39;P&#39;, &#39;&#39;], [2, &#39;B&#39;, &#39;2020-03-04&#39;, -102.36, 1254.03, 23.00, 1635.2, &quot;正常&quot;, 10, &#39;P&#39;, &#39;&#39;], [3, &#39;B&#39;, &#39;2020-03-04&#39;, -102.36, 1254.03, 23.00, 1635.2, &quot;正常&quot;, 10, &#39;P&#39;, &#39;&#39;], [4, &#39;B&#39;, &#39;2020-03-04&#39;, -102.36, 1254.03, 23.00, 1635.2, &quot;正常&quot;, 10, &#39;P&#39;, &#39;&#39;], [5, &#39;B&#39;, &#39;2020-03-04&#39;, -102.36, 1254.03, 23.00, 1635.2, &quot;正常&quot;, 10, &#39;P&#39;, &#39;&#39;], [6, &#39;B&#39;, &#39;2020-03-25&#39;, -12.36, 154.03, 2.00, 165.2, &quot;正常&quot;, 10, &#39;P&#39;, &#39;&#39;], [7, &#39;B&#39;, &#39;2020-03-25&#39;, -12.36, 154.03, 2.00, 165.2, &quot;正常&quot;, 10, &#39;P&#39;, &#39;&#39;], [8, &#39;B&#39;, &#39;2020-03-25&#39;, -12.36, 154.03, 2.00, 165.2, &quot;正常&quot;, 10, &#39;P&#39;, &#39;&#39;], [9, &#39;B&#39;, &#39;2020-03-25&#39;, -12.36, 154.03, 2.00, 165.2, &quot;正常&quot;, 10, &#39;P&#39;, &#39;&#39;], [10, &#39;B&#39;, &#39;2020-03-25&#39;, -12.36, 154.03, 2.00, 165.2, &quot;正常&quot;, 10, &#39;P&#39;, &#39;&#39;]]for line in data: row_cells = table.add_row().cells for i, d in enumerate(line): row_cells[i].paragraphs[0].paragraph_format.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER run = row_cells[i].paragraphs[0].add_run(str(d)) run.font.name = u&#39;宋体&#39; run._element.rPr.rFonts.set(qn(&#39;w:eastAsia&#39;), u&#39;宋体&#39;)# 合并第二列单元格rowss = 10table.cell(1, 1).merge(table.cell(rowss, 1))table.cell(1, 1).text = &#39;&#39;table.cell(1, 1).paragraphs[0].paragraph_format.alignment = WD_PARAGRAPH_ALIGNMENT.CENTERrun = table.cell(1, 1).paragraphs[0].add_run(&#39;B&#39;)run.font.name = u&#39;宋体&#39;run._element.rPr.rFonts.set(qn(&#39;w:eastAsia&#39;), u&#39;宋体&#39;)table.cell(1, 1).vertical_alignment = WD_TABLE_ALIGNMENT.CENTER# 合并第三列单元格table.cell(1, 2).merge(table.cell(int(rowss / 2), 2))table.cell(1, 2).text = &#39;&#39;table.cell(1, 2).paragraphs[0].paragraph_format.alignment = WD_PARAGRAPH_ALIGNMENT.CENTERrun = table.cell(1, 2).paragraphs[0].add_run(&#39;2020-3-24&#39;)run.font.name = u&#39;宋体&#39;run._element.rPr.rFonts.set(qn(&#39;w:eastAsia&#39;), u&#39;宋体&#39;)table.cell(1, 2).vertical_alignment = WD_TABLE_ALIGNMENT.CENTERtable.cell(int(rowss / 2 + 1), 2).merge(table.cell(rowss, 2))table.cell(int(rowss / 2 + 1), 2).text = &#39;&#39;table.cell(int(rowss / 2 + 1), 2).paragraphs[0].paragraph_format.alignment = WD_PARAGRAPH_ALIGNMENT.CENTERrun = table.cell(int(rowss / 2 + 1), 2).paragraphs[0].add_run(&#39;2020-3-25&#39;)run.font.name = u&#39;宋体&#39;run._element.rPr.rFonts.set(qn(&#39;w:eastAsia&#39;), u&#39;宋体&#39;)table.cell(int(rowss / 2 + 1), 2).vertical_alignment = WD_TABLE_ALIGNMENT.CENTER# 写入表格其他信息p = document.add_paragraph()run = p.add_run(&#39;编制单位：&#39; + &#39;_&#39; * 20 + &#39;\\n&#39;)run.font.name = u&#39;宋体&#39;run._parent.paragraph_format.space_before = Pt(18) # 段前间距run._element.rPr.rFonts.set(qn(&#39;w:eastAsia&#39;), u&#39;宋体&#39;)run.font.size = Pt(14) # 设置大小为14磅p.alignment = WD_PARAGRAPH_ALIGNMENT.RIGHT # 右对齐p = document.add_paragraph()run = p.add_run(&#39;编制人：&#39; + &#39;_&#39; * 10 + &#39;审核：&#39; + &#39;_&#39; * 10)run.font.name = u&#39;宋体&#39;run._element.rPr.rFonts.set(qn(&#39;w:eastAsia&#39;), u&#39;宋体&#39;)run.font.size = Pt(14) # 设置大小为14磅p.alignment = WD_TABLE_ALIGNMENT.RIGHT # 右对齐# 将文档保存到docx中try: document.save(&quot;Tech Blogs v2.5.docx&quot;) print(&quot;Tech Blogs v2.5.docx文件已保存&quot;)except: print(&quot;文件被占用，请关闭后重试！&quot;)2.6再次编辑文档​ 在加入了段落后，需要注意的是段落属性Paragraph properties,通过paragraph.paragraph_format可以访问。分析一下，段落：即由字符组成句子，句子组成段落。字符 --- 字体样式（加粗、倾斜、下滑线、删除线...）、字体大小、字体颜色句子 --- 行距段落 --- 段前段后间距、段落对齐方式、段落缩进方式&amp;gt;&amp;gt;&amp;gt; from docx.enum.text import WD_ALIGN_PARAGRAPH&amp;gt;&amp;gt;&amp;gt; from docx.shared import Inches&amp;gt;&amp;gt;&amp;gt; document = Document()&amp;gt;&amp;gt;&amp;gt; paragraph = document.add_paragraph()&amp;gt;&amp;gt;&amp;gt; paragraph_format = paragraph.paragraph_format水平对齐（Horizontal alignment (justification)）&amp;gt;&amp;gt;&amp;gt; paragraph_format.alignment = WD_ALIGN_PARAGRAPH.CENTER&amp;gt;&amp;gt;&amp;gt; paragraph_format.alignmentCENTER (1)缩进（Indentation）# 左缩进&amp;gt;&amp;gt;&amp;gt; paragraph_format.left_indent = Inches(0.5)&amp;gt;&amp;gt;&amp;gt; paragraph_format.left_indent457200# 右缩进&amp;gt;&amp;gt;&amp;gt; paragraph_format.right_indent = Pt(24)&amp;gt;&amp;gt;&amp;gt; paragraph_format.right_indent304800# 首行缩进&amp;gt;&amp;gt;&amp;gt; paragraph_format.first_line_indentNone&amp;gt;&amp;gt;&amp;gt; paragraph_format.first_line_indent = Inches(-0.25)&amp;gt;&amp;gt;&amp;gt; paragraph_format.first_line_indent-228600​ 精讲一下，一般在文档编辑的过程中，需要首行缩进2字符。但是，这个字符的大小是随着字体的大小变化而变化的，所以，需要设置或者找出字体的大小，然后乘以2即可。# p1.style.font.size = Pt(10.5)p1.paragraph_format.first_line_indent = p1.style.font.size * 2行距​ 行距通过两个属性来设定，行距line_spacing和行距规则line_spacing_rule，参考2.4小节的行间距规则。&amp;gt;&amp;gt;&amp;gt; from docx.shared import Length&amp;gt;&amp;gt;&amp;gt; paragraph_format.line_spacingNone&amp;gt;&amp;gt;&amp;gt; paragraph_format.line_spacing_ruleNone# 设置固定行距，需要制定具体数值单位&amp;gt;&amp;gt;&amp;gt; paragraph_format.line_spacing = Pt(18)&amp;gt;&amp;gt;&amp;gt; isinstance(paragraph_format.line_spacing, Length)True&amp;gt;&amp;gt;&amp;gt; paragraph_format.line_spacing.pt18.0&amp;gt;&amp;gt;&amp;gt; paragraph_format.line_spacing_ruleEXACTLY (4)# 设置多倍行距，直接写浮点数据&amp;gt;&amp;gt;&amp;gt; paragraph_format.line_spacing = 1.75&amp;gt;&amp;gt;&amp;gt; paragraph_format.line_spacing1.75&amp;gt;&amp;gt;&amp;gt; paragraph_format.line_spacing_ruleMULTIPLE (5)段前段后间距（Paragraph spacing）&amp;gt;&amp;gt;&amp;gt; paragraph_format.space_before, paragraph_format.space_after(None, None) # inherited by default&amp;gt;&amp;gt;&amp;gt; paragraph_format.space_before = Pt(18)&amp;gt;&amp;gt;&amp;gt; paragraph_format.space_before.pt18.0&amp;gt;&amp;gt;&amp;gt; paragraph_format.space_after = Pt(12)&amp;gt;&amp;gt;&amp;gt; paragraph_format.space_after.pt12.0# 在使用run等级的时候，需要用到_parentp = document.add_paragraph()run = p.add_run(&#39;编制单位：&#39; + &#39;_&#39; * 20 + &#39;\\n&#39;)run.font.name = u&#39;宋体&#39;run._parent.paragraph_format.space_before = Pt(18) # 段前间距分页属性(Pagination properties)​ 这个分页有点不太懂~ 分页方式（布尔类型） 说明 keep_together 整个段落归于后一页中；如果段落分跨两页，分页符在段首 keep_with_next 段落应与后续段落保持在同一页面上。例如，此属性可用于将节标题与其第一段保持在同一页上 page_break_before 段落前分页，使得被纸张分开的段落全部位于第二页上 widow_control 文档重排时，第一行与最后一行与段落均位于同一纸张 字符操作​ 字符操作通过run级别来实现。&amp;gt;&amp;gt;&amp;gt; from docx import Document&amp;gt;&amp;gt;&amp;gt; document = Document()&amp;gt;&amp;gt;&amp;gt; run = document.add_paragraph().add_run()# 访问运行的字体&amp;gt;&amp;gt;&amp;gt; font = run.font# 字体样式与大小设置&amp;gt;&amp;gt;&amp;gt; from docx.shared import Pt&amp;gt;&amp;gt;&amp;gt; font.name = &#39;Calibri&#39;&amp;gt;&amp;gt;&amp;gt; font.size = Pt(12)# 字体加粗与倾斜&amp;gt;&amp;gt;&amp;gt; font.bold, font.italic(None, None)&amp;gt;&amp;gt;&amp;gt; font.italic = True&amp;gt;&amp;gt;&amp;gt; font.italicTrue&amp;gt;&amp;gt;&amp;gt; font.italic = False&amp;gt;&amp;gt;&amp;gt; font.italicFalse&amp;gt;&amp;gt;&amp;gt; font.italic = None&amp;gt;&amp;gt;&amp;gt; font.italicNone# 下划线&amp;gt;&amp;gt;&amp;gt; font.underlineNone&amp;gt;&amp;gt;&amp;gt; font.underline = True&amp;gt;&amp;gt;&amp;gt; # or perhaps&amp;gt;&amp;gt;&amp;gt; font.underline = WD_UNDERLINE.DOT_DASH# 字体颜色&amp;gt;&amp;gt;&amp;gt; from docx.shared import RGBColor&amp;gt;&amp;gt;&amp;gt; font.color.rgb = RGBColor(0x42, 0x24, 0xE9)# 示例第一段小标题p1_0 = new_doc.add_paragraph()p1_0.alignment = WD_PARAGRAPH_ALIGNMENT.LEFTfont_s = p1_0.add_run(&quot;Abstract&quot;)font_s.font.bold = Truefont_s.font.color.rgb = RGBColor(250, 0, 0)# 设置主题颜色&amp;gt;&amp;gt; from docx.enum.dml import MSO_THEME_COLOR&amp;gt;&amp;gt;&amp;gt; font.color.theme_color = MSO_THEME_COLOR.ACCENT_1# 示例p0 = new_doc.add_paragraph()p0.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER# 设置文字的样式，需要把文字写到run后面的文字中font_s = p0.add_run(text=&quot;Amir Ghaderi Borhan M. Sanandaji Faezeh Ghaderi&quot;)font_s.font.bold = True明白上面的属性之后，开始写一段代码from docx import Documentfrom docx.shared import Pt, RGBColor, Inchesfrom docx.enum.text import WD_PARAGRAPH_ALIGNMENTnew_doc = Document()# 设置标题head = new_doc.add_heading(text=&quot;Deep Forecast:Deep Learning-based Spatio-Temporal Forecasting&quot;)head.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER# 设置作者p0 = new_doc.add_paragraph()p0.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER# 设置文字的样式，需要把文字写到run后面的文字中font_s = p0.add_run(text=&quot;Amir Ghaderi Borhan M. Sanandaji Faezeh Ghaderi&quot;)font_s.font.bold = True# 第一段小标题p1_0 = new_doc.add_paragraph()p1_0.alignment = WD_PARAGRAPH_ALIGNMENT.LEFTfont_s = p1_0.add_run(&quot;Abstract&quot;)font_s.font.bold = Truefont_s.font.color.rgb = RGBColor(250, 0, 0)# 第一段内容p1 = new_doc.add_paragraph( &#39;The paper presents a spatio-temporal wind speed forecasting algorithm using Deep Learning (DL) and in particular, Recurrent Neural Networks(RNNs). Motivated by recent advances in renewable energy integration and smart grids, we apply our proposed algorithm for wind speed forecasting. Renewable energy resources (wind and solar)are random in nature and, thus, their integration is facilitated with accurate short-term forecasts.In our proposed framework, we model the spatiotemporal information by a graph whose nodes are data generating entities and its edges basically model how these nodes are interacting with each other. One of the main contributions of our work is the fact that we obtain forecasts of all nodes of the graph at the same time based on one framework. Results of a case study on recorded time series data from a collection of wind mills in the north-east of the U.S. show that the proposed DL-based forecasting algorithm significantly improves the short-term forecasts compared to a set of widely-used benchmarks models.&#39;)p1.alignment = WD_PARAGRAPH_ALIGNMENT.LEFTp1.style.font.size = Pt(10.5)p1.paragraph_format.first_line_indent = p1.style.font.size * 2# 第二段小标题p2_0 = new_doc.add_paragraph()p2_0.alignment = WD_PARAGRAPH_ALIGNMENT.LEFTfont_s = p2_0.add_run(&quot;1. Introduction&quot;)font_s.font.bold = True# 第二段内容p2 = new_doc.add_paragraph(&#39;&#39;&#39;Many countries in the world and many states in the U.S. have mandated aggressive Renewable Portfolio Standards (RPSs). Among different renewable energy resources, wind energy itself is expected to grow to provide between 15 to 25% of the world’s global electricity by 2050. According to another study, the world total wind power capacity has doubled every three years since 2000, reaching an installed capacity of 197 GW in 2010 and 369 GW in 2014 (CEC, 2013), (IEA, 2013). The random nature of wind, however, makes it difficult to achieve the power balance needed for its grid integration (Smith et al., 2007). The use of ancillary services such as frequency regulation and load following to compensate for such imbalances is facilitated by accurate forecasts (Hao et al., 2013), (Sanandaji et al., 2014). We present a spatio-temporal wind speed forecasting algorithm using Deep Learning (DL) and in particular, Recurrent Neural Networks (RNNs). In our proposed framework, we model the spatio-temporal information by a graph whose nodes are data generating entities and its edges model how these nodes are interacting with each other. One of the main contributions of our work is the fact that we obtain forecasts of all nodes of the graph at the same time and using one framework. One of the most important points is that we do not know the relationship between stations and the trained model determines which stations are more important to forecast one specific station. Our code and data are available at https://github.com/amirstar/Deep-Forecast One can directly attempt to forecast wind power. An alternative approach is to forecast the wind speed and then convert it to wind power using given power curves. This approach will accommodate different wind turbines installed in a wind farm experiencing the same wind speed profile but resulting in different wind power generation. We focus on wind speed forecasting in this paper. Wind speed forecasting methods can be categorized to different groups: (i) model-based methods such as Numerical Weather Prediction (NWP) vs. data-driven methods, (ii) point forecasting vs. probabilistic forecasting, and (iii) short-term forecasting vs. long-term forecasting. This paper is concerned with short-term point forecasting using both temporal data as well as spatial information. For a more complete survey of wind speed forecasting methods see (Zhu &amp;amp; Genton, 2012)&#39;&#39;&#39;)p2.alignment = WD_PARAGRAPH_ALIGNMENT.LEFTp2.paragraph_format.first_line_indent = p1.style.font.size * 2# 第三段小标题p3_0 = new_doc.add_paragraph()p3_0.alignment = WD_PARAGRAPH_ALIGNMENT.LEFTfont_s = p3_0.add_run(&quot;2. Related works&quot;)font_s.font.bold = True# 第三段内容p3 = new_doc.add_paragraph(&#39;&#39;&#39;Many countries in the world and many states in the U.S. have mandated aggressive Renewable Portfolio Standards (RPSs). Among different renewable energy resources, wind energy itself is expected to grow to provide between 15 to 25% of the world’s global electricity by 2050. According to another study, the world total wind power capacity has doubled every three years since 2000, reaching an installed capacity of 197 GW in 2010 and 369 GW in 2014 (CEC, 2013), (IEA, 2013). The random nature of wind, however, makes it difficult to achieve the power balance needed for its grid integration (Smith et al., 2007). The use of ancillary services such as frequency regulation and load following to compensate for such imbalances is facilitated by accurate forecasts (Hao et al., 2013), (Sanandaji et al., 2014). We present a spatio-temporal wind speed forecasting algorithm using Deep Learning (DL) and in particular, Recurrent Neural Networks (RNNs). In our proposed framework, we model the spatio-temporal information by a graph whose nodes are data generating entities and its edges model how these nodes are interacting with each other. One of the main contributions of our work is the fact that we obtain forecasts of all nodes of the graph at the same time and using one framework. One of the most important points is that we do not know the relationship between stations and the trained model determines which stations are more important to forecast one specific station. Our code and data are available at https://github.com/amirstar/Deep-Forecast One can directly attempt to forecast wind power. An alternative approach is to forecast the wind speed and then convert it to wind power using given power curves. This approach will accommodate different wind turbines installed in a wind farm experiencing the same wind speed profile but resulting in different wind power generation. We focus on wind speed forecasting in this paper. Wind speed forecasting methods can be categorized to different groups: (i) model-based methods such as Numerical Weather Prediction (NWP) vs. data-driven methods, (ii) point forecasting vs. probabilistic forecasting, and (iii) short-term forecasting vs. long-term forecasting. This paper is concerned with short-term point forecasting using both temporal data as well as spatial information. For a more complete survey of wind speed forecasting methods see (Zhu &amp;amp; Genton, 2012)Many countries in the world and many states in the U.S. have mandated aggressive Renewable Portfolio Standards (RPSs). Among different renewable energy resources, wind energy itself is expected to grow to provide between 15 to 25% of the world’s global electricity by 2050. According to another study, the world total wind power capacity has doubled every three years since 2000, reaching an installed capacity of 197 GW in 2010 and 369 GW in 2014 (CEC, 2013), (IEA, 2013). The random nature of wind, however, makes it difficult to achieve the power balance needed for its grid integration (Smith et al., 2007). The use of ancillary services such as frequency regulation and load following to compensate for such imbalances is facilitated by accurate forecasts (Hao et al., 2013), (Sanandaji et al., 2014). We present a spatio-temporal wind speed forecasting algorithm using Deep Learning (DL) and in particular, Recurrent Neural Networks (RNNs). In our proposed framework, we model the spatio-temporal information by a graph whose nodes are data generating entities and its edges model how these nodes are interacting with each other. One of the main contributions of our work is the fact that we obtain forecasts of all nodes of the graph at the same time and using one framework. One of the most important points is that we do not know the relationship between stations and the trained model determines which stations are more important to forecast one specific station. Our code and data are available at https://github.com/amirstar/Deep-Forecast One can directly attempt to forecast wind power. An alternative approach is to forecast the wind speed and then convert it to wind power using given power curves. This approach will accommodate different wind turbines installed in a wind farm experiencing the same wind speed profile but resulting in different wind power generation. We focus on wind speed forecasting in this paper. Wind speed forecasting methods can be categorized to different groups: (i) model-based methods such as Numerical Weather Prediction (NWP) vs. data-driven methods, (ii) point forecasting vs. probabilistic forecasting, and (iii) short-term forecasting vs. long-term forecasting. This paper is concerned with short-term point forecasting using both temporal data as well as spatial information. For a more complete survey of wind speed forecasting methods see (Zhu &amp;amp; Genton, 2012)Many countries in the world and many states in the U.S. have mandated aggressive Renewable Portfolio Standards (RPSs). Among different renewable energy resources, wind energy itself is expected to grow to provide between 15 to 25% of the world’s global electricity by 2050. According to another study, the world total wind power capacity has doubled every three years since 2000, reaching an installed capacity of 197 GW in 2010 and 369 GW in 2014 (CEC, 2013), (IEA, 2013). The random nature of wind, however, makes it difficult to achieve the power balance needed for its grid integration (Smith et al., 2007). The use of ancillary services such as frequency regulation and load following to compensate for such imbalances is facilitated by accurate forecasts (Hao et al., 2013), (Sanandaji et al., 2014). We present a spatio-temporal wind speed forecasting algorithm using Deep Learning (DL) and in particular, Recurrent Neural Networks (RNNs). In our proposed framework, we model the spatio-temporal information by a graph whose nodes are data generating entities and its edges model how these nodes are interacting with each other. One of the main contributions of our work is the fact that we obtain forecasts of all nodes of the graph at the same time and using one framework. One of the most important points is that we do not know the relationship between stations and the trained model determines which stations are more important to forecast one specific station. Our code and data are available at https://github.com/amirstar/Deep-Forecast One can directly attempt to forecast wind power. An alternative approach is to forecast the wind speed and then convert it to wind power using given power curves. This approach will accommodate different wind turbines installed in a wind farm experiencing the same wind speed profile but resulting in different wind power generation. We focus on wind speed forecasting in this paper. Wind speed forecasting methods can be categorized to different groups: (i) model-based methods such as Numerical Weather Prediction (NWP) vs. data-driven methods, (ii) point forecasting vs. probabilistic forecasting, and (iii) short-term forecasting vs. long-term forecasting. This paper is concerned with short-term point forecasting using both temporal data as well as spatial information. For a more complete survey of wind speed forecasting methods see (Zhu &amp;amp; Genton, 2012)Many countries in the world and many states in the U.S. have mandated aggressive Renewable Portfolio Standards (RPSs). Among different renewable energy resources, wind energy itself is expected to grow to provide between 15 to 25% of the world’s global electricity by 2050. According to another study, the world total wind power capacity has doubled every three years since 2000, reaching an installed capacity of 197 GW in 2010 and 369 GW in 2014 (CEC, 2013), (IEA, 2013). The random nature of wind, however, makes it difficult to achieve the power balance needed for its grid integration (Smith et al., 2007). The use of ancillary services such as frequency regulation and load following to compensate for such imbalances is facilitated by accurate forecasts (Hao et al., 2013), (Sanandaji et al., 2014). We present a spatio-temporal wind speed forecasting algorithm using Deep Learning (DL) and in particular, Recurrent Neural Networks (RNNs). In our proposed framework, we model the spatio-temporal information by a graph whose nodes are data generating entities and its edges model how these nodes are interacting with each other. One of the main contributions of our work is the fact that we obtain forecasts of all nodes of the graph at the same time and using one framework. One of the most important points is that we do not know the relationship between stations and the trained model determines which stations are more important to forecast one specific station. Our code and data are available at https://github.com/amirstar/Deep-Forecast One can directly attempt to forecast wind power. An alternative approach is to forecast the wind speed and then convert it to wind power using given power curves. This approach will accommodate different wind turbines installed in a wind farm experiencing the same wind speed profile but resulting in different wind power generation. We focus on wind speed forecasting in this paper. Wind speed forecasting methods can be categorized to different groups: (i) model-based methods such as Numerical Weather Prediction (NWP) vs. data-driven methods, (ii) point forecasting vs. probabilistic forecasting, and (iii) short-term forecasting vs. long-term forecasting. This paper is concerned with short-term point forecasting using both temporal data as well as spatial information. For a more complete survey of wind speed forecasting methods see (Zhu &amp;amp; Genton, 2012)&#39;&#39;&#39;)p3.alignment = WD_PARAGRAPH_ALIGNMENT.LEFTp3.paragraph_format.first_line_indent = p1.style.font.size * 2# 设置页眉header = new_doc.sections[0].header.paragraphs[0]header.add_run(&#39;Deep Forecast: Deep Learning-based Spatio-Temporal Forecasting&#39;)header.alignment = WD_PARAGRAPH_ALIGNMENT.CENTERnew_doc.settings.odd_and_even_pages_header_footer = True# 设置偶数页页眉section = new_doc.sections[0]even_page_header = section.even_page_header # 获取偶数页even_page_run = even_page_header.paragraphs[0].add_run(&#39;Tech Blogs&#39;)even_page_run.font.size = Pt(18) # 设置偶数页页眉大小even_page_header.paragraphs[0].alignment = WD_PARAGRAPH_ALIGNMENT.RIGHT# 设置页脚# todo 不清楚如何添加页码footer_page = section.footer.paragraphs[0]footer_page.add_run(&#39;Study hard and make progress everyday!&#39;)footer_page.alignment = WD_PARAGRAPH_ALIGNMENT.CENTEReven_page_footer_run = section.even_page_footer.paragraphs[0]even_page_footer_run.add_run(&#39;Knowledge is power&#39;)even_page_footer_run.alignment = WD_PARAGRAPH_ALIGNMENT.CENTERnew_doc.save(&quot;Tech Blogs v2.6.docx&quot;)参考链接：1. python-docx — python-docx 0.8.11 documentation2.浅谈python-docx的缩进问题——如何缩进两个字符3.python-docx设置页眉和页脚 (baidu.com)4.利用python自动写Word文档（三）——用Python-docx修改表格5.python-docx表格样式列表" }, { "title": "Python基操-正则表达式", "url": "/posts/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/", "categories": "Python", "tags": "Python基操", "date": "2020-03-30 00:00:00 +0800", "snippet": "1. 概念​ 在实际开发过程中，经常会有查找符合某些复杂规则的字符串的需要，比如:邮箱、图片地址、手机号码等，这时候想匹配或者查找符合某些规则的字符串就可以使用正则表达式了。​ 在Python中，提到正则表达式，首先肯定会想到re库，这是一个Python处理文本的标准库。import re2.使用方法2.1.查找一个匹配项​ 查找并返回一个匹配项的函数有3个：search、match、fullmatch，他们的区别分别是： 方法 说明 search 查找任意位置的匹配项 match 必须从字符串开头匹配 fullmatch 整个字符串与正则完全匹配 import reex_str = &quot;今夜阳光明媚，今夜多云转晴&quot;pattern = &quot;阳光&quot;print(&quot;search:&quot;, re.search(pattern, ex_str).group()) # 只要字符串中有一个阳光，就能返回结果print(&quot;match:&quot;, re.match(pattern, ex_str)) # 第一个出现的不是阳光，所以match不能匹配到，返回noneprint(&quot;match:&quot;, re.fullmatch(pattern, ex_str)) # ex_str中如果只有阳光两个字符，fullmatch才有返回值 &amp;gt;&amp;gt;&amp;gt;search: 阳光match: Nonematch: Noneimport re# 完整的案例ex_str = &quot;今夜阳光明媚，今夜多云转晴&quot;pattern = &quot;阳光&quot;print(&quot;search:&quot;, re.search(pattern, ex_str).group())print(&quot;match:&quot;, re.match(pattern, ex_str))print(&quot;match:&quot;, re.fullmatch(pattern, ex_str))print(&quot;---------------------------------------&quot;)ex_str = &quot;今夜阳光明媚，今夜多云转晴&quot;pattern = &quot;今夜阳光明媚&quot;print(&quot;search:&quot;, re.search(pattern, ex_str).group())print(&quot;match:&quot;, re.match(pattern, ex_str).group())print(&quot;match:&quot;, re.fullmatch(pattern, ex_str))print(&quot;---------------------------------------&quot;)ex_str = &quot;今夜阳光明媚，今夜多云转晴&quot;pattern = &quot;今夜阳光明媚，今夜多云转晴&quot;print(&quot;search:&quot;, re.search(pattern, ex_str).group())print(&quot;match:&quot;, re.match(pattern, ex_str).group())print(&quot;match:&quot;, re.fullmatch(pattern, ex_str).group())&amp;gt;&amp;gt;&amp;gt;search: 阳光match: Nonematch: None---------------------------------------search: 今夜阳光明媚match: 今夜阳光明媚match: None---------------------------------------search: 今夜阳光明媚，今夜多云转晴match: 今夜阳光明媚，今夜多云转晴match: 今夜阳光明媚，今夜多云转晴2.2 查找多个匹配项 方法 说明 findall 从字符串任意位置查找，返回一个列表 finditer 从字符串任意位置查找，返回一个迭代器 ​ 两个方法基本类似，只不过一个是返回列表，一个是返回迭代器。我们知道列表是一次性生成在内存中，而迭代器是需要使用时一点一点生成出来的，内存使用更优。import reex_str = &quot;今夜阳光明媚，今夜多云转晴&quot;pattern = &quot;今夜&quot;print(&quot;findall:&quot;, re.findall(pattern, ex_str))print(&quot;finditer:&quot;, re.finditer(pattern, ex_str))\\&amp;gt;&amp;gt;&amp;gt;findall: [&#39;今夜&#39;, &#39;今夜&#39;]finditer: &amp;lt;callable_iterator object at 0x00000247530E2640&amp;gt;​ 如果可能存在大量的匹配项的话，建议使用finditer函数，一般情况使用findall函数基本没啥影响。2.3 正则分割​ re.split(pattern, string, maxsplit=0, flags=0) 函数：用 pattern 分开 string ， maxsplit表示最多进行分割次数， flags表示模式，就是下面第三节讲解的常量！import reex_str = &quot;今天星期三，明天星期四，后天星期五&quot;pattern = &quot;星期&quot;print(&quot;split:&quot;, re.split(pattern, ex_str, maxsplit=3, flags=re.IGNORECASE)) # 正则分割比字符串的分割更加强大&amp;gt;&amp;gt;&amp;gt;split: [&#39;今天&#39;, &#39;三，明天&#39;, &#39;四，后天&#39;, &#39;五&#39;] # 注意：str模块也有一个 split函数 ，那这两个函数该怎么选呢？# str.split函数功能简单，不支持正则分割，而re.split支持正则。 ​ 试验证明，1000次循环以内str.split函数更快，而循环次数1000次以上后re.split函数明显更快，而且次数越多差距越大！所以结论是：在 不需要正则支持 且 数据量和数次不多 的情况下使用str.split函数更合适，反之则使用re.split函数。注：具体执行时间与测试数据有关！2.4 正则替换 方法 说明 sub re.sub(pattern, repl, string, count=0, flags=0) subn re.subn(pattern, repl, string, count=0, flags=0)     repl – 字符串，用来替换string中被pattern匹配到的字符；count – 最大替换次数flags – 正则表达式常量，参考第三节内容import re# sub ，返回一个替换后的字符串ex_str = &quot;今夜阳光明媚，今夜多云转晴&quot;pattern = &quot;今夜&quot;repl = &quot;明晚&quot;print(&quot;sub:&quot;, re.sub(pattern,repl, ex_str, count=2, flags=0))&amp;gt;&amp;gt;&amp;gt;sub: 明晚阳光明媚，明晚多云转晴 # subn,与sub类似，但是返回一个元组 (替换后的字符串，替换次数)ex_str = &quot;今夜阳光明媚，今夜多云转晴&quot;pattern = &quot;今夜&quot;repl = &quot;明晚&quot;print(&quot;subn:&quot;, re.subn(pattern,repl, ex_str, count=2, flags=0))&amp;gt;&amp;gt;&amp;gt;subn: (&#39;明晚阳光明媚，明晚多云转晴&#39;, 2)2.5 编译正则对象​ compile函数 与 template函数 将正则表达式的样式编译为一个 正则表达式对象 （正则对象Pattern），这个对象与re模块有同样的正则函数（后面我们会讲解Pattern正则对象）。import reex_str = &quot;今夜阳光明媚，今夜多云转晴&quot;pattern = &quot;阳光&quot;pattern_obj = re.compile(pattern)print(&quot;pattern_obj_search:&quot;, pattern_obj.search(ex_str).group())&amp;gt;&amp;gt;&amp;gt;pattern_obj_search: 阳光而template函数 与 compile函数 类似，只不过是增加了我们之前说的re.TEMPLATE 模式，我们可以看看源码。#源码当中增加了template模式def template(pattern, flags=0): &quot;Compile a template pattern, returning a Pattern object&quot; return _compile(pattern, flags|T)注意一下：官方文档推荐，在多次使用某个正则表达式时推荐使用正则对象Pattern 以增加复用性，因为通过 re.compile(pattern) 编译后的模块级函数会被缓存！3. re模块常量​ 在python 3.6 版本后，re模块使用了RegexFlag类进行了集成，在python3.6版本前都是散装的常量。# ----- re variables and constants -----if sys.version_info &amp;gt;= (3, 6): import enum class RegexFlag(enum.IntFlag): A = 0 ASCII = 0 DEBUG = 0 I = 0 IGNORECASE = 0 L = 0 LOCALE = 0 M = 0 MULTILINE = 0 S = 0 DOTALL = 0 X = 0 VERBOSE = 0 U = 0 UNICODE = 0 T = 0 TEMPLATE = 0 A = RegexFlag.A ASCII = RegexFlag.ASCII DEBUG = RegexFlag.DEBUG I = RegexFlag.I IGNORECASE = RegexFlag.IGNORECASE L = RegexFlag.L LOCALE = RegexFlag.LOCALE M = RegexFlag.M MULTILINE = RegexFlag.MULTILINE S = RegexFlag.S DOTALL = RegexFlag.DOTALL X = RegexFlag.X VERBOSE = RegexFlag.VERBOSE U = RegexFlag.U UNICODE = RegexFlag.UNICODE T = RegexFlag.T TEMPLATE = RegexFlag.TEMPLATE _FlagsType = Union[int, RegexFlag]else: A = 0 ASCII = 0 DEBUG = 0 I = 0 IGNORECASE = 0 L = 0 LOCALE = 0 M = 0 MULTILINE = 0 S = 0 DOTALL = 0 X = 0 VERBOSE = 0 U = 0 UNICODE = 0 T = 0 TEMPLATE = 0 _FlagsType = int3.1 IGNORECASE 语法 作用 re.IGNORECASE或简写为 re.I 进行忽略大小写匹配(默认匹配模式下,大写字母B无法匹配小写字母b，使用re.IGNORECASE 忽略大小写 模式下是可以的。) import reex_str = &quot;今天星期三(Wednesday)，明天星期四(Thursday)，后天星期五(Friday)&quot;pattern = r&quot;DAY&quot;print(&quot;re.IGNORECASE:&quot;, re.findall(pattern, ex_str, re.IGNORECASE))&amp;gt;&amp;gt;&amp;gt;re.IGNORECASE: [&#39;day&#39;, &#39;day&#39;, &#39;day&#39;]3.2 ASCII 语法 说明 re.ASCII 或简写为 re.A ASCII表示ASCII码的意思，让 \\w, \\W, \\b, \\B, \\d, \\D, \\s 和 \\S 只匹配ASCII，而不是Unicode。 import reex_str = &quot;今天星期三(Wednesday)，明天星期四(Thursday)，后天星期五(Friday)&quot;pattern = r&quot;\\w+&quot;print(&quot;re.ASCII:&quot;, re.findall(pattern, ex_str, re.ASCII))&amp;gt;&amp;gt;&amp;gt;re.ASCII: [&#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;] # 注意：这只对字符串匹配模式有效，对字节匹配模式无效。 3.3 DOTALL​ 默认匹配情况下，换行符不能被匹配，使用DOTALL能够匹配所有 语法 说明 re.DOTALL 或简写为 re.S DOT表示.；ALL表示所有；连起来就是匹配所有 import reex_str = &quot;今天星期三(Wednesday)，\\n 明天星期四(Thursday)，\\n 后天星期五(Friday)&quot;pattern = r&quot;.*&quot;print(&quot;常规匹配:&quot;, re.findall(pattern, ex_str))print(&quot;re.DOTALL:&quot;, re.findall(pattern, ex_str, re.DOTALL))&amp;gt;&amp;gt;&amp;gt;常规匹配: [&#39;今天星期三(Wednesday)，&#39;, &#39;&#39;, &#39; 明天星期四(Thursday)，&#39;, &#39;&#39;, &#39; 后天星期五(Friday)&#39;, &#39;&#39;]re.DOTALL: [&#39;今天星期三(Wednesday)，\\n 明天星期四(Thursday)，\\n 后天星期五(Friday)&#39;, &#39;&#39;]其他几个常量，平时用处不大，暂时不记录： 如MULTILINE、VERBOSE；两个（LOCALE、UNICODE）官方不建议使用、两个（TEMPLATE、DEBUG）试验性功能，不能依赖。4.常用的正则表达式 表达式 含义   ^ 匹配字符串的开头   $ 匹配字符串的末尾   . 匹配任意字符，除了换行符。 当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。   […] 匹配中括号中列出的字符。如 [amk] 匹配 ‘a’，’m’或’k’   [^…] 匹配不在[]中的字符，中括号中的^是非的意思.如[^abc]匹配除了a,b,c之外的字符。   * 匹配0个或多个字符   + 匹配1个或多个字符   ex_str？ 匹配0个或1个ex_str表达式定义的片段，贪婪方式   ex_str{ n} 精确匹配n个ex_str表达式定义的片段，如o{2}匹配foo中的oo   ex_str{ n,} 匹配大于n个ex_str表达式定义的片段，如o{2,}匹配fooooo中的ooooo   ex_str{ n, m} 匹配 n 到 m 次ex_str表达式定义的片段，贪婪方式，如o{1,4}匹配fooooood中的前4个o   (ex_str) 匹配括号内的字符串以一个组出现，顺序固定；如(abc)匹配cabdadcabc匹配最后三个字符abc   (ex_str1 ex_str2) 匹配ex_str1或ex_str2       4.1 表示字符 字符 功能 . 匹配任意1个字符（除了\\n） [ ] 匹配[ ]中列举的字符 \\d 匹配数字，即0-9 \\D 匹配非数字，即不是数字 \\s 匹配空白，即 空格，tab键 \\S 匹配非空白 \\w 匹配单词字符，即a-z、A-Z、0-9、_ \\W 匹配非单词字符 4.2 表示数量 字符 功能 * 匹配前一个字符出现0次或者无限次，即可有可无 + 匹配前一个字符出现1次或者无限次，即至少有1次 ? 匹配前一个字符出现1次或者0次，即要么有1次，要么没有 {m} 匹配前一个字符出现m次 {m,} 匹配前一个字符至少出现m次 {m,n} 匹配前一个字符出现从m到n次 4.3 表示边界 字符 功能 ^ 匹配字符串开头 $ 匹配字符串结尾 \\b 匹配一个单词的边界 \\B 匹配非单词边界 4.4 匹配分组 字符 功能 | 匹配左右任意一个表达式 (ab) 将括号中字符作为一个分组 \\num 引用分组num匹配到的字符串 (?P&amp;lt;name&amp;gt;) 分组起别名 (?P=name) 引用别名为name分组匹配到的字符串 4.4 常用的匹配 匹配目标 表达式 数字： 匹配字符串中任意数量的数字 \\d+ 数字： 匹配字符串中n个数字 \\d{n} 数字： 匹配字符串中至少n个数字 \\d{n,} 数字： 匹配字符串中m到n个数字的组合 \\d{m,n} 数字： 匹配字符串中的小数 \\d+\\.\\d 数字： 匹配负数 \\-\\d) 数字： 匹配负数小数 \\-\\d+\\.\\d+ 数字： 匹配数字（正数整数，负数整数，正数小数，负数小数） \\-?\\d+\\.?\\d+ 数字： 匹配非0开头的数字 [1-9]\\d+ 数字： 匹配有1~3位小数的正实数 [1-9]+\\.[0-9]{1,3} 匹配目标 表达式 字符：汉字 [\\u4e00-\\u9fa5]+ 字符+数字：英文+数字 [A-Za-z0-9]+ 字符+数字+特殊字符 \\w+ 字符+数字+特殊字符：中文、英文、数字但不包括下划线 [\\u4E00-\\u9FA5A-Za-z0-9]+ 匹配目标 表达式 取反操作：除了英文字符、空格字符外的所有字符 [^a-zA-Z\\s] E-mail地址 \\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)* 域名 [a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? 日期 ^\\d{4}-\\d{1,2}-\\d{1,2} IP地址(提取) \\d+\\.\\d+\\.\\d+\\.\\d+ 空白行 \\n\\s*\\r 详细代码见： https://github.com/CarmanZheng/Blog_codes/tree/main/20200329%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F参考文献：https://zhuanlan.zhihu.com/p/127807805" }, { "title": "Python基操-多进程与多线程", "url": "/posts/Python-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/", "categories": "Python", "tags": "Python基操", "date": "2020-03-29 00:00:00 +0800", "snippet": "1.概念​ 进程（process）和线程（thread）是操作系统的基本概念，但是它们比较抽象，不容易掌握。关于多进程和多线程，教科书上最经典的一句话是“进程是资源分配的最小单位，线程是CPU调度的最小单位”。​ 线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位指运行中的程序的调度单位。在单个程序中同时运行多个线程完成不同的工作，称为多线程。2.进程与线程区别​ 进程是资源分配的基本单位。所有与该进程有关的资源，都被记录在进程控制块PCB中。以表示该进程拥有这些资源或正在使用它们。另外，进程也是抢占处理机的调度单位，它拥有一个完整的虚拟地址空间。当进程发生调度时，不同的进程拥有不同的虚拟地址空间，而同一进程内的不同线程共享同一地址空间。​ 与进程相对应，线程与资源分配无关，它属于某一个进程，并与进程内的其他线程一起共享进程的资源。线程只由相关堆栈（系统栈或用户栈）寄存器和线程控制表TCB组成。寄存器可被用来存储线程内的局部变量，但不能存储其他线程的相关变量。线程与进程的区别可以归纳为以下4点： 地址空间和其它资源（如打开文件）：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。 通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。 调度和切换：线程上下文切换比进程上下文切换要快得多。 在多线程OS中，进程不是一个可执行的实体。总结，进程和线程还可以类比为火车和车厢,下面的例子很形象： 线程在进程下行进（单纯的车厢无法运行） 一个进程可以包含多个线程（一辆火车可以有多个车厢） 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘） 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易） 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源） 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到该趟火车的所有车厢） 进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上） 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－”互斥锁（mutex）” 进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量（semaphore）”3.Python全局解释器锁GIL​ 全局解释器锁（英语：Global Interpreter Lock，缩写GIL），并不是Python的特性，它是在实现Python解析器（CPython）时所引入的一个概念。由于CPython是大部分环境下默认的Python执行环境。所以在很多人的概念里CPython就是Python，也就想当然的把GIL归结为Python语言的缺陷。​ Python代码的执行由Python 虚拟机(也叫解释器主循环，CPython版本)来控制，Python 在设计之初就考虑到要在解释器的主循环中，同时只有一个线程在执行，即在任意时刻，只有一个线程在解释器中运行。对Python 虚拟机的访问由全局解释器锁（GIL）来控制，正是这个锁能保证同一时刻只有一个线程在运行。GIL 有什么好处？简单来说，它在单线程的情况更快，并且在和 C 库结合时更方便，而且不用考虑线程安全问题，这也是早期 Python 最常见的应用场景和优势。另外，GIL的设计简化了CPython的实现，使得对象模型，包括关键的内建类型如字典，都是隐含可以并发访问的。锁住全局解释器使得比较容易的实现对多线程的支持，但也损失了多处理器主机的并行计算能力。在多线程环境中，Python 虚拟机按以下方式执行： 设置GIL 切换到一个线程去运行 运行直至指定数量的字节码指令，或者线程主动让出控制（可以调用sleep(0)） 把线程设置为睡眠状态 解锁GIL 再次重复以上所有步骤Python3.2前，GIL的释放逻辑是当前线程遇见IO操作或者ticks计数达到100（ticks可以看作是python自身的一个计数器，专门做用于GIL，每次释放后归零，这个计数可以通过 sys.setcheckinterval 来调整），进行释放。因为计算密集型线程在释放GIL之后又会立即去申请GIL，并且通常在其它线程还没有调度完之前它就已经重新获取到了GIL，就会导致一旦计算密集型线程获得了GIL，那么它在很长一段时间内都将占据GIL，甚至一直到该线程执行结束。Python 3.2开始使用新的GIL。新的GIL实现中用一个固定的超时时间来指示当前的线程放弃全局锁。在当前线程保持这个锁，且其他线程请求这个锁时，当前线程就会在5毫秒后被强制释放该锁。该改进在单核的情况下，对于单个线程长期占用GIL的情况有所好转。在单核CPU上，数百次的间隔检查才会导致一次线程切换。在多核CPU上，存在严重的线程颠簸（thrashing）。而每次释放GIL锁，线程进行锁竞争、切换线程，会消耗资源。单核下多线程，每次释放GIL，唤醒的那个线程都能获取到GIL锁，所以能够无缝执行，但多核下，CPU0释放GIL后，其他CPU上的线程都会进行竞争，但GIL可能会马上又被CPU0拿到，导致其他几个CPU上被唤醒后的线程会醒着等待到切换时间后又进入待调度状态，这样会造成线程颠簸(thrashing)，导致效率更低。另外，从上面的实现机制可以推导出，Python的多线程对IO密集型代码要比CPU密集型代码更加友好。针对GIL的应对措施： 使用更高版本Python（对GIL机制进行了优化） 使用多进程替换多线程（多进程之间没有GIL，但是进程本身的资源消耗较多） 指定cpu运行线程（使用affinity模块） 使用Jython、IronPython等无GIL解释器 全IO密集型任务时才使用多线程 使用协程（高效的单线程模式，也称微线程；通常与多进程配合使用） 将关键组件用C/C++编写为Python扩展，通过ctypes使Python程序直接调用C语言编译的动态链接库的导出函数。（with nogil调出GIL限制）4.Python的多进程包multiprocessing​ Python的threading包主要运用多线程的开发，但由于GIL的存在，Python中的多线程其实并不是真正的多线程，如果想要充分地使用多核CPU的资源，大部分情况需要使用多进程。在Python 2.6版本的时候引入了multiprocessing包，它完整的复制了一套threading所提供的接口方便迁移。唯一的不同就是它使用了多进程而不是多线程。每个进程有自己的独立的GIL，因此也不会出现进程之间的GIL争抢。​ 借助这个multiprocessing，你可以轻松完成从单进程到并发执行的转换。multiprocessing支持子进程、通信和共享数据、执行不同形式的同步，提供了Process、Queue、Pipe、Lock等组件。4.1 Multiprocessing产生的背景除了应对Python的GIL以外，产生multiprocessing的另外一个原因时Windows操作系统与Linux/Unix系统的不一致。Unix/Linux操作系统提供了一个fork()系统调用，它非常特殊。普通的函数，调用一次，返回一次，但是fork()调用一次，返回两次，因为操作系统自动把当前进程（父进程）复制了一份（子进程），然后，分别在父进程和子进程内返回。子进程永远返回0，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getpid()就可以拿到父进程的ID。Python的os模块封装了常见的系统调用，其中就包括fork，可以在Python程序中轻松创建子进程：import osprint(&#39;Process (%s) start...&#39; % os.getpid())# Only works on Unix/Linux/Mac:pid = os.fork()if pid == 0: print(&#39;I am child process (%s) and my parent is %s.&#39; % (os.getpid(), os.getppid()))else: print(&#39;I (%s) just created a child process (%s).&#39; % (os.getpid(), pid))上述代码在Linux、Unix和Mac上的执行结果为：Process (876) start...I (876) just created a child process (877).I am child process (877) and my parent is 876.​ 有了fork调用，一个进程在接到新任务时就可以复制出一个子进程来处理新任务，常见的Apache服务器就是由父进程监听端口，每当有新的http请求时，就fork出子进程来处理新的http请求。​ 由于Windows没有fork调用，上面的代码在Windows上无法运行。由于Python是跨平台的，自然也应该提供一个跨平台的多进程支持。multiprocessing模块就是跨平台版本的多进程模块。multiprocessing模块封装了fork()调用，使我们不需要关注fork()的细节。由于Windows没有fork调用，因此，multiprocessing需要“模拟”出fork的效果。4.2 multiprocessing常用组件及功能​ 创建管理进程模块： Process（用于创建进程） Pool（用于创建管理进程池） Queue（用于进程通信，资源共享） Value，Array（用于进程通信，资源共享） Pipe（用于管道通信） Manager（用于资源共享）同步子进程模块： Condition（条件变量） Event（事件） Lock（互斥锁） RLock（可重入的互斥锁(同一个进程可以多次获得它，同时不会造成阻塞) Semaphore（信号量）接下来就一起来学习下每个组件及功能的具体使用方法。5.multiprocessing的使用5.1 Process（用于创建进程）​ multiprocessing模块提供了一个Process类来代表一个进程对象。​ 在multiprocessing中，每一个进程都用一个Process类来表示。构造方法：Process([group [, target [, name [, args [, kwargs]]]]]) group：分组，实际上不使用，值始终为None target：表示调用对象，即子进程要执行的任务，你可以传入方法名（函数名） name：为子进程设定名称 args：要传给target函数的位置参数，以元组方式进行传入。 kwargs：要传给target函数的字典参数，以字典方式进行传入。实例方法： start()：启动进程，并调用该子进程中的p.run() run()：进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法 terminate()：强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况（会产生僵尸进程）。如果p还保存了一个锁那么也将不会被释放，进而导致死锁 is_alive()：返回进程是否在运行。如果p仍然运行，返回True join([timeout])：进程同步，主进程等待子进程完成后再执行后面的代码。线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间（超过这个时间，父线程不再等待子线程，继续往下执行），需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程属性介绍： daemon：默认值为False，如果设为True，代表p为后台运行的守护进程；当p的父进程终止时，p也随之终止，并且设定为True后，p不能创建自己的新进程（因为p是守护进程的子进程）；必须在p.start()之前设置 name：进程的名称 pid：进程的pid exitcode：进程在运行时为None、如果为–N，表示被信号N结束(了解即可) authkey：进程的身份验证键,默认是由os.urandom()随机生成的32字符的字符串。这个键的用途是为涉及网络连接的底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功（了解即可）使用示例：（注意：在windows中Process()必须放到if name == &quot;main&quot;:下）from multiprocessing import Processimport osdef run_proc(name): print(&#39;Run child process %s (%s)...&#39; % (name, os.getpid()))if __name__==&#39;__main__&#39;: print(&#39;Parent process %s.&#39; % os.getpid()) p = Process(target=run_proc, args=(&#39;test&#39;,)) print(&#39;Child process will start.&#39;) p.start() p.join()print(&#39;Child process end.&#39;)5.2 Pool（用于创建管理进程池）​ Pool类用于需要执行的目标很多，而手动限制进程数量又太繁琐时，如果目标少且不用控制进程数量则可以用Process类。Pool可以提供指定数量的进程，供用户调用，当有新的请求提交到Pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到规定最大值，那么该请求就会等待，直到池中有进程结束，就重用进程池中的进程。构造方法：Pool([processes[, initializer[, initargs[, maxtasksperchild[, context]]]]]) processes ：要创建的进程数，如果省略，将默认使用cpu_count()返回的数量。 initializer：每个工作进程启动时要执行的可调用对象，默认为None。如果initializer是None，那么每一个工作进程在开始的时候会调用initializer(*initargs)。 initargs：是要传给initializer的参数组。 maxtasksperchild：工作进程退出之前可以完成的任务数，完成后用一个新的工作进程来替代原进程，来让闲置的资源被释放。maxtasksperchild默认是None，意味着只要Pool存在工作进程就会一直存活。 context: 用在制定工作进程启动时的上下文，一般使用Pool() 或者一个context对象的Pool()方法来创建一个池，两种方法都适当的设置了context。实例方法： apply(func[, args[, kwargs]])：在一个池工作进程中执行func(args,*kwargs),然后返回结果。需要强调的是：此操作并不会在所有池工作进程中并执行func函数。如果要通过不同参数并发地执行func函数，必须从不同线程调用p.apply()函数或者使用p.apply_async()。它是阻塞的。apply很少使用 apply_async(func[, arg[, kwds={}[, callback=None]]])：在一个池工作进程中执行func(args,*kwargs),然后返回结果。此方法的结果是AsyncResult类的实例，callback是可调用对象，接收输入参数。当func的结果变为可用时，将理解传递给callback。callback禁止执行任何阻塞操作，否则将接收其他异步操作中的结果。它是非阻塞。 map(func, iterable[, chunksize=None])：Pool类中的map方法，与内置的map函数用法行为基本一致，它会使进程阻塞直到返回结果。注意，虽然第二个参数是一个迭代器，但在实际使用中，必须在整个队列都就绪后，程序才会运行子进程。 map_async(func, iterable[, chunksize=None])：map_async与map的关系同apply与apply_async imap()：imap 与 map的区别是，map是当所有的进程都已经执行完了，并将结果返回了，imap()则是立即返回一个iterable可迭代对象。 imap_unordered()：不保证返回的结果顺序与进程添加的顺序一致。 close()：关闭进程池，防止进一步操作。如果所有操作持续挂起，它们将在工作进程终止前完成。 join()：等待所有工作进程退出。此方法只能在close()或teminate()之后调用，让其不再接受新的Process。 terminate()：结束工作进程，不再处理未处理的任务。方法apply_async()和map_async()的返回值是AsyncResul的实例obj。实例具有以下方法： get()：返回结果，如果有必要则等待结果到达。timeout是可选的。如果在指定时间内还没有到达，将引发异常。如果远程操作中引发了异常，它将在调用此方法时再次被引发。 ready()：如果调用完成，返回True successful()：如果调用完成且没有引发异常，返回True，如果在结果就绪之前调用此方法，引发异常 wait([timeout])：等待结果变为可用。 terminate()：立即终止所有工作进程，同时不执行任何清理或结束任何挂起工作。如果p被垃圾回收，将自动调用此函数使用示例：\\# -*- coding:utf-8 -*-\\# Pool+mapfrom multiprocessing import Pooldef test(i): print(i)if __name__ == &quot;__main__&quot;: lists = range(100) pool = Pool(8) pool.map(test, lists) pool.close() pool.join()# -*- coding:utf-8 -*-# 异步进程池（非阻塞）from multiprocessing import Pooldef test(i): print(i)if __name__ == &quot;__main__&quot;: pool = Pool(8) for i in range(100): &#39;&#39;&#39; For循环中执行步骤： （1）循环遍历，将100个子进程添加到进程池（相对父进程会阻塞） （2）每次执行8个子进程，等一个子进程执行完后，立马启动新的子进程。（相对父进程不阻塞） apply_async为异步进程池写法。异步指的是启动子进程的过程，与父进程本身的执行（print）是异步的，而For循环中往进程池添加子进程的过程，与父进程本身的执行却是同步的。 &#39;&#39;&#39; pool.apply_async(test, args=(i,)) # 维持执行的进程总数为8，当一个进程执行完后启动一个新进程. print(&quot;test&quot;) pool.close() pool.join()# -*- coding:utf-8 -*-# 异步进程池（非阻塞）from multiprocessing import Pooldef test(i): print(i) if __name__ == &quot;__main__&quot;: pool = Pool(8) for i in range(100): &#39;&#39;&#39; 实际测试发现，for循环内部执行步骤： （1）遍历100个可迭代对象，往进程池放一个子进程 （2）执行这个子进程，等子进程执行完毕，再往进程池放一个子进程，再执行。（同时只执行一个子进程） for循环执行完毕，再执行print函数。 &#39;&#39;&#39; pool.apply(test, args=(i,)) # 维持执行的进程总数为8，当一个进程执行完后启动一个新进程. print(&quot;test&quot;) pool.close() pool.join()5.3 Queue（用于进程通信，资源共享）​ 在使用多进程的过程中，最好不要使用共享资源。普通的全局变量是不能被子进程所共享的，只有通过Multiprocessing组件构造的数据结构可以被共享。​ Queue是用来创建进程间资源共享的队列的类，使用Queue可以达到多进程间数据传递的功能（缺点：只适用Process类，不能在Pool进程池中使用）。构造方法：Queue([maxsize]) maxsize是队列中允许最大项数，省略则无大小限制。实例方法： put()：用以插入数据到队列。put方法还有两个可选参数：blocked和timeout。如果blocked为True（默认值），并且timeout为正值，该方法会阻塞timeout指定的时间，直到该队列有剩余的空间。如果超时，会抛出Queue.Full异常。如果blocked为False，但该Queue已满，会立即抛出Queue.Full异常。 get()：可以从队列读取并且删除一个元素。get方法有两个可选参数：blocked和timeout。如果blocked为True（默认值），并且timeout为正值，那么在等待时间内没有取到任何元素，会抛出Queue.Empty异常。如果blocked为False，有两种情况存在，如果Queue有一个值可用，则立即返回该值，否则，如果队列为空，则立即抛出Queue.Empty异常。若不希望在empty的时候抛出异常，令blocked为True或者参数全部置空即可。 get_nowait()：同q.get(False) put_nowait()：同q.put(False) empty()：调用此方法时q为空则返回True，该结果不可靠，比如在返回True的过程中，如果队列中又加入了项目。 full()：调用此方法时q已满则返回True，该结果不可靠，比如在返回True的过程中，如果队列中的项目被取走。 qsize()：返回队列中目前项目的正确数量，结果也不可靠，理由同q.empty()和q.full()一样使用示例：from multiprocessing import Process, Queueimport os, time, randomdef write(q): print(&#39;Process to write: %s&#39; % os.getpid()) for value in [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]: print(&#39;Put %s to queue...&#39; % value) q.put(value) time.sleep(random.random())def read(q): print(&#39;Process to read: %s&#39; % os.getpid()) while True: value = q.get(True) print(&#39;Get %s from queue.&#39; % value)if __name__ == &quot;__main__&quot;: q = Queue() pw = Process(target=write, args=(q,)) pr = Process(target=read, args=(q,)) pw.start() pr.start() pw.join() # 等待pw结束 pr.terminate() # pr进程里是死循环，无法等待其结束，只能强行终止​ JoinableQueue就像是一个Queue对象，但队列允许项目的使用者通知生成者项目已经被成功处理。通知进程是使用共享的信号和条件变量来实现的。构造方法：JoinableQueue([maxsize]) maxsize：队列中允许最大项数，省略则无大小限制。实例方法​ JoinableQueue的实例p除了与Queue对象相同的方法之外还具有： task_done()：使用者使用此方法发出信号，表示q.get()的返回项目已经被处理。如果调用此方法的次数大于从队列中删除项目的数量，将引发ValueError异常 join():生产者调用此方法进行阻塞，直到队列中所有的项目均被处理。阻塞将持续到队列中的每个项目均调用q.task_done（）方法为止使用示例：# -*- coding:utf-8 -*-from multiprocessing import Process, JoinableQueueimport time, randomdef consumer(q): while True: res = q.get() print(&#39;消费者拿到了 %s&#39; % res) q.task_done()def producer(seq, q): for item in seq: time.sleep(random.randrange(1,2)) q.put(item) print(&#39;生产者做好了 %s&#39; % item) q.join()if __name__ == &quot;__main__&quot;: q = JoinableQueue() seq = (&#39;产品%s&#39; % i for i in range(5)) p = Process(target=consumer, args=(q,)) p.daemon = True # 设置为守护进程，在主线程停止时p也停止，但是不用担心，producer内调用q.join保证了consumer已经处理完队列中的所有元素 p.start() producer(seq, q) print(&#39;主线程&#39;)5.4 Value，Array（用于进程通信，资源共享）multiprocessing 中Value和Array的实现原理都是在共享内存中创建ctypes()对象来达到共享数据的目的，两者实现方法大同小异，只是选用不同的ctypes数据类型而已。Value构造方法：Value((typecode_or_type, args[, lock]) typecode_or_type：定义ctypes()对象的类型，可以传Type code或 C Type，具体对照表见下文。 args：传递给typecode_or_type构造函数的参数 lock：默认为True，创建一个互斥锁来限制对Value对象的访问，如果传入一个锁，如Lock或RLock的实例，将用于同步。如果传入False，Value的实例就不会被锁保护，它将不是进程安全的。typecode_or_type支持的类型：| Type code | C Type | Python Type | Minimum size in bytes || --------- | ------------------ | ----------------- | --------------------- || `&#39;b&#39;` | signed char | int | 1 || `&#39;B&#39;` | unsigned char | int | 1 || `&#39;u&#39;` | Py_UNICODE | Unicode character | 2 || `&#39;h&#39;` | signed short | int | 2 || `&#39;H&#39;` | unsigned short | int | 2 || `&#39;i&#39;` | signed int | int | 2 || `&#39;I&#39;` | unsigned int | int | 2 || `&#39;l&#39;` | signed long | int | 4 || `&#39;L&#39;` | unsigned long | int | 4 || `&#39;q&#39;` | signed long long | int | 8 || `&#39;Q&#39;` | unsigned long long | int | 8 || `&#39;f&#39;` | float | float | 4 || `&#39;d&#39;` | double | float | 8 |参考地址：https://docs.python.org/3/library/array.htmlArray构造方法：Array(typecode_or_type, size_or_initializer, **kwds[, lock]) typecode_or_type：同上 size_or_initializer：如果它是一个整数，那么它确定数组的长度，并且数组将被初始化为零。否则，size_or_initializer是用于初始化数组的序列，其长度决定数组的长度。 kwds：传递给typecode_or_type构造函数的参数 lock：同上使用示例：import multiprocessingdef f(n, a): n.value = 3.14 a[0] = 5if __name__ == &#39;__main__&#39;: num = multiprocessing.Value(&#39;d&#39;, 0.0) arr = multiprocessing.Array(&#39;i&#39;, range(10)) p = multiprocessing.Process(target=f, args=(num, arr)) p.start() p.join() print(num.value) print(arr[:])注意：Value和Array只适用于Process类。5.5 Pipe（用于管道通信）​ 多进程还有一种数据传递方式叫管道原理和 Queue相同。Pipe可以在进程之间创建一条管道，并返回元组（conn1,conn2）,其中conn1，conn2表示管道两端的连接对象，强调一点：必须在产生Process对象之前产生管道。构造方法：Pipe([duplex]) dumplex:默认管道是全双工的，如果将duplex射成False，conn1只能用于接收，conn2只能用于发送。实例方法： send(obj)：通过连接发送对象。obj是与序列化兼容的任意对象 recv()：接收conn2.send(obj)发送的对象。如果没有消息可接收，recv方法会一直阻塞。如果连接的另外一端已经关闭，那么recv方法会抛出EOFError。 close(): 关闭连接。如果conn1被垃圾回收，将自动调用此方法 fileno(): 返回连接使用的整数文件描述符 poll([timeout]): 如果连接上的数据可用，返回True。timeout指定等待的最长时限。如果省略此参数，方法将立即返回结果。如果将timeout射成None，操作将无限期地等待数据到达。 recv_bytes([maxlength]): 接收c.send_bytes()方法发送的一条完整的字节消息。maxlength指定要接收的最大字节数。如果进入的消息，超过了这个最大值，将引发IOError异常，并且在连接上无法进行进一步读取。如果连接的另外一端已经关闭，再也不存在任何数据，将引发EOFError异常。 send_bytes(buffer [, offset [, size]])：通过连接发送字节数据缓冲区，buffer是支持缓冲区接口的任意对象，offset是缓冲区中的字节偏移量，而size是要发送字节数。结果数据以单条消息的形式发出，然后调用c.recv_bytes()函数进行接收 recv_bytes_into(buffer [, offset]):接收一条完整的字节消息，并把它保存在buffer对象中，该对象支持可写入的缓冲区接口（即bytearray对象或类似的对象）。offset指定缓冲区中放置消息处的字节位移。返回值是收到的字节数。如果消息长度大于可用的缓冲区空间，将引发BufferTooShort异常。使用示例：from multiprocessing import Process, Pipeimport time# 子进程执行方法def f(Subconn): time.sleep(1) Subconn.send(&quot;吃了吗&quot;) print(&quot;来自父亲的问候:&quot;, Subconn.recv()) Subconn.close()if __name__ == &quot;__main__&quot;: parent_conn, child_conn = Pipe() # 创建管道两端 p = Process(target=f, args=(child_conn,)) # 创建子进程 p.start() print(&quot;来自儿子的问候:&quot;, parent_conn.recv()) parent_conn.send(&quot;嗯&quot;)5.6 Manager（用于资源共享）​ Manager()返回的manager对象控制了一个server进程，此进程包含的python对象可以被其他的进程通过proxies来访问。从而达到多进程间数据通信且安全。Manager模块常与Pool模块一起使用。​ Manager支持的类型有list,dict,Namespace,Lock,RLock,Semaphore,BoundedSemaphore,Condition,Event,Queue,Value和Array。​ 管理器是独立运行的子进程，其中存在真实的对象，并以服务器的形式运行，其他进程通过使用代理访问共享对象，这些代理作为客户端运行。Manager()是BaseManager的子类，返回一个启动的SyncManager()实例，可用于创建共享对象并返回访问这些共享对象的代理。BaseManager，创建管理器服务器的基类构造方法：BaseManager([address[, authkey]]) address：(hostname，port)，指定服务器的网址地址，默认为简单分配一个空闲的端口 authkey：连接到服务器的客户端的身份验证，默认为current_process().authkey的值实例方法： start([initializer[, initargs]])：启动一个单独的子进程，并在该子进程中启动管理器服务器 get_server()：获取服务器对象 connect()：连接管理器对象 shutdown()：关闭管理器对象，只能在调用了start()方法之后调用实例属性： address：只读属性，管理器服务器正在使用的地址SyncManager，**以下类型均不是进程安全的，需要加锁..实例方法： Array(self,*args,**kwds) BoundedSemaphore(self,*args,**kwds) Condition(self,*args,**kwds) Event(self,*args,**kwds) JoinableQueue(self,*args,**kwds) Lock(self,*args,**kwds) Namespace(self,*args,**kwds) Pool(self,*args,**kwds) Queue(self,*args,**kwds) RLock(self,*args,**kwds) Semaphore(self,*args,**kwds) Value(self,*args,**kwds) dict(self,*args,**kwds) list(self,*args,**kwds)使用示例：import multiprocessingdef f(x, arr, l, d, n): x.value = 3.14 arr[0] = 5 l.append(&#39;Hello&#39;) d[1] = 2 n.a = 10if __name__ == &#39;__main__&#39;: server = multiprocessing.Manager() x = server.Value(&#39;d&#39;, 0.0) arr = server.Array(&#39;i&#39;, range(10)) l = server.list() d = server.dict() n = server.Namespace() proc = multiprocessing.Process(target=f, args=(x, arr, l, d, n)) proc.start() proc.join() print(x.value) print(arr) print(l) print(d) print(n)6.同步子进程模块6.1 Lock（互斥锁）​ Lock锁的作用是当多个进程需要访问共享资源的时候，避免访问的冲突。加锁保证了多个进程修改同一块数据时，同一时间只能有一个修改，即串行的修改，牺牲了速度但保证了数据安全。Lock包含两种状态——锁定和非锁定，以及两个基本的方法。构造方法：Lock()实例方法： acquire([timeout]): 使线程进入同步阻塞状态，尝试获得锁定。 release(): 释放锁。使用前线程必须已获得锁定，否则将抛出异常。使用示例：from multiprocessing import Process, Lockdef l(lock, num): lock.acquire() print(&quot;Hello Num: %s&quot; % (num)) lock.release()if __name__ == &#39;__main__&#39;: lock = Lock() # 这个一定要定义为全局 for num in range(20): Process(target=l, args=(lock, num)).start()6.2 RLock（可重入的互斥锁)RLock（可重入锁,即同一个进程可以多次获得它，同时不会造成阻塞）是一个可以被同一个进程请求多次的同步指令。RLock使用了“拥有的线程”和“递归等级”的概念，处于锁定状态时，RLock被某个线程拥有。拥有RLock的线程可以再次调用acquire()，释放锁时需要调用release()相同次数。可以认为RLock包含一个锁定池和一个初始值为0的计数器，每次成功调用 acquire() / release()，计数器将+1/-1，为0时锁处于未锁定状态。构造方法：` RLock()`实例方法： acquire([timeout])：同Lock release(): 同Lock6.3 Semaphore（信号量）​ 信号量是一个更高级的锁机制。信号量内部有一个计数器而不像锁对象内部有锁标识，而且只有当占用信号量的线程数超过信号量时线程才阻塞。这允许了多个线程可以同时访问相同的代码区。​ 比如厕所有3个坑，那最多只允许3个人上厕所，后面的人只能等里面有人出来了才能再进去，如果指定信号量为3，那么来一个人获得一把锁，计数加1，当计数等于3时，后面的人均需要等待。一旦释放，就有人可以获得一把锁。构造方法：Semaphore([value]) value：设定信号量，默认值为1实例方法： acquire([timeout])：同Lock release(): 同Lock使用示例：from multiprocessing import Process, Semaphoreimport time, randomdef go_wc(sem, user): sem.acquire() print(&#39;%s 占到一个茅坑&#39; % user) time.sleep(random.randint(0, 3)) sem.release() print(user, &#39;OK&#39;)if __name__ == &#39;__main__&#39;: sem = Semaphore(2) p_l = [] for i in range(5): p = Process(target=go_wc, args=(sem, &#39;user%s&#39; % i,)) p.start() p_l.append(p) for i in p_l: i.join()6.4 Condition（条件变量）​ 可以把Condition理解为一把高级的锁，它提供了比Lock, RLock更高级的功能，允许我们能够控制复杂的线程同步问题。Condition在内部维护一个锁对象（默认是RLock），可以在创建Condigtion对象的时候把琐对象作为参数传入。Condition也提供了acquire, release方法，其含义与锁的acquire, release方法一致，其实它只是简单的调用内部锁对象的对应的方法而已。Condition还提供了其他的一些方法。构造方法：Condition([lock/rlock]) 可以传递一个Lock/RLock实例给构造方法，否则它将自己生成一个RLock实例。实例方法： acquire([timeout])：首先进行acquire，然后判断一些条件。如果条件不满足则wait release()：释放 Lock wait([timeout]): 调用这个方法将使线程进入Condition的等待池等待通知，并释放锁。使用前线程必须已获得锁定，否则将抛出异常。处于wait状态的线程接到通知后会重新判断条件。 notify(): 调用这个方法将从等待池挑选一个线程并通知，收到通知的线程将自动调用acquire()尝试获得锁定（进入锁定池）；其他线程仍然在等待池中。调用这个方法不会释放锁定。使用前线程必须已获得锁定，否则将抛出异常。 notifyAll(): 调用这个方法将通知等待池中所有的线程，这些线程都将进入锁定池尝试获得锁定。调用这个方法不会释放锁定。使用前线程必须已获得锁定，否则将抛出异常。使用示例：import multiprocessingimport timedef stage_1(cond): &quot;&quot;&quot; perform first stage of work, then notify stage_2 to continue &quot;&quot;&quot; name = multiprocessing.current_process().name print(&#39;Starting&#39;, name) with cond: print(&#39;{} done and ready for stage 2&#39;.format(name)) cond.notify_all() def stage_2(cond): &quot;&quot;&quot; wait for the condition telling us stage_1 is done &quot;&quot;&quot; name = multiprocessing.current_process().name print(&#39;Starting&#39;, name) with cond: cond.wait() print(&#39;{} running&#39;.format(name))if __name__ == &#39;__main__&#39;: condition = multiprocessing.Condition() s1 = multiprocessing.Process(name=&#39;s1&#39;, target=stage_1, args=(condition,)) s2_clients = [ multiprocessing.Process( name=&#39;stage_2[{}]&#39;.format(i), target=stage_2, args=(condition,), ) for i in range(1, 3) ] for c in s2_clients: c.start() time.sleep(1) s1.start() s1.join() for c in s2_clients: c.join()6.5 Event（事件）​ Event内部包含了一个标志位，初始的时候为false。可以使用set()来将其设置为true；或者使用clear()将其从新设置为false；可以使用is_set()来检查标志位的状态；​ 另一个最重要的函数就是wait(timeout=None)，用来阻塞当前线程，直到event的内部标志位被设置为true或者timeout超时。如果内部标志位为true则wait()函数立即返回。使用示例：import multiprocessingimport timedef wait_for_event(e): &quot;&quot;&quot; Wait for the event to be set before doing anything &quot;&quot;&quot; print(&#39;wait_for_event: starting&#39;) e.wait() print(&#39;wait_for_event: e.is_set()-&amp;gt;&#39;, e.is_set())def wait_for_event_timeout(e, t): &quot;&quot;&quot; Wait t seconds and then timeout &quot;&quot;&quot; print(&#39;wait_for_event_timeout: starting&#39;) e.wait(t) print(&#39;wait_for_event_timeout: e.is_set()-&amp;gt;&#39;, e.is_set())if __name__ == &#39;__main__&#39;: e = multiprocessing.Event() w1 = multiprocessing.Process( name=&#39;block&#39;, target=wait_for_event, args=(e,), ) w1.start() w2 = multiprocessing.Process( name=&#39;nonblock&#39;, target=wait_for_event_timeout, args=(e, 2), ) w2.start() print(&#39;main: waiting before calling Event.set()&#39;) time.sleep(3) e.set() print(&#39;main: event is set&#39;)参考链接：https://mp.weixin.qq.com/s/tPH2CkR4OPLqv0M9K9fzKA" }, { "title": "Python基操-格式化基操", "url": "/posts/Python-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%9F%BA%E6%93%8D/", "categories": "Python", "tags": "Python基操", "date": "2020-03-28 00:00:00 +0800", "snippet": "Python在处理文字、数字等工程领域内的文字符号输出时，需要用到格式化内容。本文主要总结python中format的用法，足以满足输出的需要。第一部分 python格式化Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能。基本语法是通过 {} 和 : 来代替以前的 %。format 函数可以接受不限个参数，位置可以不按顺序。# format 或者 % # 提到Python中的格式化输出方法，一般来说有以下两种方式：print(&#39;hello %s&#39; % &#39;world&#39;)# hello worldprint(&#39;hello {}&#39;.format(&#39;world&#39;))# hello world个人认为format更好用，所以墙裂推荐。第二部分 基本用法print(&#39;{} {}&#39;.format(&#39;hello&#39;, &#39;world&#39;)) # 最基本的print(&#39;{0} {1}&#39;.format(&#39;hello&#39;, &#39;world&#39;)) # 通过位置参数print(&#39;{0} {1} {0}&#39;.format(&#39;hello&#39;, &#39;world&#39;)) # 单个参数多次输出&amp;gt;&amp;gt;&amp;gt;hello worldhello worldhello world hello关键词定位# 通过关键词参数print(&#39;我的名字是{name},我今年{age}岁了。&#39;.format(name=&#39;小明&#39;, age=&#39;12&#39;))# 与位置参数一样，单个参数也能多次输出print(&#39;{name}说：&quot;我的名字是{name},我今年{age}岁了。&quot;&#39;.format(name=&#39;小明&#39;, age=&#39;12&#39;))&amp;gt;&amp;gt;&amp;gt;我的名字是小明,我今年12岁了。小明说：&quot;我的名字是小明,我今年12岁了。&quot;可变参数既然format()是一个方法，那是不是也接受*args和**kwargs形式的传参呢，答案是肯定的。# 传入list，通过使用解包符号*data = [&#39;hello&#39;, &#39;world&#39;]print(&#39;{0} {1}&#39;.format(*data))# 传入dictdata = {&#39;name&#39;: &#39;小明&#39;, &#39;age&#39;: 12}print(&#39;我的名字是{name},我今年{age}岁了。&#39;.format(**data))# 混用data_1 = [&#39;hello&#39;, &#39;world&#39;]data_2 = {&#39;name&#39;: &#39;小明&#39;, &#39;age&#39;: 12}print(&#39;{0} {1} 我的名字是{name},我今年{age}岁了,{0}!&#39;.format(*data_1, **data_2))&amp;gt;&amp;gt;&amp;gt; hello world我的名字是小明,我今年12岁了。hello world 我的名字是小明,我今年12岁了,hello!固定宽度format()可以指定输出宽度为多少，当字符串长度少于设定值的时候，默认用空格填充：data = [{&#39;name&#39;: &#39;Mary&#39;, &#39;college&#39;: &#39;Tsinghua University&#39;}, {&#39;name&#39;: &#39;Micheal&#39;, &#39;college&#39;: &#39;Harvard University&#39;}, {&#39;name&#39;: &#39;James&#39;, &#39;college&#39;: &#39;Massachusetts Institute of Technology&#39;}]# 固定宽度输出for item in data: print(&#39;{:10}{:40}&#39;.format(item[&#39;name&#39;], item[&#39;college&#39;]))&amp;gt;&amp;gt;&amp;gt; Mary Tsinghua University Micheal Harvard University James Massachusetts Institute of Technology 当然除了空格，我们也可以选择其他字符来填充，譬如我想打印一条分割线,便可以选择通过-来填充：data = [{&#39;name&#39;: &#39;Mary&#39;, &#39;college&#39;: &#39;Tsinghua University&#39;}, {&#39;name&#39;: &#39;Micheal&#39;, &#39;college&#39;: &#39;Harvard University&#39;}, {&#39;name&#39;: &#39;James&#39;, &#39;college&#39;: &#39;Massachusetts Institute of Technology&#39;}]# 固定宽度输出for item in data: # 每输出一条记录之前打印一条分割线 # 选择用其他字符来填充时需要指定对齐方式 print(&#39;{:-^60}&#39;.format(&#39;我是分割线&#39;)) print(&#39;{:10}{:40}&#39;.format(item[&#39;name&#39;], item[&#39;college&#39;]))&amp;gt;&amp;gt;&amp;gt; ---------------------------我是分割线----------------------------Mary Tsinghua University ---------------------------我是分割线----------------------------Micheal Harvard University ---------------------------我是分割线----------------------------James Massachusetts Institute of Technology 对齐方式format()支持左对齐，右对齐，居中，分别对应&amp;lt;，&amp;gt;，^，具体怎么使用我们看实例：data = [{&#39;name&#39;: &#39;Mary&#39;, &#39;college&#39;: &#39;Tsinghua University&#39;}, {&#39;name&#39;: &#39;Micheal&#39;, &#39;college&#39;: &#39;Harvard University&#39;}, {&#39;name&#39;: &#39;James&#39;, &#39;college&#39;: &#39;Massachusetts Institute of Technology&#39;}]print(&#39;{:-^50}&#39;.format(&#39;居中&#39;))for item in data: print(&#39;{:^10}{:^40}&#39;.format(item[&#39;name&#39;], item[&#39;college&#39;]))print(&#39;{:-^50}&#39;.format(&#39;左对齐&#39;))for item in data: print(&#39;{:&amp;lt;10}{:&amp;lt;40}&#39;.format(item[&#39;name&#39;], item[&#39;college&#39;]))print(&#39;{:-^50}&#39;.format(&#39;右对齐&#39;))for item in data: print(&#39;{:&amp;gt;10}{:&amp;gt;40}&#39;.format(item[&#39;name&#39;], item[&#39;college&#39;]))&amp;gt;&amp;gt;&amp;gt; ------------------------居中------------------------ Mary Tsinghua University Micheal Harvard University James Massachusetts Institute of Technology -----------------------左对齐------------------------Mary Tsinghua University Micheal Harvard University James Massachusetts Institute of Technology -----------------------右对齐------------------------ Mary Tsinghua University Micheal Harvard University James Massachusetts Institute of Technology数字格式化常用的示例如下：# 取小数点后两位num = 3.1415926print(&#39;小数点后两位：{:.2f}&#39;.format(num))# 带+/-输出num = -3.1415926print(&#39;带正/负符号：{:+.2f}&#39;.format(num))# 转为百分比num = 0.34534print(&#39;百分比：{:.2%}&#39;.format(num))# 科学计数法num = 12305800000print(&#39;科学计数法：{:.2e}&#39;.format(num))# ,分隔num = 12305800000print(&#39;&quot;,&quot;分隔：{:,}&#39;.format(num))# 转为二进制num = 15print(&#39;二进制：{:b}&#39;.format(num))# 十六进制num = 15print(&#39;十六进制：{:x}&#39;.format(num))# 八进制num = 15print(&#39;八进制：{:o}&#39;.format(num))&amp;gt;&amp;gt;&amp;gt; 小数点后两位：3.14带正/负符号：-3.14百分比：34.53%科学计数法：1.23e+10&quot;,&quot;分隔：12,305,800,000二进制：1111十六进制：f八进制：17 数字 格式 输出 描述 3.1415926 {:.2f} 3.14 保留小数点后两位 3.1415926 {:+.2f} +3.14 带符号保留小数点后两位 -1 {:+.2f} -1.00 带符号保留小数点后两位 2.71828 {:.0f} 3 不带小数 5 {:0&amp;gt;2d} 05 数字补零 (填充左边, 宽度为2) 5 {:x&amp;lt;4d} 5xxx 数字补x (填充右边, 宽度为4) 10 {:x&amp;lt;4d} 10xx 数字补x (填充右边, 宽度为4) 1000000 {:,} 1,000,000 以逗号分隔的数字格式 0.25 {:.2%} 25.00% 百分比格式 1000000000 {:.2e} 1.00e+09 指数记法 13 {:&amp;gt;10d} 13 右对齐 (默认, 宽度为10) 13 {:&amp;lt;10d} 13 左对齐 (宽度为10) 13 {:^10d} 13 中间对齐 (宽度为10) ^, &amp;lt;, &amp;gt; 分别是居中、左对齐、右对齐，后面带宽度， : 号后面带填充的字符，只能是一个字符，不指定则默认是用空格填充。+ 表示在正数前显示 +，负数前显示 -； （空格）表示在正数前加空格b、d、o、x 分别是二进制、十进制、八进制、十六进制。输出花括号当然，如果我们想输出的{}的时候怎么办呢？# 输出花括号print(&#39;我是 }&#39;.format(&#39;Awesome_Tang&#39;))&amp;gt;&amp;gt;&amp;gt;我是{Awesome_Tang}花式玩法其实结合以上这些特性，我们可以来点好玩点，譬如说自己写一个进度条：import timelength = 1000for i in range(1, length + 1): percent = i / length bar = &#39;▉&#39; * int(i // (length / 50)) time.sleep(0.01) print(&#39;\\r进度条：|{:&amp;lt;50}|{:&amp;gt;7.1%}&#39;.format(bar, percent), end=&#39;&#39;)print(&#39;\\n&#39;)进度条：|▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉ | 34.5%第三部分 补充使用f和{}的组合，轻松操作格式化字符age = int(input(&quot;Please input your age:&quot;))name = input(&quot;Please input your name:&quot;)print(f&quot;Ok,your name is {age}, and your age is {name}.&quot; )参考链接：https://www.runoob.com/python/att-string-format.html" }, { "title": "Python基操-datetime", "url": "/posts/pyhton-datetime%E5%9F%BA%E6%93%8D/", "categories": "Python", "tags": "Python基操", "date": "2020-03-27 00:00:00 +0800", "snippet": "Python 中的datetime模块，时间获取、时间转换等常用的用法。第一部分 总体概览datetime是一个关于时间的库，主要包含的类有： 类名 功能说明 date 日期对象,常用的属性有year, month, day time 时间对象 datetime 日期时间对象,常用的属性有hour, minute, second, microsecond datetime_CAPI 日期时间对象C语言接口 timedelta 时间间隔，即两个时间点之间的长度 tzinfo 时区信息对象 第二部分 模块常用1. date模块# 获取当前日期 ，返回值是时间特有的date格式，里面包括了year，month和day,通过点号获取import datetime&amp;gt;&amp;gt;&amp;gt; tyday = datetime.date.today()&amp;gt;&amp;gt;&amp;gt; tydaydatetime.date(2022, 1, 23)&amp;gt;&amp;gt;&amp;gt; tyday.year2022# 日期转换为字符串,这里是通过转换为符合ISO 8601标准 (YYYY-MM-DD) 的日期字符串&amp;gt;&amp;gt;&amp;gt; tyday.isoformat()&#39;2022-01-23&#39;# 拆分日期,方便取用&amp;gt;&amp;gt;&amp;gt; spday = tyday.isocalendar()(2022, 3, 7)&amp;gt;&amp;gt;&amp;gt; spday[0]2022# 构造需要的时间 [直接输入]&amp;gt;&amp;gt;&amp;gt; wantday = datetime.date(2017,3,22)&amp;gt;&amp;gt;&amp;gt; wantdaydatetime.date(2017, 3, 22)# 构造需要的时间 [从时间戳构建]&amp;gt;&amp;gt;&amp;gt; import time&amp;gt;&amp;gt;&amp;gt; time.time()1642932611.3631077&amp;gt;&amp;gt;&amp;gt; datetime.date.fromtimestamp(time.time())datetime.date(2022, 1, 23)# 判断一周的第几天，isoweekday(...): 返回符合ISO标准的指定日期所在的星期数（周一为1，周二为2，....,周日为7) &amp;gt;&amp;gt;&amp;gt; wantday.isoweekday()3实例now = datetime.date( 2010 , 4 , 6 ) tomorrow = now.replace(day = 7 ) print (&#39;now:&#39; , now, &#39;, tomorrow:&#39; , tomorrow )print (&#39;isoweekday():&#39; , now.isoweekday() )# 拆散时间，转换为元祖形式，方便取用print (&#39;isocalendar():&#39; , now.isocalendar() )print (&#39;isoformat():&#39; , now.isoformat())# # ---- 结果 ---- # now: 2010-04-06 , tomorrow: 2010-04-07 # weekday(): 1 # isocalendar(): (2010, 14, 2) # isoformat(): 2010-04-062. time模块这个模块个人觉得过于鸡肋，因为datetime.datetime包含了里面的内容，所以不总结了，下一个# hour的范围为[0, 24)，# minute的范围为[0, 60)，# second的范围为[0, 60)，# microsecond的范围为[0, 1000000)3. datatime模块# 获取当前时间（本地），这个时间包含： 年、月、日、时、分、秒、微秒 共7个量# 分别对应取用 year、month、day、hour、minute、second、microsecond&amp;gt;&amp;gt;&amp;gt; from datetime import datetime&amp;gt;&amp;gt;&amp;gt; now = datetime.now()&amp;gt;&amp;gt;&amp;gt; nowdatetime.datetime(2022, 1, 23, 18, 35, 57, 666123)# 获取协调世界时,即世界标准时(取代格林威治时间)&amp;gt;&amp;gt;&amp;gt; datetime.datetime.now()datetime.datetime(2022, 1, 23, 18, 57, 54, 313232)&amp;gt;&amp;gt;&amp;gt; datetime.datetime.utcnow()datetime.datetime(2022, 1, 23, 10, 57, 54, 313232)# 构造需要的时间 [直接输入]&amp;gt;&amp;gt;&amp;gt; datetime.datetime(2017, 3, 22, 16, 55, 49, 148233)datetime.datetime(2017, 3, 22, 16, 55, 49, 148233)# 构造需要的时间 [从时间戳构建，获取时间标准时间；本地时间直接获取就行了]&amp;gt;&amp;gt;&amp;gt; datetime.datetime.utcfromtimestamp(time.time())datetime.datetime(2017, 3, 22, 8, 29, 7, 654272)# 构造需要的时间 [从字符串构建]， 记忆：这个中间是p，[datetime parsed from a string]# 这里需要指定两个参量： 时间字符串、字符串格式&amp;gt;&amp;gt;&amp;gt; datetime.datetime.strptime(&#39;2017-3-22 15:25&#39;,&#39;%Y-%m-%d %H:%M&#39;)datetime.datetime(2017, 3, 22, 15, 25)# 格式化日期，字符串输出，记忆：这个中间是f，strftime， str format time&amp;gt;&amp;gt;&amp;gt; td = datetime.datetime.now()&amp;gt;&amp;gt;&amp;gt; print(td.strftime(&quot;%Y-%m-%d&quot;))2022-01-23# 格式化时间,字符串输出&amp;gt;&amp;gt;&amp;gt; td = datetime.datetime.now()&amp;gt;&amp;gt;&amp;gt; print(td.strftime(&quot;%H:%M:%S&quot;))19:09:48 datetime.min、datetime.max：datetime所能表示的最小值与最大值；datetime.resolution：datetime最小单位；datetime.today()：返回一个表示当前本地时间的datetime对象；datetime.now([tz])：返回一个表示当前本地时间的datetime对象，如果提供了参数tz，则获取tz参数所指时区的本地时间；datetime.utcnow()：返回一个当前utc时间的datetime对象；datetime.fromtimestamp(timestamp[, tz])：根据时间戮创建一个datetime对象，参数tz指定时区信息；datetime.utcfromtimestamp(timestamp)：根据时间戮创建一个datetime对象；datetime.combine(date, time)：根据date和time，创建一个datetime对象；datetime.strptime(date_string, format)：将格式字符串转换为datetime对象；实例dt = datetime.now() print ((%Y-%m-%d %H:%M:%S %f): &#39; , dt.strftime( &#39;%Y-%m-%d %H:%M:%S %f&#39; ))print ((%Y-%m-%d %H:%M:%S %p): &#39; , dt.strftime( &#39;%y-%m-%d %I:%M:%S %p&#39; )) print (%%a: %s &#39; % dt.strftime( &#39;%a&#39; ) )print (%%A: %s &#39; % dt.strftime( &#39;%A&#39; ) )print (%%b: %s &#39; % dt.strftime( &#39;%b&#39; )) print (%%B: %s &#39; % dt.strftime( &#39;%B&#39; ) )print (日期时间%%c: %s &#39; % dt.strftime( &#39;%c&#39; ) )print (日期%%x：%s &#39; % dt.strftime( &#39;%x&#39; ) )print (时间%%X：%s &#39; % dt.strftime( &#39;%X&#39; ) )print (今天是这周的第%s天 &#39; % dt.strftime( &#39;%w&#39; ) )print (今天是今年的第%s天 &#39; % dt.strftime( &#39;%j&#39; ) )print (今周是今年的第%s周 &#39; % dt.strftime( &#39;%U&#39; )) # # ---- 结果 ---- # (%Y-%m-%d %H:%M:%S %f): 2010-04-07 10:52:18 937000 # (%Y-%m-%d %H:%M:%S %p): 10-04-07 10:52:18 AM # %a: Wed # %A: Wednesday # %b: Apr # %B: April # 日期时间%c: 04/07/10 10:52:18 # 日期%x：04/07/10 # 时间%X：10:52:18 # 今天是这周的第3天 # 今天是今年的第097天 # 今周是今年的第14周 第三部分 格式化字符的意义%a 星期的简写。如 星期三为Web|%A 星期的全写。如 星期三为Wednesday|%b 月份的简写。如4月份为Apr%B 月份的全写。如4月份为April%c: 日期时间的字符串表示。（如： 04/07/10 10:43:39）%d: 日在这个月中的天数（是这个月的第几天）%f: 微秒（范围[0,999999]）%H: 小时（24小时制，[0, 23]）%I: 小时（12小时制，[0, 11]）%j: 日在年中的天数 [001,366]（是当年的第几天）%m: 月份（[01,12]）%M: 分钟（[00,59]）%p: AM或者PM%S: 秒（范围为[00,61]，为什么不是[00, 59]，参考python手册~_~）%U: 周在当年的周数当年的第几周），星期天作为周的第一天%w: 今天在这周的天数，范围为[0, 6]，6表示星期天%W: 周在当年的周数（是当年的第几周），星期一作为周的第一天%x: 日期字符串（如：04/07/10）%X: 时间字符串（如：10:43:39）%y: 2个数字表示的年份%Y: 4个数字表示的年份%z: 与utc时间的间隔 （如果是本地时间，返回空字符串）%Z: 时区名称（如果是本地时间，返回空字符串）%%: %% =&amp;gt; %" }, { "title": "Python基操-os", "url": "/posts/python-os%E5%9F%BA%E6%93%8D/", "categories": "Python", "tags": "Python基操", "date": "2020-03-26 00:00:00 +0800", "snippet": "Python中OS模块对文件路径、文件夹、文件的操作1.获取当前路径os.getcwd()2. 改变文件夹路径os.chdir(path)3. 获取文件夹下所有文件os.listdir()4. 生成文件夹和生成多层文件夹mkdir() # Use for making one directorymakedirs() # Use if you want to create multiple directories at once5. 删除文件夹和删除指定的文件夹rmdir(file) # Recommended use caseremovedirs(file) # Removes intermediate directories if specified6. 重命名文件名os.rename(&quot;test.txt&quot;, &quot;demo.txt&quot;) # This renames text.txt to demo.txt7. 查看文件状态（如文件大小，修改时间等）os.stat(test.txt)Useful stat results: st_size (bytes), st_mtime (time stamp)8. 文件树目录 （用于遍历）for dirpath, dirnames, filenames in os.walk(routepath): print(&quot;Current Path:&quot;, dirpath) print(&quot;Directories:&quot;, dirnames) print(&quot;Files:&quot;, filenames)9. 主目录os.environ.get(&quot;HOME&quot;). # Returns a path# 文件路径的构造 (常用)file_path = os.path.join(os.environ.get(&quot;HOME&quot;), &quot;test.txt&quot;)10. OS 对文件路径的操作# 常用os.path.split()# 返回文件路径最后一条斜线前的路径,即os.path.split(path)的第一个元素os.path.dirname(&quot;/tmp/test.txt&quot;)eg : &amp;gt;&amp;gt;&amp;gt; path = &#39;/Users/beazley/Data/data.csv&#39; &amp;gt;&amp;gt;&amp;gt; os.path.dirname(path) &#39;/Users/beazley/Data&#39; os.path.basename(path)# 返回文件路径最后一条斜线后的文件名字,即os.path.split(path)的第二个元素eg : &amp;gt;&amp;gt;&amp;gt; path = &#39;/Users/beazley/Data/data.csv&#39; &amp;gt;&amp;gt;&amp;gt; # Get the last component of the path &amp;gt;&amp;gt;&amp;gt; os.path.basename(path) &#39;data.csv&#39;# 常用，返回元祖,包含了上面 basename 和 dirname 的内容dirname, basename = os.path.split(&quot;/tmp/test.txt&quot;)eg: &amp;gt;&amp;gt;&amp;gt; path = &#39;/Users/beazley/Data/data.csv&#39; &amp;gt;&amp;gt;&amp;gt; os.path.split(path) (&#39;/Users/beazley/Data&#39;, &#39;data.csv&#39;)判断文件是否存在# 返回布尔值 os.path.exists(&quot;/tmp/test.txt&quot;)判断是否为文件夹# 返回布尔值 os.path.isdir(&quot;/tmp/test.txt&quot;)判断是否为文件# 返回布尔值 os.path.isfile(&quot;/tmp/test.txt&quot;)11. 文件名后缀分割提取os.path.splitext(‘/tmp/test.txt’)" } ]
